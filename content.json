{"meta":{"title":"逃避可耻但很有用","subtitle":null,"description":"fix myself","author":"fromzero","url":"https://luwenjie.me"},"pages":[{"title":"","date":"2017-07-02T05:30:37.000Z","updated":"2017-06-13T07:05:26.000Z","comments":true,"path":"404.html","permalink":"https://luwenjie.me/404.html","excerpt":"","text":""},{"title":"","date":"2016-12-22T07:27:45.000Z","updated":"2017-06-13T07:12:06.000Z","comments":true,"path":"categories/index.html","permalink":"https://luwenjie.me/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-12-22T07:27:45.000Z","updated":"2017-07-20T10:33:58.000Z","comments":false,"path":"about/index.html","permalink":"https://luwenjie.me/about/index.html","excerpt":"","text":"爱生活，爱 Android，爱 gakki，爱麻酱，爱濑遥，爱村花，爱吧花。"},{"title":"","date":"2016-12-22T07:27:45.000Z","updated":"2017-06-13T07:10:07.000Z","comments":true,"path":"tags/index.html","permalink":"https://luwenjie.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Kotlin-Learning 基础类型","slug":"Kotlin-Learning 基础类型","date":"2018-02-05T08:08:00.000Z","updated":"2018-02-05T08:16:50.623Z","comments":true,"path":"2018/02/05/Kotlin-Learning 基础类型/","link":"","permalink":"https://luwenjie.me/2018/02/05/Kotlin-Learning 基础类型/","excerpt":"数值在 Kotlin 一切都是对象。包括基础类型。 Double: 64位 Float: 32位 Long： 64位 Int: 32位 Short：16位 Byte: 8位 在 kotlin 中 字符不是一个数值。","text":"数值在 Kotlin 一切都是对象。包括基础类型。 Double: 64位 Float: 32位 Long： 64位 Int: 32位 Short：16位 Byte: 8位 在 kotlin 中 字符不是一个数值。 字面常量 十进制：123 长整型要加大写的L：123L 16进制：0x0f 2进制：0b000001011 不支持8进制 浮点： 默认双精度（Double）：123.3，123333.43e13 单精度浮点数（Float）添加 f 或 F：1233.4F 可以使用下划线分割常量1val oneMillion = 1_000_000 表示通常数值被 JVM 以字节码物理存储。 有可空标识(Int?)或者泛型时，数值会被装箱。 1234567val a: Int = 10000print (a === a ) // 打印 &apos;true&apos; // 被装箱了。boxedA 和 anotherBoxedA 是两个不同的对象。val boxedA: Int? =aval anotherBoxedA: Int? = aprintln (boxedA === anotherBoxedA ) // 输出 false 类型转换每个数值类型都支持下面的转换：12345678910111213toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 位操作只能用于 Int 和 Long 1234567891011121314// shl(bits) – 左移 (等于 Java 的 &lt;&lt;) 1.sh1(2)// shr(bits) – 右移 (等于 Java 的 &gt;&gt;)1.shr(1)// ushr(bits) – 无符号右移 (等于 Java 的 &gt;&gt;&gt;)-12.unhr(2)// and(bits) – 按位与 (等于 Java 的 &amp;)2.and(2)// or(bits) – 按位或 (等于 Java 的 |)2.or(3)// xor(bits) – 按位异或 (等于 Java 的 ^)2.xor(4)// inv() – 按位取反 (等于 Java 的 ~) : 是个方法23.inv() 字符使用 Char 类表示。不能直接当做数值使用。 1public class Char private constructor() : Comparable&lt;Char&gt; 布尔值只有 true false。如果需要可空引用，可以装箱。 数组用 Array 类表示。 1public class Array&lt;T&gt; 可以使用静态方法 arrayof, arrayOfNulls ，emptyArray 创建数组。 123456// 创建数组val array = arrayOf(\"we\", 1, \"da\")// 创建空数组val emptyArray = emptyArray&lt;Any&gt;()// 创建默认是 null 填充的数组val arrayOfNulls = arrayOfNulls&lt;Any&gt;(4) Array 有一个特殊的构造函数。 1public inline constructor(size: Int, init: (Int) -&gt; T) 传入 size 和初始化数据的闭包。 12345678// 表示创建一个数量为 3，下标是偶数就填充 i*，奇数就填充 i。val array = Array(3, &#123; i -&gt; if (i % 2 == 0) &#123; (i * i).toString() &#125; else &#123; i.toString() &#125;&#125;) 如果初始化的闭包里面什么都不写，默认就是创建了 3 个 Unit 类型的对象。1val a = Array(3, &#123;&#125;) [] 可以代替 get set 方法。 Array 的类型不可变的，Array&lt;String&gt; 不可以被强转。 ByteArray,ShortArray,IntArray。这几个类表示原始类型的数组，不需要装箱操作。这些类和 Array 没有继承关系，但是方法都一样。 StringString 和 Java 一样不可变的。可以赢下标访问字符串的元素字符。可以用 for 循环遍历 123for (i in s)&#123; println(i)&#125; 带转义符的字符串：1val s = &quot;hello world!\\n&quot; 整行字符串：使用 &quot;&quot;&quot; 包裹，不能有转义符，可以换行 1val text = \"\"\"for (c in \"foo\") print(c)\"\"\" 移除空格123456val text = \"\"\" |for (c in \"foo\") | print(c) | \"\"\".trimMargin() println(text)&#125; 默认用| 作为每一行的起始前缀。也可以自定义 trimMargin(&quot;d&quot;) 只能传一个字符。 字符串模板使用 ${} 表示代码片段。只有一个变量时 {} 可以省略，$a 在不可以转义的整行字符串中表示 $ 12val text2 = \"\"\"$&#123;'$'&#125; 9.99\"\"\".trimMargin()println(text2)","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"Kotlin-Learning 控制流","slug":"Kotlin-Learning 控制流","date":"2018-02-02T03:21:00.000Z","updated":"2018-02-02T03:22:15.919Z","comments":true,"path":"2018/02/02/Kotlin-Learning 控制流/","link":"","permalink":"https://luwenjie.me/2018/02/02/Kotlin-Learning 控制流/","excerpt":"ifkotlin 没有三元表达式。直接返回一个值。","text":"ifkotlin 没有三元表达式。直接返回一个值。 // 传统用法12345678910111213141516fun ifFlow(a: Int, b: Int) &#123; // 传统写法 var max = a if (a &lt; b) max = b // else var max2: Int if (a &gt; b) &#123; max2 = a &#125; else &#123; max2 = b &#125; // 作为表达式 val max3 = if (a &gt; b) a else b&#125; 代码块的最后一行作为返回值：123456789101112fun ifBlock(a: Int, b: Int) &#123; // 代码块最后一行表达式的值就是 max 的值 val max = if (a &gt; b) &#123; print(&quot;Choose a&quot;) a &#125; else &#123; print(&quot;Choose b&quot;) b &#125; println(&quot;max = $max&quot;)&#125; whenwhen 代替了 switch 。 1234567when (x) &#123; 1 -&gt; print(&quot;x == 1&quot;) 2 -&gt; print(&quot;x == 2&quot;) else -&gt; &#123; // Note the block print(&quot;x is neither 1 nor 2&quot;) &#125;&#125; 可以用逗号分隔条件 1234when (x) &#123; 0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;) else -&gt; print(&quot;otherwise&quot;)&#125; 可以用任意的表达式作为判断 1234when (x) &#123; parseInt(s) -&gt; print(&quot;s encodes x&quot;) else -&gt; print(&quot;s does not encode x&quot;)&#125; 可以用 in 检查是否在一个区间内 123456when (x) &#123; in 1..10 -&gt; print(&quot;x is in the range&quot;) in validNumbers -&gt; print(&quot;x is valid&quot;) !in 10..20 -&gt; print(&quot;x is outside the range&quot;) else -&gt; print(&quot;none of the above&quot;)&#125; 用 is 作为条件，判断是否是 String。不需要强转类型。 判断语句返回的都是 Boolean 类型，返回值可以省略1234fun hasPrefix(x:Any) = when(x)&#123; is String -&gt; x.startsWith(&quot;prefix&quot;) else -&gt; false&#125; when 可以代替 if else 语句 1234567fun replaceIfWithWhen(x: Int) &#123; when &#123; x &gt; 0 -&gt; println(&quot;x &gt; 0&quot;) x &lt; 0 -&gt; println(&quot;x &lt; 0&quot;) else -&gt; println(&quot;x = 0&quot;) &#125;&#125; for 循环for 循环迭代器。给提供了迭代器的对象使用。类似 foreach1for (item in collection) print(item) 没有迭代器的根据下标遍历. 类似 java 的 123for(int i;i &lt; size;i++)&#123; &#125; 使用 array.indices 获得一个下标范围。在这个范围里面迭代，底层编译是优化过的，没有额外对象创建。12345fun forLoopByIndex(list:Array&lt;String&gt;)&#123; for (i in list.indices)&#123; println(list[i]) &#125;&#125; 也可以使用 array.withIndex 12345fun forLoopByWithIndex(list:List&lt;String&gt;)&#123; for ((index,value) in list.withIndex())&#123; println(&quot;index = $index , value = $value&quot;) &#125;&#125; while 循环while 语法和 java 是一致的。 1234567while(x&gt;0)&#123; x --&#125;do&#123; val y = retrieveData()&#125;while(y != null) break continue支持传统的 break continue","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"Kotlin-Learning 基本语法","slug":"Kotlin-Learning 基本语法","date":"2018-02-01T10:15:00.000Z","updated":"2018-02-01T10:16:56.576Z","comments":true,"path":"2018/02/01/Kotlin-Learning 基本语法/","link":"","permalink":"https://luwenjie.me/2018/02/01/Kotlin-Learning 基本语法/","excerpt":"包名允许包名和文件路径不一致 为什么kotlin允许包名和文件所在路径不一致？","text":"包名允许包名和文件路径不一致 为什么kotlin允许包名和文件所在路径不一致？ 定义方法1234// 2 个 Int 参数，返回一个 Intfun sum(a:Int, b:Int): Int&#123; return a+b&#125; 12// 一行方法体可以直接简写，不写返回值，由系统推测fun sum(a:Int, b:Int) = a + b 1234// 返回没有意义的值，返回值默认为 Unitfun printSum(a: Int, b: Int): Unit &#123; println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)&#125; 1234// Unit 可以省略fun printSum(a: Int, b: Int)&#123; println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)&#125; 定义变量12345678910// 定义只读变量fun assignLocalVariable()&#123; val a:Int = 1 val b = 2 // 直接初始化具体类型可以省略 val c:Int // 没有初始化需要指定具体类型，否则会报错 c = 4 println(&quot;a = $a, b = $b, c = $c&quot;)&#125; 123456// 定义可变变量fun mutableVariable() &#123; var x = 4 // Int 类型被推测出来 x += 1 println(&quot;x = $x&quot;)&#125; 1234567// 定义全局的变量val PI = 3.14var x = 23fun incrementX() &#123; x += 1&#125; 注释和 Java 一样，支持行尾注释和块注释。但是 Kotlin 的块注释可以嵌套。 12345678910// 行尾注释/** * 块注释 *//* 块注释 块注释 *//* 嵌套块注释 /* 嵌套块注释 */ */ 字符串模板123456789// 字符串模板// 和 groovy 一样使用 $，后面跟变量或者代码块。调用代码fun stringTemplates()&#123; var a = 1 val s1 = &quot;a is $a&quot; a = 2 val s2 = &quot;$&#123;s1.replace(&quot;is&quot;,&quot;was&quot;)&#125;,but now is $a&quot;&#125; 条件语句1234567fun maxOf(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; // 可以简写成 1fun maxOf(a: Int, b: Int) = if (a &gt; b) a else b 使用可为空的类型1234// 返回值后面有个？代表返回值可能为 null，没有？则代表一定不是 nullfun parseInt(str: String): Int? &#123; // ...&#125; 可能为 null 的情况就需要自己处理空值的情况 12345678910111213141516fun printProduct(arg1: String, arg2: String) &#123; val x = parseInt(arg1) val y = parseInt(arg2) if (x == null) &#123; println(&quot;Wrong number format in arg1: &apos;$arg1&apos;&quot;) return &#125; if (y == null) &#123; println(&quot;Wrong number format in arg2: &apos;$arg2&apos;&quot;) return &#125; println(x * y)&#125; 使用类型检查和自动转换1234567891011121314151617181920212223242526fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 不需要像 java 类型强转，Kotlin 自动推测这是 String 类型 return obj.length &#125; return null&#125;fun getStringLength(obj: Any): Int? &#123; if (obj !is String) &#123; return null &#125; // 不需要像 java 类型强转，Kotlin 自动推测这是 String 类型 return obj.length&#125;fun getStringLength(obj: Any): Int? &#123; // 在 is 判断后面的判断都可以自动推测出 String 类型 if (obj is String &amp;&amp; obj.length &gt; 0) &#123; return obj.length &#125; return null&#125; 循环for 循环使用 in 和 index 2 种方式循环。 in 需要对象提供迭代器，类似 java foreach。 12345678910111213fun forLoopIn()&#123; val items = listOf(&quot;apple&quot;,&quot;banana&quot;,&quot;kiwi&quot;) for (item in items)&#123; println(item) &#125;&#125;fun forLoopIndex()&#123; val items = listOf(&quot;apple&quot;,&quot;banana&quot;,&quot;kiwi&quot;) for (i in items.indices)&#123; println(&quot;i = $i, item = $&#123;items[i]&#125;&quot;) &#125;&#125; while 循环while 还是和 java 一样12345678fun whileLoop() &#123; val items = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;) var index = 0 while (index &lt; items.size) &#123; println(&quot;item at $index is $&#123;items[index]&#125;&quot;) index++ &#125;&#125; when 选择语句类似 switch 1234567fun describe(obj: Any) = when (obj) &#123; 1 -&gt; &quot;One&quot; &quot;Hello&quot; -&gt; &quot;Greeting&quot; is Long -&gt; &quot;Long&quot; !is String -&gt; &quot;Not a string&quot; else -&gt; &quot;Unknown&quot;&#125; 区间判断检查一个数是否在一个区间里。用 in 关键字： x..y 表示 [x,y] 的数。包括 x,yy downto x 表示从 y 到 x 开始倒序遍历 step 表示跳过几个数 12345678fun checkNumber() &#123; val x = 1.2 val y = 9 // x 是否在 [1，10] 闭区间 if (x in 1..y + 1) &#123; println(&quot;$x fits in range&quot;) &#125;&#125; 123456789101112131415fun step() &#123; // 按 1 3 5 7 9 跳过 2 个数 for (x in 1..10 step 2) &#123; print(x) &#125;&#125;fun downto()&#123; println() // 9 downTo 0 是 [0,9] 的反序 for (x in 9 downTo 0 step 3) &#123; print(x) &#125;&#125; 集合1234// 具有迭代器对象的集合遍历。类似 foreachfor (item in items) &#123; println(item)&#125; 12345678// 使用 in 判断元素是否在集合中fun checkItem() &#123; val items = setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;) when &#123; &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;) &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;) &#125;&#125; 123456789// 筛选出首字母 a 开头的元素，然后转成大写，打印fun lambdaSample() &#123; println() val fruits = setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwi&quot;) fruits.filter &#123; it.startsWith(&quot;a&quot;) &#125; .sortedBy &#123; it &#125; .map &#123; it.toUpperCase() &#125; .forEach &#123; println(it) &#125;&#125; 实例创建实例不需要 new 关键字。直接是 类名() 1val a = A()","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"理解 OkHttp 的拦截器","slug":"undstandOkhttpInterceptor","date":"2018-01-12T10:16:00.000Z","updated":"2018-01-12T10:16:55.246Z","comments":true,"path":"2018/01/12/undstandOkhttpInterceptor/","link":"","permalink":"https://luwenjie.me/2018/01/12/undstandOkhttpInterceptor/","excerpt":"OkHttp 最精髓的地方就是它的拦截器，把网络请求的操作解耦，每个拦截器只负责自己的工作，并且可以根据自己的需求自定义添加拦截器。第一次看到拦截器那段代码我是懵逼的。","text":"OkHttp 最精髓的地方就是它的拦截器，把网络请求的操作解耦，每个拦截器只负责自己的工作，并且可以根据自己的需求自定义添加拦截器。第一次看到拦截器那段代码我是懵逼的。 12345678910111213141516171819Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest);&#125; 乍一看，就是把一堆拦截器添加到了列表中，然后 new 了一个 Chain 对象启动了一下，这就构成了可以拦截请求拦截响应的拦截器链吗？翻看源码发现主要是通过递归调用函数栈来实现这种往下拦截请求，往上拦截响应的。 我模仿源码拦截器写了一段伪代码方便理解拦截器的工作流程。 首先定义拦截器接口和连接拦截器的锁链接口。 1234567891011121314151617181920public interface MyInterceptor &#123; /** * 拦截 * * @param chain 下一个锁链 */ String intercept(MyChain chain); interface MyChain &#123; /** * 获取请求 */ String request(); /** * 处理请求返回一个结果 */ String process(String request); &#125;&#125; A、B、C 三个拦截器的实现，各自拦截请求和响应1234567891011121314151617181920212223242526272829303132333435363738394041public class InterceptorA implements MyInterceptor &#123; @Override public String intercept(MyChain chain) &#123; // 修改请求 String request = chain.request(); String newRequest = request + \"/a\"; Log.d(\"InterceptorA\", \"newRequest = \" + newRequest); // 调用第2个链子处理新的请求，返回处理后的结果 String response = chain.process(newRequest) + \"/responseA\"; Log.d(\"InterceptorA\", \"response = \" + response); return response; &#125;&#125;public class InterceptorB implements MyInterceptor &#123; @Override public String intercept(MyChain chain) &#123; // 修改请求 String request = chain.request(); String newRequest = request + \"/b\"; Log.d(\"InterceptorB\", \"newRequest = \" + newRequest); // 处理请求 String response = chain.process(newRequest) + \"/responseB\"; Log.d(\"InterceptorB\", \"response = \" + response); return response; &#125;&#125;public class InterceptorC implements MyInterceptor &#123; @Override public String intercept(MyChain chain) &#123; // 修改请求 String request = chain.request(); String newRequest = request + \"/c\"; Log.d(\"InterceptorC\", \"newRequest = \" + newRequest); // 处理请求 String response = chain.process(newRequest) + \"/responseC\"; Log.d(\"InterceptorC\", \"response = \" + response); return response; &#125;&#125; 锁链的实现： 123456789101112131415161718192021222324252627public class RealChain implements MyInterceptor.MyChain &#123; private final String request; private final int index; private final List&lt;MyInterceptor&gt; interceptors; public RealChain(String request, int index, List&lt;MyInterceptor&gt; interceptors) &#123; this.request = request; this.index = index; this.interceptors = interceptors; &#125; @Override public String request() &#123; return request; &#125; @Override public String process(String request) &#123; if (index == interceptors.size()) &#123; return \"请求结束，得到结果：\"; &#125; // 构建下一个锁链实例，处理下一个拦截器 RealChain next = new RealChain(request, index + 1, interceptors); // 得到当前的拦截器 MyInterceptor interceptor = interceptors.get(index); // 当前拦截器进行拦截得到处理结果，将结果返回 return interceptor.intercept(next); &#125;&#125; 关键是调用的时候，从第一个锁链开始往下递归依次调用拦截器的拦截方，按 A -&gt;B-&gt;C 的顺序拦截请求。调用到最后一个拦截器时开始往回按 C-&gt;B-&gt;A 返回结果，这样就构成了官方拦截器图的效果。 1234567891011String getMyInterceptorChain() &#123; List&lt;MyInterceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.add(new InterceptorA()); interceptors.add(new InterceptorB()); interceptors.add(new InterceptorC()); String originRequest = \"www.baidu.com\"; // 构建出锁链 RealChain chain = new RealChain(originRequest, 0, interceptors); return chain.process(originRequest);&#125; 运行后打印日志，请求是按ABC的顺序拦截添加的，返回结果则是CBA的顺序拦截添加的。 123456newRequest = www.baidu.com/anewRequest = www.baidu.com/a/bnewRequest = www.baidu.com/a/b/cresponse = 请求结束，得到结果：/responseCresponse = 请求结束，得到结果：/responseC/responseBresponse = 请求结束，得到结果：/responseC/responseB/responseA 函数调用顺序： 链子A处理 -&gt; 拦截器A拦截 -&gt; 链子B处理 -&gt; 拦截器B拦截 -&gt; 链子C处理 -&gt; 拦截器C拦截 -&gt; 链子C处理 -&gt; end","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"Picasso 加载图片的流程分析","slug":"picasso","date":"2018-01-10T08:18:00.000Z","updated":"2018-01-10T08:44:54.583Z","comments":true,"path":"2018/01/10/picasso/","link":"","permalink":"https://luwenjie.me/2018/01/10/picasso/","excerpt":"Picasso 是一款老牌的图片加载器，特别小巧，功能上虽然比不上 Glide 和 Fresco。但是一般的图片加载需求都能满足。关键是 square 出品，JakeWharton 大神主导的项目，必属精品，和自家的 OkHtttp 无缝衔接。 分析版本： 2.5.2","text":"Picasso 是一款老牌的图片加载器，特别小巧，功能上虽然比不上 Glide 和 Fresco。但是一般的图片加载需求都能满足。关键是 square 出品，JakeWharton 大神主导的项目，必属精品，和自家的 OkHtttp 无缝衔接。 分析版本： 2.5.2123Picasso.with(this) .load(&quot;https://www.kaochong.com/static/imgs/ic_course_logo_92e76ec.png&quot;) .into(imageView); with()看了几个开源库，都是一个套路，先用门面模式提供一个单例给外部访问，这里是 Picasso，其他开源框架如 EventBus，Retrofit 都是一样的。因为开源需要满足很多 feature 避免不了使用一堆参数，建造者模式也是很常见的，几乎每个开源库必备。 12345678910public static Picasso with(Context context) &#123; if (singleton == null) &#123; synchronized (Picasso.class) &#123; if (singleton == null) &#123; singleton = new Builder(context).build(); &#125; &#125; &#125; return singleton;&#125; load()接着看 load 方法: load 有 4 个重载方法： load(Uri) load(String) load(File) load(int) 分别对应加载不同的来源。 这个方法会构造一个 RequestCreator 对象并返回。这个 RequestCreator 看名字就知道，是负责创建图片请求的。RequestCreator 和 Request 的区别在于，Request 是最终创建完成的请求，所有关于图片的信息都在这个请求里，包括图片大小，图片怎么转换，图片是否有渐变动画等等。而 RequestCreator 是一个 Request 的生产者，负责把请求参数组合然后创建成一个 Request。 12345678Picasso.with(this).load(\"url\").placeholder() .resize() .transform() .error() .noFade() .networkPolicy() .centerCrop() .into(imageview); 上面这段代码中，load() 返回的是 RequestCreator 对象，后面从 placeholder() 到 into() 都是 RequestCreator 的中的方法。直到在 into() 中才会把最终图片请求 Request 对象构造出来处理。所以之前都是一堆参数的设置。 以 load(String) 为例看看内部的操作：123456789public RequestCreator load(String path) &#123; if (path == null) &#123; return new RequestCreator(this, null, 0); &#125; if (path.trim().length() == 0) &#123; throw new IllegalArgumentException(\"Path must not be empty.\"); &#125; return load(Uri.parse(path)); &#125; load(String) 其实调用的是 load(Uri):123public RequestCreator load(Uri uri) &#123; return new RequestCreator(this, uri, 0);&#125; RequestCreator 的构造中，传入了 picasso 实例，用传入的 Uri、resourceId、默认 Bitmap 参数在内部构造一个 Request.Builder 实例，用于拼接后续参数最终 build 出一个 Request 实例。12345678RequestCreator(Picasso picasso, Uri uri, int resourceId) &#123; if (picasso.shutdown) &#123; throw new IllegalStateException( \"Picasso instance already shut down. Cannot submit new requests.\"); &#125; this.picasso = picasso; this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);&#125; 后面的 error()、placeholder() 等等就很简单了，就是把参数进行赋值修改。 into()关键的地方来了。into 有 4 个重载方法： into(Target) into(RemoteViews,int,int,Notification) into(RemoteViews,int,int[]) into(ImageView) into(ImageView,Callback) 第 1 个用于实现了 Target 接口的对象，第 2、3 用于 RemoteView 的加载，分别用于通知和桌面小部件。4 和 5 就是我们常用的方法，把图片加载到 ImageView, 区别是 5 有回调。这 5 个流程基本是一样，我们就看 5 来看看加载的具体过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public void into(ImageView target, Callback callback) &#123; // 获取加载的开始时间，纳秒级别的，因为加载很快的 long started = System.nanoTime(); // 检查是否在主线程 checkMain(); // target 不能为空，不然没法加载 if (target == null) &#123; throw new IllegalArgumentException(\"Target must not be null.\"); &#125; // 没图片就设置占位图 if (!data.hasImage()) &#123; picasso.cancelRequest(target); if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; return; &#125; // 如果是 fit 模式，图片自适应控件的大小，需要等 View layout 完确定宽和高再加载。这里采用的是监听 OnPreDraw 接口的方法。 if (deferred) &#123; // fit 模式不能指定图片大小，和 resize 冲突 if (data.hasSize()) &#123; throw new IllegalStateException(\"Fit cannot be used with resize.\"); &#125; int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) &#123; if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; &#125; data.resize(width, height); &#125; // 创建出最终的 Request Request request = createRequest(started); // 创建 Request key 用于缓存 Request String requestKey = createKey(request); // 首先从内存中查找，内存中有就把这个请求取消，直接从内存加载 if (shouldReadFromMemoryCache(memoryPolicy)) &#123; Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) &#123; picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) &#123; log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), \"from \" + MEMORY); &#125; if (callback != null) &#123; callback.onSuccess(); &#125; return; &#125; &#125; // 设置占位图 if (setPlaceholder) &#123; setPlaceholder(target, getPlaceholderDrawable()); &#125; // 构造出 Action Action action = new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade); // 将 Action 入队执行 picasso.enqueueAndSubmit(action);&#125; into 中会检查调用代码是否在主线程，因为要更新 View，还有回调，肯定要在主线程。然后判断是否有图片的源地址，如果给的是个 null，那么直接就终止请求了。如果设置了 fit 模式(自适应 ImageView 的宽和高)，fit 模式和 resize 冲突，既然自适应宽高了，肯定就不能指定宽高。自适应 ImageView 的宽和高需要等待测量完成后得到宽高再继续请求，否则得到的宽高是 0，Picasso 使用 ViewTreeObserver 监听 ImageView 的 OnPreDrawListener 接口来获取宽和高，详细的代码可以看 DeferredRequestCreator 这个类。 然后创建出最终的 Request，此时的 Request 就代表了最终的图片请求信息。然后没有直接去请求，而是去缓存中查找，有的话就直接取消请求从内存中加载。没有的话就创建一个 ImageViewAction , 它是 Action 的子类。加载到不同的 Target 会使用不同的 Action。加载到 Target 使用 TargetAction。加载到通知就使用 NotificationAction。可以去其他的 into 方法中查看源码。 Action是一个抽象类， 内部封装了图片的请求信息，以及当前图片请求的其他参数（缓存策略，网络策略，是否取消了请求，Tag, 是否有动画等等）。需要子类实现 2 个方法： 1234// 解析图片完成后拿到 Bitmap，子类定义如何显示 abstract void complete(Bitmap result, VanGogh.LoadedFrom from);// 解析发送错误 abstract void error(Exception e); 这下可以理解它为啥叫 Action 了，它需要子类自己处理 Bitmap。定义自己的 Action (行为), 成功拿到 Bitmap 怎么办，发生错误了怎么办？ ImageViewAction 的实现很简单，内部通过自定义 BitmapDrawable 来绘制自己的图像，实现渐变。加载错误的时候就放置占位图。 接着看这最后一行picasso.enqueueAndSubmit(action); 看看把 action 扔到哪去处理了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void enqueueAndSubmit(Action action) &#123; Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) &#123; // 取消原来 target 的 action，将新的 action 存入 cancelExistingRequest(target); targetToAction.put(target, action); &#125; submit(action); &#125; void submit(Action action) &#123; dispatcher.dispatchSubmit(action); &#125; void dispatchSubmit(Action action) &#123; handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action)); &#125; void performSubmit(Action action, boolean dismissFailed) &#123; // 处理暂停的请求 if (pausedTags.contains(action.getTag())) &#123; pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), \"because tag '\" + action.getTag() + \"' is paused\"); &#125; return; &#125; // 将 action 合并，action 的 key 是根据 Request 中图片参数生成的， // 这里的意思就是如果图片请求完全一样，只是 Action 不一样，只需要请求一次拿到 Bitmap 就行， // 因为图片信息完全相同，一个 Request 对应了对个 Action BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) &#123; hunter.attach(action); return; &#125; if (service.isShutdown()) &#123; if (action.getPicasso().loggingEnabled) &#123; log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), \"because shut down\"); &#125; return; &#125; // 构造出 hunter hunter = forRequest(action.getPicasso(), this, cache, stats, action); // 扔给线程池执行并获得结果 hunter.future = service.submit(hunter); // 缓存 hunter hunterMap.put(action.getKey(), hunter); // 是否移除请求失败的 Action if (dismissFailed) &#123; failedActions.remove(action.getTarget()); &#125; &#125; 跟踪可以发现交给 Dispatcher 中的 handler 处理了。 在 performSubmit() 中重点看 forRequest() 方法构造出 BitmapHunter 实例。 1234567891011121314static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) &#123; Request request = action.getRequest(); List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers(); for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) &#123; RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) &#123; return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); &#125; &#125; return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);&#125; forRequest() 中遍历所有的 RequestHandler。谁能处理 Action 就处理这个 Action。这是典型的责任链模式-《JAVA与模式》之责任链模式。 在 Picasso 实例初始化的时候就把这些 RequestHandler 都加入了列表中。 1234567891011121314151617181920212223Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers...) &#123; List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount); // ResourceRequestHandler needs to be the first in the list to avoid // forcing other RequestHandlers to perform null checks on request.uri // to cover the (request.resourceId != 0) case. allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) &#123; allRequestHandlers.addAll(extraRequestHandlers); &#125; allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); requestHandlers = Collections.unmodifiableList(allRequestHandlers); &#125; 每个 RequestHandler 重写 canHandleRequest 来表明自己能处理哪种请求。 BitmapHunter 是一个 Runnable, 构造之后交给线程池处理。来看看 BitmapHunter 的 run()。 1234567891011121314151617181920212223242526272829303132333435@Override public void run() &#123; try &#123; updateThreadName(data); // 解析图片得到 Bitmap result = hunt(); // 由 dispatcher 分发解析图片的结果。 if (result == null) &#123; dispatcher.dispatchFailed(this); &#125; else &#123; dispatcher.dispatchComplete(this); &#125; &#125; catch (Downloader.ResponseException e) &#123; if (!e.localCacheOnly || e.responseCode != 504) &#123; exception = e; &#125; dispatcher.dispatchFailed(this); &#125; catch (NetworkRequestHandler.ContentLengthException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (IOException e) &#123; exception = e; dispatcher.dispatchRetry(this); &#125; catch (OutOfMemoryError e) &#123; StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); &#125; catch (Exception e) &#123; exception = e; dispatcher.dispatchFailed(this); &#125; finally &#123; Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); &#125;&#125; 首先由 hunt() 方法解析出 Bitmap，再把解析后的结果交给 Dispatcher 来分发，成功了咋样，失败了咋样，失败了是否重试。Dispatcher 在 Picasso 中扮演了重要的角色，负责整个流程的调度。 看看 hunt() 是怎么解析出 Bitmap 的。首先还是从内存中取，每个 RequestHandler 对象都持有了下载器，用于下载网络图片。网络图片下载完是一个流需要解析成 Bitmap，非网络的就直接得到一个 Bitmap。最后在处理变换操作得到最终的 bitmap。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Bitmap hunt() throws IOException &#123; Bitmap bitmap = null; // 从内存缓存中取 if (shouldReadFromMemoryCache(memoryPolicy)) &#123; bitmap = cache.get(key); if (bitmap != null) &#123; // 统计 缓存命中 stats.dispatchCacheHit(); loadedFrom = MEMORY; return bitmap; &#125; &#125; data.networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy; // 用下载器请求url得到结果 RequestHandler.Result result = requestHandler.load(data, networkPolicy); if (result != null) &#123; loadedFrom = result.getLoadedFrom(); exifRotation = result.getExifOrientation(); bitmap = result.getBitmap(); // 从流中解析出 Bitmap if (bitmap == null) &#123; InputStream is = result.getStream(); try &#123; bitmap = decodeStream(is, data); &#125; finally &#123; Utils.closeQuietly(is); &#125; &#125; &#125; if (bitmap != null) &#123; // 解码 stats.dispatchBitmapDecoded(bitmap); if (data.needsTransformation() || exifRotation != 0) &#123; // 同一时间只处理一个 bitmap synchronized (DECODE_LOCK) &#123; if (data.needsMatrixTransform() || exifRotation != 0) &#123; bitmap = transformResult(data, bitmap, exifRotation); &#125; if (data.hasCustomTransformations()) &#123; bitmap = applyCustomTransformations(data.transformations, bitmap); &#125; &#125; &#125; &#125; return bitmap;&#125; Dispatcher 内部实例化了一个 HandlerThread，所有的调度都是通过这个子线程上执行，通过这个子线程的 Handler 和 主线程的 Handler 以及线程池互相通信。 解析图片的得到 Bitmap 后，Dispatcher 会调度到 dispatchComplete，跟踪代码走到 performComplete。 123456789101112131415161718void performComplete(BitmapHunter hunter) &#123; // 是否写入内存缓存 if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123; cache.set(hunter.getKey(), hunter.getResult()); &#125; hunterMap.remove(hunter.getKey()); // 批处理 hunter batch(hunter); &#125;// 执行批处理 void performBatchComplete() &#123; List&lt;BitmapHunter&gt; copy = new ArrayList&lt;BitmapHunter&gt;(batch); batch.clear(); mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy)); logBatch(copy);&#125; 最终将一批 BitmapHunter 打包一起扔给主线程处理。跟踪代码到 Picasso 类中的主线程的 Handler, 遍历执行 complete(hunter)123456@SuppressWarnings(\"unchecked\") List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj; //noinspection ForLoopReplaceableByForEach for (int i = 0, n = batch.size(); i &lt; n; i++) &#123; BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter);&#125; complete(hunter) 中将调用 Action 的 complete/error 方法进行最后一步把 Bitmap 显示到 target 上，并进行相应的成功或者失败回调。 总结引用一下blog.happyhls.me的图（自己懒得画了%&gt;_&lt;%），上面的流程可以总结成： 看源码的过程中发现 Dispatcher 里面一堆 handler send message，和 ActivityThread 中 H 和 AMS 通信很像，都用 Handler 来进行通信。Handler 真是 Android 的精髓。","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"My 2018","slug":"My 2018","date":"2018-01-01T15:44:00.000Z","updated":"2018-02-01T10:18:43.654Z","comments":true,"path":"2018/01/01/My 2018/","link":"","permalink":"https://luwenjie.me/2018/01/01/My 2018/","excerpt":"2017 todo list Java 涨薪水 增肥 Android 开发艺术探索","text":"2017 todo list Java 涨薪水 增肥 Android 开发艺术探索 2018 todo list 临摹 Picasso Think In Java Effective Java Android Test Kotlin Android 源码设计模式解析与实战 健身增肥 学习一个 coding 以外的技能比如乐器 英语听说读写 BAT 名企","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"Gradle 脚本实现多渠道打包","slug":"Gradle 脚本实现多渠道打包","date":"2017-12-25T06:00:00.000Z","updated":"2018-01-09T03:10:46.220Z","comments":true,"path":"2017/12/25/Gradle 脚本实现多渠道打包/","link":"","permalink":"https://luwenjie.me/2017/12/25/Gradle 脚本实现多渠道打包/","excerpt":"核心思路很简单就是通过脚本来在 gradle 处理 minafest 任务之后修改文件中的值。 需要用到 afterEvaluate 监听所有配置完成后，再设置每个渠道处理清单任务之后的监听。","text":"核心思路很简单就是通过脚本来在 gradle 处理 minafest 任务之后修改文件中的值。 需要用到 afterEvaluate 监听所有配置完成后，再设置每个渠道处理清单任务之后的监听。 运行 ./gradlew aR -Pchannel=213123 即可设置渠道号。12345678910111213141516171819202122232425project.afterEvaluate &#123; android.applicationVariants.each &#123; variant -&gt; def variantName = variant.name.capit alize() def mergeManifest = project.tasks.getByName(\"process$&#123;variantName&#125;Manifest\") mergeManifest.doLast &#123; mm -&gt; // 获取 manifest 文件 def manifest = file(\"$&#123;mm.manifestOutputDirectory&#125;/AndroidManifest.xml\") if (project.hasProperty(\"channel\")) &#123; addChannel(manifest) &#125; &#125; &#125;&#125;void addChannel(File manifest) &#123; def channelNo = project.property(\"channel\") def xml = new XmlParser().parse(manifest) xml.application[0].appendNode(\"meta-data\", ['android:name': 'channel', 'android:value': channelNo]) manifest.withPrintWriter(\"UTF-8\") &#123; XmlUtil.serialize(xml, it) &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"View 点击事件的来源","slug":"View 点击事件的来源","date":"2017-12-05T02:27:00.000Z","updated":"2018-01-09T03:10:11.598Z","comments":true,"path":"2017/12/05/View 点击事件的来源/","link":"","permalink":"https://luwenjie.me/2017/12/05/View 点击事件的来源/","excerpt":"我们在屏幕上点击产生触摸事件，源头肯定是来自屏幕上点击硬件，然后硬件将点击事件传递给 Android 系统。在 Android 系统中又由底层 Linux 处理返回给上层 Framework。这里只讨论 Framework 的来源。","text":"我们在屏幕上点击产生触摸事件，源头肯定是来自屏幕上点击硬件，然后硬件将点击事件传递给 Android 系统。在 Android 系统中又由底层 Linux 处理返回给上层 Framework。这里只讨论 Framework 的来源。 我们知道 Android 的 View 的事件传递顺序是： Activity -&gt; PhoneWindow -&gt; DecorView -&gt; ViewGroup … 但是 Activity 其实是作为一个控制器，按道理来说它不应该是一个源头。而且 Activity 是运行在 UI 线程的，这种来源是由系统产生，很有可能发生在系统进程，Android 中大量使用 Binder 来传输各种信息，这里的点击事件估计也是由系统通过 Binder 传输进来给 UI 线程处理。一起看看 Activity，找出和它有关联的点击事件的线索。 12345678910// Activity 的 dispatchTouchEvent()public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; ​ 既然 Activity 不是源头，肯定是有其他人调用了这个 dispatchTouchEvent() ，我们找出这个人就可以了。 找了半天… 发现 Activity 实现的 Window.Callback 接口中有一个同名的 dispatchTouchEvent()，那自然 Activity 的 dispatchTouchEvent() 就是实现自 Window.Callback接口，这是一个回调，我们只需找出谁持有了 Activity 实例，并调用了 dispatchTouchEvent()。源头就是它！ ps: 其实我是看的任主席的文章，知道了 Callback，Activity 的 dispatchTouchEvent() 也不注解一下 @Override，让人误解是 Activity 自己内部的方法。 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback, WindowControllerCallback 123456// Window.Callbackpublic interface Callback &#123; public boolean dispatchTouchEvent(MotionEvent event); // .... &#125; 这个回调是在哪里设置的呢？按套路应该有个 setCallback(activity)。 回顾一下 Activity 的创建过程，在创建完 Activity 实例后，会调用 Activity 的 attach（），具体的代码可以看 ActivityThread#performLaunchActivity()。 123456789101112final void attach(Context context, ActivityThread aThread, // 省略一堆参数.... Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); // 省略无关代码... &#125; 我们惊喜的发现，在 attach() 中 mWindow 调用了我们猜测的 setCallback()。这里的 mWindow 就是 PhoneWindow。而 setCallback() 是在 Window 中就实现了。 12345678// Window public void setCallback(Callback callback) &#123; mCallback = callback;&#125;public final Callback getCallback() &#123; return mCallback;&#125; 所以持有 Activity 实例的是 PhoneWindow 对象，是 Window 把事件分发给 Activity 的。 Window 分发事件的详细过程Activity 启动之后，在调用了 onResume()之后，Activity 才开始调用 makeVisible() 显示 DecorView。 12345678910111213141516// ActivityThreadfinal void handleResumeActivity()&#123; // 执行 resume 过程 r = performResumeActivity(token, clearHide, reason); // ... if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; // ... r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125;&#125; 123456789// Activityvoid makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; addView() 是由 WindowManagerGlobal 实现的。在addView() 中 ViewRootImpl 被创建，同时调用它的 setView(decorView,windowLayoutParams,panelParentView) ，setView() 的作用就是跨进程调用系统进程中 WMS(WindowManagerService) 的 `` 12345678910111213141516171819202122232425262728// WindowManagerGlobalpublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; // ... int res; /* = WindowManagerImpl.ADD_OKAY; */ // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. requestLayout(); mInputChannel = new InputChannel(); if (view instanceof RootViewSurfaceTaker) &#123; mInputQueueCallback = ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue(); &#125; if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; // 建立输入管道 // ... &#125; &#125; &#125; 参考Android中MotionEvent的来源和ViewRootImpl 点击事件的分发规则 Android 开发艺术探索","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"Fragment 源码解析","slug":"fragmentSouceCodeAna","date":"2017-10-01T10:15:00.000Z","updated":"2017-10-01T09:19:42.125Z","comments":true,"path":"2017/10/01/fragmentSouceCodeAna/","link":"","permalink":"https://luwenjie.me/2017/10/01/fragmentSouceCodeAna/","excerpt":"分析源码前我自己想了几个问题，带着目的去看。 Activity 是如何与 Fragment 关联，如何操作 fragment 的？ Fragment 的本质是一个 View 吗？","text":"分析源码前我自己想了几个问题，带着目的去看。 Activity 是如何与 Fragment 关联，如何操作 fragment 的？ Fragment 的本质是一个 View 吗？ 前言Activity 和 Fragment 密不可分, 分析 Fragment 必须去从 Activity 的生命周期着手去分析其中和 Fragment 的关联。 我们在 Activity 操作 Fragment 通过如下代码：1234getSupportFragmentManager() .beginTransaction() .add(R.id.container, new MyFragment()) .commit(); 查看源码可以发现getSupportFragmentManager() 内部通过 FragmentController 操作。 这个 FragmentController 类是负责控制 Fragment 的。 它的内部持有一个 FragmentHostCallback，所有的核心操作都间接交给了这个类，这个 FragmentHostCallback 类才是重点。而且它的命名是 mHost，它才是最主要的操作者。FragmentController 只是个中间对象。 12// Fragment 可以寄生在任何对象上，让 fragment 寄存在自己身上需要实现 FragmentHostCallback 类，实现里面的一些方法 。 public abstract class FragmentHostCallback&lt;E&gt; extends FragmentContainer Activity 通过 FragmentController 类管理 Fragment。FragmentController 的实例在成员变量中实例化，所以当 Activity 被实例化的时候，FragmentController 就被实例化了。 1234public class FragmentActivity &#123; final FragmentController mFragments = FragmentController.createController(new HostCallbacks());// ...&#125; 那么 Activity 在哪里被实例化的？ Activit 的实例化 实例 Activity 的过程发生在 ActivityThread 中的 performLaunchActivity() 中的这段代码。 12345678// 通过 Instrumentation 的 newActivity 方法使用类加载器创建 Activity 对象activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);activity.attach(); /**-------------------------------------------------------*/ // newActivity() 方法内部调用了 Activity 的无参实例：Activity activity = (Activity)clazz.newInstance(); 在 Activity 实例化之后会立刻调用 Activity#attach()，这个方法内部会调用mFragments.attachHost(null /*parent*/); 1234public void attachHost(Fragment parent) &#123; mHost.mFragmentManager.attachController( mHost, mHost /*container*/, parent);&#125; 1234567891011// 第一个参数是宿主；// 第二参数是容器，FragmentHostCallback 继承于 FragmentContainer 也代表容器；// 第三个参数是父类 Fragmentpublic void attachController(FragmentHostCallback host, FragmentContainer container, Fragment parent) &#123; // 宿主只能有一个 if (mHost != null) throw new IllegalStateException(\"Already attached\"); mHost = host; mContainer = container; mParent = parent;&#125; 这个方法最终将宿主对象和控制器中的 FragmentManager 关联，内部就是进行赋值。为什么里面传的是 null？注释写了 parent。应该是传入的父类 fragment，而由 Activity 创建的 fragment 没有父类，所以是 null。 FragmentController 的初始化1final FragmentController mFragments = FragmentController.createController(new HostCallbacks()); 123public static final FragmentController createController(FragmentHostCallback&lt;?&gt; callbacks) &#123; return new FragmentController(callbacks);&#125; createController() 方法中传入了一个 HostCallbacks 实例。 HostCallbacks 是 FragmentActivity 的内部类，是 FragmentHostCallback 的实现类。 HostCallbacks 的初始化在构造函数中调用父类的构造函数，将当前的 Activity 实例传进去：123public HostCallbacks() &#123; super(FragmentActivity.this /*fragmentActivity*/);&#125; 父类 FragmentHostCallback 有 3 个构造方法： 123456789101112131415public FragmentHostCallback(Context context, Handler handler, int windowAnimations) &#123; this(context instanceof Activity ? (Activity) context : null, context, handler, windowAnimations);&#125;FragmentHostCallback(FragmentActivity activity) &#123; this(activity, activity /*context*/, activity.mHandler, 0 /*windowAnimations*/);&#125;FragmentHostCallback(Activity activity, Context context, Handler handler, int windowAnimations) &#123; mActivity = activity; mContext = context; mHandler = handler; mWindowAnimations = windowAnimations;&#125; HostCallbacks 调用的是第二个构造，将 mActivity、mContext 赋值为 Activity 的实例，mHandler 赋值为 Activity 中的 mHandler，mWindowAnimations 直接赋值 0。 这里的 mHandler 也是在 Activty 被实例化的时候实例化，看代码是处理 Fragment 的 stop 和 resume 状态的。具体怎么处理的后面再看，这里先了解传入的 mHandler 在哪里初始化的。 123456789101112131415161718final Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_REALLY_STOPPED: if (mStopped) &#123; doReallyStop(false); &#125; break; case MSG_RESUME_PENDING: onResumeFragments(); mFragments.execPendingActions(); break; default: super.handleMessage(msg); &#125; &#125;&#125;; FragmentHostCallback 的成员变量123456789101112131415161718192021222324252627282930313233// Actvityprivate final Activity mActivity;// 上下文final Context mContext;// 在 Activity 中实例化的 handler，负责处理 fragment 的生命周期，内部执行具体的事务private final Handler mHandler;// window 的动画final int mWindowAnimations;// 在成员变量中直接实例化了 FragmentManagerImplfinal FragmentManagerImpl mFragmentManager = new FragmentManagerImpl();// loaderManager 的集合, loadMangaer 通过 Fragment#getLoaderManager() 获取，最终是由 FragmentHostCallback#getLoaderManager() 获取。/** The loader managers for individual fragments [i.e. Fragment#getLoaderManager()] */private SimpleArrayMap&lt;String, LoaderManager&gt; mAllLoaderManagers;// 标记 fragmentLoader 是否应该保存 fragment 的状态/** Whether or not fragment loaders should retain their state */private boolean mRetainLoaders;// fragment 宿主的 loaderManager，通过 Activity#getLoaderManager() 获取, 最终是由 FragmentHostCallback#getLoaderManagerImpl() 获取。/** The loader manger for the fragment host [i.e. Activity#getLoaderManager()] */private LoaderManagerImpl mLoaderManager;// 检查 loaderManager 是否为空private boolean mCheckedForLoaderManager;// 宿主的 loaderManager 是否开始加载/** Whether or not the fragment host loader manager was started */private boolean mLoadersStarted; 根据注释和局部代码初步了解一下这些变量的含义，有个大概的印象。可以看到内部有一个 loader manager 的存在。宿主有一个单独的加载器，以 &quot;(root)&quot; 为键存入了 SimpleArrayMap&lt;String, LoaderManager&gt; 集合中。 每个 fragment 也对应有一个自己的 loader manager。 这个 load manager 是干啥的，现在还不知道，后面再看。 FragmentManagerImpl 的初始化 FragmentManager、FragmentManagerState、FragmentManagerImpl 三个类共存于 FragmentManager.java 文件下，它们是同级的关系，而不是内部类的关系。 我们平常操作 fragment 所调用的 getSupportFragmentManager() 返回的就是 FragmentManager 对象。顾名思义，它是 fragment 的管理者，负责添加、删除、替换 fragment 等一些操作。 FragmentManager 是一个抽象类，定义了操作 fragment 的一系列方法，如开启事务、进栈、弹栈等。除此之外，有一个 BackStackEntry 接口和一个 FragmentLifecycleCallbacks 生命周期回调。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class FragmentManager &#123; public abstract FragmentTransaction beginTransaction(); public abstract boolean executePendingTransactions(); public abstract Fragment findFragmentById(@IdRes int id); public abstract Fragment findFragmentByTag(String tag); public abstract void popBackStack(); public abstract boolean popBackStackImmediate(); // ..... // 当调用 FragmentTransaction#addToBackStack(String) 时，将放入回退栈的 frament 的信息存起来。用于以后检索。 public interface BackStackEntry &#123; public int getId(); public String getName(); @StringRes public int getBreadCrumbTitleRes(); @StringRes public int getBreadCrumbShortTitleRes(); public CharSequence getBreadCrumbTitle(); public CharSequence getBreadCrumbShortTitle(); &#125; // 回退栈内容改变时的监听接口 public interface OnBackStackChangedListener &#123; public void onBackStackChanged(); &#125; // frgment 的生命周期回调 public abstract static class FragmentLifecycleCallbacks &#123; public void onFragmentPreAttached(FragmentManager fm, Fragment f, Context context) &#123; &#125; public void onFragmentAttached(FragmentManager fm, Fragment f, Context context) &#123; &#125; public void onFragmentCreated(FragmentManager fm, Fragment f, Bundle savedInstanceState) &#123; &#125; public void onFragmentActivityCreated(FragmentManager fm, Fragment f, Bundle savedInstanceState) &#123; &#125; public void onFragmentViewCreated(FragmentManager fm, Fragment f, View v, Bundle savedInstanceState) &#123; &#125; // ... &#125; &#125; FragmentManager 的具体实现是 FragmentManagerImpl 具体内部的实现，现在先不深入看了。现在先把主要的流程走通，后面再看具体的细节。 1final FragmentManagerImpl mFragmentManager = new FragmentManagerImpl(); FragmentMangerImpl 在 FragmentHostCallback() 的成员变量中被实例化。所以 Activity 被实例化的时候，FragmentController、HostCallbacks、FragmentManagerImpl 都会被实例化。然后再通过我们前面说到的 attach() 将他们关联，让 FragmentManagerImpl 实例持有 HostCallbacks 实例。 Activity 的 onCreate()Activity 的生命周期从 onCreate 开始,在 Activity 实例化后，FragmentManager 就可以被使用来操作 fragment，即我们常用的 getFragmentManager().beginTransaction().add() 等操作。 这些操作都是在 Activity 的 onCreate 完成的。 Activity 的 onCreate() 发生在哪里？ onCreate() 也发生在 ActivityThread 中的 performLaunchActivity() 中： 1mInstrumentation.callActivityOnCreate(activity, r.state); 123456// Instrumentationpublic void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; 1234567// Activity final void performCreate(Bundle icicle) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); &#125; 12345protected void onCreate(@Nullable Bundle savedInstanceState) &#123; // ... mFragments.dispatchCreate();&#125; 12345 final void performCreateCommon() &#123; // ... mFragments.dispatchActivityCreated(); // ... &#125; 最终在 Activity 的 onCreate 调用了 FragmentController#dispatchCreate()，接着在 performCreateCommon() 中调用了 FragmentController#dispatchActivityCreated() ： 123456public void dispatchCreate() &#123; mHost.mFragmentManager.dispatchCreate();&#125;public void dispatchActivityCreated() &#123; mHost.mFragmentManager.dispatchActivityCreated();&#125; 这两个方法都是调用的 HostCallback 实例中的 FragmentManagerImpl 实例的方法。 12345678910111213public void dispatchCreate() &#123; mStateSaved = false; mExecutingActions = true; moveToState(Fragment.CREATED, false); mExecutingActions = false;&#125;public void dispatchActivityCreated() &#123; mStateSaved = false; mExecutingActions = true; moveToState(Fragment.ACTIVITY_CREATED, false); mExecutingActions = false;&#125; 看到这里结合源码注释我们知道这俩方法通过 moveToState() 去更新 Fragment 的 状态。并且用 mExecutingActions 标记事务是否在进行。 用 mStateSaved 标记状态是否保存了。 12345678910void moveToState(int newState, boolean always) &#123; // 状态没变且没有设置必须更新就结束 if (!always &amp;&amp; newState == mCurState) &#123; return; &#125; // 更新当前状态 mCurState = newState; // ... &#125; 这个方法有 2 个参数，第一个参数是即将更新的状态，第二个参数表示是否更新所有 fragment 的状态。 12345678static final int INITIALIZING = 0; // Not yet created.static final int CREATED = 1; // Created.static final int ACTIVITY_CREATED = 2; // The activity has finished its creation.static final int STOPPED = 3; // Fully created, not started.static final int STARTED = 4; // Created and started, not resumed.static final int RESUMED = 5; // Created started and resumed.int mState = INITIALIZING; Fragment 的状态有上面几种。默认是 INITIALIZING。 这里我有个地方有点疑惑：Activity onCreate() 的时候给 FragmentManager 通知更新 CREATED 状态，此时应该还没有创建任何 fragment，为啥是个 CREATED。看到后面又有个 STOPPED，表示创建完成，还没开始的状态。那么 CREATED 应该表示的是开始创建，还没创建好。 事务操作接着我们会在 Activity 中的 onCreate() 创建执行 fragment 的事务。getFragmentManager() 前面已经看过，现在来看 beginTransaction()。 1234// FragmentManagerImpl public FragmentTransaction beginTransaction() &#123; return new BackStackRecord(this);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// BackStackStatefinal class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, FragmentManagerImpl.OpGenerator &#123; static final String TAG = FragmentManagerImpl.TAG; static final boolean SUPPORTS_TRANSITIONS = Build.VERSION.SDK_INT &gt;= 21; final FragmentManagerImpl mManager; // 表示一系列操作 static final int OP_NULL = 0; static final int OP_ADD = 1; static final int OP_REPLACE = 2; static final int OP_REMOVE = 3; static final int OP_HIDE = 4; static final int OP_SHOW = 5; static final int OP_DETACH = 6; static final int OP_ATTACH = 7; static final int OP_SET_PRIMARY_NAV = 8; static final int OP_UNSET_PRIMARY_NAV = 9; // 双链表的节点 static final class Op &#123; // 执行的操作（添加/删除。。。） int cmd; Fragment fragment; // 进栈动画 int enterAnim; int exitAnim; // 出栈动画 int popEnterAnim; int popExitAnim; Op() &#123; &#125; Op(int cmd, Fragment fragment) &#123; this.cmd = cmd; this.fragment = fragment; &#125; &#125; // ...&#125; BackStackRecord 继承 FragmentTransation 抽象类，同时实现 BackStackEntry 和 OpGenerator 接口。我们在程序里要进行 add,remove,replace 等等操作时，用的是 FragmentTransation 类型，其实这个实例是 BackStackRecord 对象。 BackStackRecord 是用于保存用户一次提交的操作行为，一次提交并不是一种变化，而是一系列的变化，是一组 add、replace、remove 变化的集合。每一次的变化，即是一次操作，用 Op 类来表示。在 BackStackRecord 里保存了一个双向链表 (mHead, mTail)，用于保存一组操作。Op 类中的 cmd 表示操作类型（如 add，replace，remove 等等） 例如：1234567getSupportFragmentManager() .beginTransaction() .add(R.id.container, new MyFragment()) .hide(R.id.container,fragment2) .replace(R.id.container,fragment3) .commit(); 最终通过 commit() 方法提交一些列操作。 BackStackRecordBackStackRecord 实现了操作 fragment 的所有事务，每个方法内部都是由 doAddOp 实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic FragmentTransaction add(int containerViewId, Fragment fragment) &#123; doAddOp(containerViewId, fragment, null, OP_ADD); return this;&#125;public FragmentTransaction replace(int containerViewId, Fragment fragment, String tag) &#123; if (containerViewId == 0) &#123; throw new IllegalArgumentException(\"Must use non-zero containerViewId\"); &#125; doAddOp(containerViewId, fragment, tag, OP_REPLACE); return this;&#125; @Overridepublic FragmentTransaction remove(Fragment fragment) &#123; addOp(new Op(OP_REMOVE, fragment)); return this;&#125;@Overridepublic FragmentTransaction hide(Fragment fragment) &#123; addOp(new Op(OP_HIDE, fragment)); return this;&#125;@Overridepublic FragmentTransaction show(Fragment fragment) &#123; addOp(new Op(OP_SHOW, fragment)); return this;&#125;@Overridepublic FragmentTransaction detach(Fragment fragment) &#123; addOp(new Op(OP_DETACH, fragment)); return this;&#125;@Overridepublic FragmentTransaction attach(Fragment fragment) &#123; addOp(new Op(OP_ATTACH, fragment)); return this;&#125; 1234567891011121314private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; // ... // 将 manager 赋值给 fragment fragment.mFragmentManager = mManager; // 设置 containerViewId if (containerViewId != 0) &#123; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; // ... // 将这个事务对象加到 ArrayList 中 addOp(new Op(opcmd, fragment)); &#125; 提交事务常用的提交事务, 一种是将所有事物放入事务队列，轮询执行。另一种是立刻执行，从方法命名也可以看出来。看看它们内部是如何提交的。而立刻提交是不允许加入回退栈的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 @Override public int commit() &#123; return commitInternal(false); &#125; int commitInternal(boolean allowStateLoss) &#123; mCommitted = true; // 判断是否加入回退栈 if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; // 将事务添加到轮询队列等待执行 mManager.enqueueAction(this, allowStateLoss); return mIndex; &#125; public void enqueueAction(OpGenerator action, boolean allowStateLoss) &#123; // 检查状态 if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; throw new IllegalStateException(&quot;Activity has been destroyed&quot;); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;&gt;(); &#125; mPendingActions.add(action); scheduleCommit(); &#125; &#125; // 将事务交通过 handler post 执行 private void scheduleCommit() &#123; synchronized (this) &#123; boolean postponeReady = mPostponedTransactions != null &amp;&amp; !mPostponedTransactions.isEmpty(); boolean pendingReady = mPendingActions != null &amp;&amp; mPendingActions.size() == 1; if (postponeReady || pendingReady) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125; &#125; // mExecCommit 这个 Runnable 做的事：public boolean execPendingActions() &#123; ensureExecReady(true); boolean didSomething = false; while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) &#123; mExecutingActions = true; try &#123; // 优化执行我们的实务操作，具体的执行就在这个方法里 optimizeAndExecuteOps(mTmpRecords, mTmpIsPop); &#125; finally &#123; cleanupExec(); &#125; didSomething = true; &#125; doPendingDeferredStart(); return didSomething; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 // 这里进行了优化和执行事务的操作，执行事务是由 executeOpsTogether 完成 private void optimizeAndExecuteOps(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop) &#123; // ... final int numRecords = records.size(); int startIndex = 0; // 遍历所有的事务 for (int recordNum = 0; recordNum &lt; numRecords; recordNum++) &#123; // 标记优化 final boolean canOptimize = records.get(recordNum).mAllowOptimization; if (!canOptimize) &#123; // .. if (startIndex != recordNum) &#123; executeOpsTogether(records, isRecordPop, startIndex, recordNum); &#125; executeOpsTogether(records, isRecordPop, recordNum, optimizeEnd); // ... &#125; &#125; if (startIndex != numRecords) &#123; executeOpsTogether(records, isRecordPop, startIndex, numRecords); &#125; &#125; // 这里发现执行事务由 executeOps 方法来执行的private void executeOpsTogether(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop, int startIndex, int endIndex) &#123; final boolean allowOptimization = records.get(startIndex).mAllowOptimization; // ... // ... executeOps(records, isRecordPop, startIndex, endIndex); // ... if (postponeIndex != startIndex &amp;&amp; allowOptimization) &#123; // need to run something now FragmentTransition.startTransitions(this, records, isRecordPop, startIndex, postponeIndex, true); moveToState(mCurState, true); &#125; // .. if (addToBackStack) &#123; reportBackStackChanged(); &#125; &#125; 123456789101112131415161718 // 最终判断执行 executeOps 还是 executePopOpsprivate static void executeOps(ArrayList&lt;BackStackRecord&gt; records, ArrayList&lt;Boolean&gt; isRecordPop, int startIndex, int endIndex) &#123; for (int i = startIndex; i &lt; endIndex; i++) &#123; final BackStackRecord record = records.get(i); final boolean isPop = isRecordPop.get(i); if (isPop) &#123; record.bumpBackStackNesting(-1); // Only execute the add operations at the end of // all transactions. boolean moveToState = i == (endIndex - 1); record.executePopOps(moveToState); &#125; else &#123; record.bumpBackStackNesting(1); record.executeOps(); &#125; &#125; &#125; 这里通过 fragmentManager 来操作123456789101112131415161718192021222324252627void executeOps() &#123; final int numOps = mOps.size(); for (int opNum = 0; opNum &lt; numOps; opNum++) &#123; final Op op = mOps.get(opNum); final Fragment f = op.fragment; if (f != null) &#123; f.setNextTransition(mTransition, mTransitionStyle); &#125; switch (op.cmd) &#123; case OP_ADD: f.setNextAnim(op.enterAnim); mManager.addFragment(f, false); break; case OP_REMOVE: f.setNextAnim(op.exitAnim); mManager.removeFragment(f); break; case OP_HIDE: f.setNextAnim(op.exitAnim); mManager.hideFragment(f); break; // ... &#125; &#125; // ... &#125; 最后调用 movetToState()123456789101112131415161718192021public void addFragment(Fragment fragment, boolean moveToStateNow) &#123; if (mAdded == null) &#123; mAdded = new ArrayList&lt;Fragment&gt;(); &#125; makeActive(fragment); if (!fragment.mDetached) &#123; // ... mAdded.add(fragment); fragment.mAdded = true; fragment.mRemoving = false; if (fragment.mView == null) &#123; fragment.mHiddenChanged = false; &#125; if (fragment.mHasMenu &amp;&amp; fragment.mMenuVisible) &#123; mNeedMenuInvalidate = true; &#125; if (moveToStateNow) &#123; moveToState(fragment); &#125; &#125; &#125; 这一段的代码特别长，根据状态调用对应的生命周期, 在添加的时候把 View 添加进父布局。通过 View.GONE/VISIBLE 显示隐藏 Fragment。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) &#123;if (f.mState &lt;= newState) &#123; // ... switch (f.mState) &#123; case Fragment.INITIALIZING: // OnFragmentPreAttached dispatchOnFragmentPreAttached(f, mHost.getContext(), false); // 调用 fragment 的 onAttach f.onAttach(mHost.getContext()); // 回调宿主的 onAttachFragment mHost.onAttachFragment(f); dispatchOnFragmentAttached(f, mHost.getContext(), false); // 执行 fragment 的 onCreate f.performCreate(f.mSavedFragmentState); dispatchOnFragmentCreated(f, f.mSavedFragmentState, false); // ... case Fragment.CREATED: f.mContainer = container; // fragmenr 执行 onCreateView 创建 View f.mView = f.performCreateView(f.getLayoutInflater( f.mSavedFragmentState), container, f.mSavedFragmentState); if (container != null) &#123; // 加入父布局 container.addView(f.mView); &#125; // 设置 View 的 GONE VISIBLE 来控制 hide，show if (f.mHidden) &#123; f.mView.setVisibility(View.GONE); &#125; // onViewCreated f.onViewCreated(f.mView, f.mSavedFragmentState); // 回调 dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState,false); // onActivityCreated f.performActivityCreated(f.mSavedFragmentState); // ... case Fragment.ACTIVITY_CREATED: //... case Fragment.STOPPED: // .. // onStart f.performStart(); dispatchOnFragmentStarted(f, false); case Fragment.STARTED: // ... // onResume f.performResume(); dispatchOnFragmentResumed(f, false); &#125; &#125; else if (f.mState &gt; newState) &#123; switch (f.mState) &#123; case Fragment.RESUMED: // onPause f.performPause(); dispatchOnFragmentPaused(f, false); // .. case Fragment.STARTED: // onStop f.performStop(); dispatchOnFragmentStopped(f, false); // ... case Fragment.STOPPED: f.performReallyStop(); // ... case Fragment.ACTIVITY_CREATED: // .. // onDestroyView f.performDestroyView(); dispatchOnFragmentViewDestroyed(f, false); case Fragment.CREATED: // onDestory f.performDestroy(); // onDetach f.performDetach(); // ... &#125; &#125;&#125; 总结回到最初疑惑的 2 个问题。 Activity 是如何与 Fragment 关联，如何操作 fragment 的？ Activiy 通过 FragmentManager 得到事务的实现类 BackStackRecord，它将 Fragment 封装成一个 Ops，提交给 FragmentManager 处理。如果是异步提交，就通过 Handler 发送 Runnable 任务，FragmentManager 拿到任务后，先处理 Ops 状态，然后调用 moveToState() 方法根据状态调用 Fragment 对应的生命周期方法，从而达到 Fragment 的添加、布局的替换隐藏等。 Fragment 的本质是一个 View 吗？ 本质上是一个对 View 的封装，它持有 view, containerView, fragmentManager, childFragmentManager 等信息。 参考通过源码解析 Fragment 启动过程 Fragment FragmentManager FragmentTransaction 深入理解","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"https://luwenjie.me/tags/Fragment/"}]},{"title":"慕课算法学习 2-排序基础","slug":"imoocAlgorithmsTwo","date":"2017-09-15T09:19:00.000Z","updated":"2017-09-15T09:34:48.000Z","comments":true,"path":"2017/09/15/imoocAlgorithmsTwo/","link":"","permalink":"https://luwenjie.me/2017/09/15/imoocAlgorithmsTwo/","excerpt":"为什么要学习 O(n^2) 的排序算法？编码简单，是一些简单情形的首选。学习其思想，衍生出复杂算法。作为子过程，改进更为复杂的算法。","text":"为什么要学习 O(n^2) 的排序算法？编码简单，是一些简单情形的首选。学习其思想，衍生出复杂算法。作为子过程，改进更为复杂的算法。 选择排序法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class SelectionSort &#123; // 不允许产生任何实例 private SelectionSort() &#123; &#125; private static void sort(int[] arr) &#123; int n = arr.length; // 寻找 [i,n) 中最小值的索引 for (int i = 0; i &lt; n; i++) &#123; int minIndex = i; // 逐一和后面的比较 for (int j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 将较小的值交换到前面来 swap(arr, i, minIndex); &#125; &#125; /** * 交换数组的2个位置上的值 * * @param arr * @param i * @param j */ private static void swap(int[] arr, int i, int j) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; public static void main(String[] args) &#123; int[] arr = &#123;10,9,8,7,6,5,4,3,2,1&#125;; SelectionSort.sort(arr); for (int anArr : arr) &#123; System.out.print(anArr); System.out.print(' '); &#125; System.out.println(); &#125;&#125; 使用模板（泛型）编写算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class SelectionSortUsingComparable &#123; // 不允许产生任何实例 private SelectionSortUsingComparable() &#123; &#125; @SuppressWarnings(\"unchecked\") private static void sort(Comparable[] arr) &#123; int n = arr.length; // 寻找 [i,n) 中最小值的索引 for (int i = 0; i &lt; n; i++) &#123; int minIndex = i; // 逐一和后面的比较 for (int j = i + 1; j &lt; n; j++) &#123; // 使用 compareTo 比较 if (arr[j].compareTo(arr[minIndex]) &lt; 0) &#123; minIndex = j; &#125; &#125; // 将较小的值交换到前面来 swap(arr, i, minIndex); &#125; &#125; /** * 交换数组的2个位置上的值 * * @param arr * @param i * @param j */ private static void swap(Object[] arr, int i, int j) &#123; Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; public static void main(String[] args) &#123; // 测试Integer Integer[] a = &#123;10, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; SelectionSortUsingComparable.sort(a); for (Integer anA : a) &#123; System.out.print(anA); System.out.print(' '); &#125; System.out.println(); // 测试Double Double[] b = &#123;4.4, 3.3, 2.2, 1.1&#125;; SelectionSortUsingComparable.sort(b); for (Double aB : b) &#123; System.out.print(aB); System.out.print(' '); &#125; System.out.println(); // 测试String String[] c = &#123;\"D\", \"C\", \"B\", \"A\"&#125;; SelectionSortUsingComparable.sort(c); for (String aC : c) &#123; System.out.print(aC); System.out.print(' '); &#125; System.out.println(); // 测试自定义的类 Student Student[] d = new Student[4]; d[0] = new Student(\"D\", 90); d[1] = new Student(\"C\", 100); d[2] = new Student(\"B\", 95); d[3] = new Student(\"A\", 95); SelectionSortUsingComparable.sort(d); for (Student aD : d) System.out.println(aD); &#125; private static class Student implements Comparable&lt;Student&gt; &#123; private String name; private int score; Student(String name, int score) &#123; this.name = name; this.score = score; &#125; /** * 排序，按分数从低到高；分数相等，按照字母的字母序排序 * * @param o * @return */ @Override public int compareTo(Student o) &#123; if (this.score &lt; o.score) &#123; return -1; &#125; else if (this.score &gt; o.score) &#123; return 1; &#125; else &#123; return this.name.compareTo(o.name); &#125; &#125; @Override public String toString() &#123; return \"Student: \" + this.name + \" \" + Integer.toString(this.score); &#125; &#125;&#125; 随机生成算法测试用例1234567891011121314151617181920212223242526272829303132333435public class SortTestHelper &#123; private SortTestHelper() &#123; &#125; // 生成有 n 个元素的随机数组，随机范围为 [rangeL, rangeR] public static Integer[] generateRandomArray(int n, int rangeL, int rangeR) &#123; if (rangeL &gt; rangeR) &#123; return null; &#125; Integer[] arr = new Integer[n]; for (int i = 0; i &lt; n; i++) &#123; // Math.random() 返回一个 double 类型的值，范围是 [0.0, 1.0) // random * (rangeR - rangeL + 1) 的最大值只能取到 rangeR - rangeL，k 的范围就在 [rangeL, rangeR] double random = Math.random();// System.out.println(\"random = \"+ random); int k = (int) (random * (rangeR - rangeL + 1) + rangeL); arr[i] = k; &#125; return arr; &#125; // 打印数组的所有内容 public static void printArray(Object[] arr) &#123; for (Object anArr : arr) &#123; System.out.print(anArr); System.out.print(' '); &#125; System.out.println(); &#125;&#125; 测试算法的性能1234567891011121314151617181920212223242526272829303132333435// 测试算法测试数组的时间public static void testSort(String sortClassName, Comparable[] arr) &#123; try &#123; // 获得 class 对象 Class&lt;?&gt; aClass = Class.forName(sortClassName); // 获得排序方法 Method sort = aClass.getDeclaredMethod(\"sort\", Comparable[].class); sort.setAccessible(true); // 参数 Object[] param = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); sort.invoke(null, param); long endTime = System.currentTimeMillis(); // 断言数组是否有序 assert isSorted(arr); System.out.println(aClass.getSimpleName() + \" : \" + (endTime - startTime) + \"ms\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;// 判断数组 arr 是否按从小到大有序排列@SuppressWarnings(\"unchecked\")private static boolean isSorted(Comparable[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i].compareTo(arr[i + 1]) &gt; 0) &#123; return false; &#125; &#125; return true;&#125; 插入排序法 - Insertion Sort1234567891011121314151617181920212223242526272829303132333435363738// 这种插入排序效率较低，因为会发生多次数组拷贝public class InsertionSort &#123; private InsertionSort() &#123; &#125; @SuppressWarnings(\"unchecked\") public static void sort(Comparable[] arr) &#123; int length = arr.length; for (int i = 0; i &lt; length; i++) &#123; // 将当前的值和前一位比较，小的话就交换位置 // 写法 1// for (int j = i; j &gt; 0; j--) &#123;// if (arr[i].compareTo(arr[i - 1]) &lt; 0) &#123;// SortTestHelper.swap(arr, j, j - 1);// &#125; else &#123;// break;// &#125;// &#125; // 写法 2 for (int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j - 1]) &lt; 0; j--) &#123; SortTestHelper.swap(arr, j, j - 1); &#125; &#125; &#125; public static void main(String[] args) &#123; // write your code here int N = 200000; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 100000); SortTestHelper.testSort(\"me.wenjie.insertsort.InsertionSort\", arr); &#125;&#125; 插入排序法的改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 这种插入排序效率较高public class InsertionSortAdvanced &#123; private InsertionSortAdvanced() &#123; &#125; @SuppressWarnings(\"unchecked\") public static void sort(Comparable[] arr) &#123; int length = arr.length; for (int i = 0; i &lt; length; i++) &#123; // 将当前的值和前一位比较，小的话就交换位置 // 写法 1// for (int j = i; j &gt; 0; j--) &#123;// if (arr[i].compareTo(arr[i - 1]) &lt; 0) &#123;// SortTestHelper.swap(arr, j, j - 1);// &#125; else &#123;// break;// &#125;// &#125; // 写法 2// for (int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j - 1]) &lt; 0; j--) &#123;// SortTestHelper.swap(arr, j, j - 1);// &#125; // 写法 3 // 比较前先将当前值拷贝出来 Comparable e = arr[i]; int j = i; for (; j &gt; 0 &amp;&amp; arr[j - 1].compareTo(e) &gt; 0; j--) &#123; // 将前一个值往后一位 arr[j] = arr[j - 1]; &#125; if (i != j) arr[j] = e; &#125; &#125; public static void main(String[] args) &#123; // write your code here int N = 4; Integer[] arr = SortTestHelper.generateRandomArray(N, 0, 10); SortTestHelper.printArray(arr); SortTestHelper.testSort(\"me.wenjie.insertsort.InsertionSortAdvanced\", arr); SortTestHelper.printArray(arr); &#125;&#125; 更多关于 O(n^2) 排序算法的思考插入排序某些情况比 O(nLog(n)) 的算法还要快。 冒泡排序 （Bubble Sort） 冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 12345678910111213141516public static void sort(Comparable[] arr) &#123; int n = arr.length; int newn; do &#123; newn = 0; for (int i = 1; i &lt; n; i++) &#123; if (arr[i - 1].compareTo(arr[i]) &gt; 0) &#123; SortTestHelper.swap(arr, i - 1, i); // 记录最后一次的交换位置 newn = i; &#125; &#125; // 每一次比较都会把最大的放在最后一位，所以最后一位下次循环不用比较 n = newn; &#125; while (newn &gt; 0); &#125; 希尔排序 （Shell Sort） 分组进行插入排序。 1234567891011121314151617181920212223public static void sort(Comparable[] arr) &#123; int n = arr.length; // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093... int h = 1; while (h &lt; n / 3) h = 3 * h + 1; while (h &gt;= 1) &#123; // h-sort the array for (int i = h; i &lt; n; i++) &#123; // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序 Comparable e = arr[i]; int j = i; for (; j &gt;= h &amp;&amp; e.compareTo(arr[j - h]) &lt; 0; j -= h) arr[j] = arr[j - h]; arr[j] = e; &#125; h /= 3; &#125; &#125; 参考慕课网：C++，java算法与数据结构 http://blog.jobbole.com/11745/ 白话经典算法系列之三 希尔排序的实现 图解排序算法(二)之希尔排序","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://luwenjie.me/categories/数据结构和算法/"}],"tags":[]},{"title":"EventBus 3.0 的工作原理","slug":"eventbus","date":"2017-09-03T13:44:00.000Z","updated":"2017-09-03T13:44:44.000Z","comments":true,"path":"2017/09/03/eventbus/","link":"","permalink":"https://luwenjie.me/2017/09/03/eventbus/","excerpt":"EventBus 是一个 Android 事件发布/订阅框架，解耦代码利器。如此优秀的库，它的内部是如何工作的？ 整体的架构可以看官方给的这张图，Event 通过 EventBus 中转分发到对应的订阅者（Sucscriber）。","text":"EventBus 是一个 Android 事件发布/订阅框架，解耦代码利器。如此优秀的库，它的内部是如何工作的？ 整体的架构可以看官方给的这张图，Event 通过 EventBus 中转分发到对应的订阅者（Sucscriber）。 初始化从 Eventbus.getDeafult() 着手： 12345678910 public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; getDefault() 是一个 DoudleCheckLock 单例。看看它的构造方法： 123456789101112131415161718192021222324252627public EventBus() &#123; this(DEFAULT_BUILDER);&#125;EventBus(EventBusBuilder builder) &#123; // private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; // key:订阅的事件，value:订阅者的集合 // 订阅这个事件的所有订阅者集合 subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125;private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); 这里传入了一个默认的 EventBusBuilder 对象，这里是常见的 Builder 模式。初始化了一堆 map 和很多变量，这些 map 和变量的意思其实现在可以不用太多关注，之后遇到再回来查看是什么含义，这样比较有针对性。 注册1234567891011121314public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); // 根据订阅者（Subscriber）去找到订阅者订阅的所有的方法 // SubscriberMethodFinder 是一个封装找订阅者的方法的辅助类 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; // 遍历订阅所有的方法 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 很显然这里需要看下 findSubscriberMethods() 和 subscribe() 里面具体做了什么。 SubscriberMethodFinder#findSubscriberMethods():1234567891011121314151617181920212223242526List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; // 先从缓存中找，找到了直接返回 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; // 订阅者不能一个方法都不订阅，否则这里就会报错， // 我们封装在父类 Activity 时需要添加一个空的 `onEmpty()` 方法 if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(\"Subscriber \" + subscriberClass + \" and its super classes have no public methods with the @Subscribe annotation\"); &#125; else &#123; // 存入缓存 // key: 订阅者(Subscriber), value: 订阅者订阅的方法集合 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125; &#125; 这里暂停一下看一下 ignoreGeneratedIndex，通过判断它来确定是使用 findUsingReflection() 即反射来找订阅方法，还是使用 findUsingInfo() 来找。 这里需要说明一下: EventBus 3.0 加入一个新特性 Subscriber Index。它可以加快订阅的速度，官方推荐使用，提高性能。它内部就是通过 apt 将所有被订阅的方法融合生成一个 Index 索引类，这样不需要反射，官方称效率比之前提高了近三倍。关于 Subscriber Index 后面再独立看，这里先看反射的方法。 SubscriberMethodFinder#findUsingReflection():1234567891011121314 private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; // 准备 findState // 这里的 FindState 也是个辅助内部类，用来检查和保存以及回收订阅方法。 FindState findState = prepareFindState(); // 初始化 findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; // 根据 findstate 找方法 findUsingReflectionInSingleClass(findState); // 将 clazz 赋值为订阅者的父类 clazz，来查找父类的订阅方法 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState);&#125; 123456789101112131415161718// 初始化了一个数量为 4 的 FindState 数组，缓存 findstate 对象。private static final int POOL_SIZE = 4;private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];private FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; // 遍历数组，返回第一个查到的对象，然后将数组中对应的置为空 for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; return new FindState();&#125; 通过反射查找订阅方法的逻辑在这：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 订阅方法只能有一个参数 if (parameterTypes.length == 1) &#123; // 获取 @Subscribe 注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; // 检查方法和参数，方法不能一样 if (findState.checkAdd(method, eventType)) &#123; // 获取注解中的线程参数 ThreadMode threadMode = subscribeAnnotation.threadMode(); // 将注解方法添加进 findState 的方法集合中 // 这里创建了一个 SubscriberMethod 对象，它里面包含了订阅方法的所有信息： // 方法、事件参数类型、优先级、是否是粘性 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; // ...省略检查的代码 &#125; &#125; &#125;public SubscriberMethod(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky) &#123; this.method = method; this.threadMode = threadMode; this.eventType = eventType; this.priority = priority; this.sticky = sticky;&#125; 最后将 findState 中的订阅方法取出并返回：123456789101112131415private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; // 将 findState 的方法集合取出来，然后回收 findState List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); synchronized (FIND_STATE_POOL) &#123; // 将 findState 存入缓存 for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods; &#125; 下面接着看 subscribe(): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; // 获取订阅方法中的参数类型即订阅事件。就是我们自己定义的实体类 XXXEvent Class&lt;?&gt; eventType = subscriberMethod.eventType; // 将订阅者和订阅方法封装成一个新的订阅对象 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); // private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; // 将订阅对象存入一个 hashMap，key: 订阅事件, value: 订阅对象集合 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; // 只能注册一次 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); &#125; &#125; int size = subscriptions.size(); // 遍历订阅对象集合，根据优先级将新订阅的方法插入到其中。这个循环写的很简洁。 for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; // private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; // 这里将订阅者订阅的所有订阅事件存在 map 中，key: 订阅者，value：订阅事件的集合 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; // 将订阅事件加入集合 subscribedEvents.add(eventType); // 如果订阅的方法是粘性事件 if (subscriberMethod.sticky) &#123; // eventInheritance 表示一个订阅事件的子类是否也可以响应订阅者， // 如需响应就必须遍历出所有的事件将其 post 给 Subscription(订阅对象)，即立即分发给订阅对象。 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 到这里注册过程就结束了。 这个流程如图所示： 分发12345678910111213141516171819202122232425262728293031323334353637383940/** Posts the given event to the event bus. */ public void post(Object event) &#123; // private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState // 这里的 currentPostingThreadState 是一个存储了 PostingThreadState 的 threadLocal // PostingThreadState 中存储了当前线程的订阅信息：订阅事件队列、是否正在分发、是否是主线程等等。 PostingThreadState postingState = currentPostingThreadState.get(); // 获取当前线程的订阅事件队列，将新事件添加进去 List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; // 循环事件队列，分发出去同时从队列中删除 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; /** For ThreadLocal, much faster to set (and get multiple values). */ final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled; &#125; ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，通过这样就可以做到每个线程通过 get() 方法获取的时候，取到的只能是自己线程所对应的数据。 123456789101112131415161718192021222324252627282930private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); // 标记是否有订阅者订阅了该事件 boolean subscriptionFound = false; if (eventInheritance) &#123; // 遍历父类的事件 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //只要右边有一个为 true,subscriptionFound 就为 true subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, \"No subscribers registered for event \" + eventClass); &#125; // 没有订阅者的话就发送一条没有订阅者订阅的事件 if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; postSingleEvent()中调用postSingleEventForEventType() 检查是否有订阅者订阅了该事件，如果没有订阅者就发送一条 NoSubscriberEvent 事件，表示没有订阅者订阅。 1234567891011121314151617181920212223242526272829303132333435private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; // 获取以订阅事件为key存储的 订阅对象集合。 subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; // 将事件分发给订阅了此事件的订阅者 for (Subscription subscription : subscriptions) &#123; // 设置当前线程的分发状态 postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; // 分发 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; // 重置状态 postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; postSingleEventForEventType()做的事情就是从 map 中取出订阅了当前事件的订阅者信息的集合。把事件分发给这些订阅者，通知他们执行订阅方法。 下面看postToSubscription() 是如何具体分发事件的： 1234567891011121314151617181920212223242526272829303132private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: // 直接调用方法 invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; // 如果在主线程直接调用 invokeSubscriber(subscription, event); &#125; else &#123; // 放进主线程的队列中 mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; // 在主线程的话就切换到 background 线程 backgroundPoster.enqueue(subscription, event); &#125; else &#123; // 不在主线程直接调用 invokeSubscriber(subscription, event); &#125; break; case ASYNC: // 异步处理 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; 上述代码对调用方法的 threadMode 进行了分流处理。 首先来了解一下 EventBus 的线程切换。EventBus 的线程有 4 种可选： POSTING 发送事件在哪个线程，接收事件就在哪个线程。默认是这种模式，这种模式性能开销最小，因为它不用做线程切换，对于耗时很短的任务应该优先使用这种模式。 MAIN 接收事件时，切换到 Android 的主线程。如果发送事件也是在主线程，就等同于 POSTING 模式了。 BACKGROUND 接收事件时，切换到一个子线程，它和主线程一样，是一个单线程，不能做耗时任务。只有当发送线程在主线程时，它才会切换。否则等同于 POSTING 模式，在哪个线程发送还在哪个线程接收。当事件超过一个的时候，它们会被放在队列中依次执行。 ASYNC 不论任何时候，每次接收事件时，都新开一个独立的新线程。适用于一些耗时操作。EventBus 内部会通过线程池来管理这些线程。 这 4 种模式有各自的处理方式，直接看代码就能看出来。这里我们重点看一下 MAIN、BACKGROUND、ASYNC 的处理。 对应由这三位处理：123private final HandlerPoster mainThreadPoster;private final BackgroundPoster backgroundPoster;private final AsyncPoster asyncPoster; HandlerPoster12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);final class HandlerPoster extends Handler &#123; // PendingPostQueue 是内部存储了 PendingPost 的链表队列，PendingPost 内部存储了分发事件的所有信息。 private final PendingPostQueue queue; // 处理订阅方法的最大耗时，默认是 10 ms private final int maxMillisInsideHandleMessage; private final EventBus eventBus; // 标记是否正在处理消息 private boolean handlerActive; HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123; super(looper); this.eventBus = eventBus; this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage; queue = new PendingPostQueue(); &#125; void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; // 将这个 pendingPost 插入到链表的尾部 queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; // 发一个消息出去 if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; &#125; &#125; &#125; @Override public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; // 从链表的头部开始取数据 PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; // 如果链表头部是空的，就再试一次，还为空就直接返回 synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; // 调用订阅方法 eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; // 如果处理方法的耗时超过了最大耗时就将此事件重新发送 if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125;&#125; HandlerPoster 是一个 Handler，内部将订阅信息(subscription) 和 订阅事件（event）封装成一个单链表队列。将新来的事件插入到队尾，每次分发事件直接调用sendMessage 发送一个空消息。处理的时候按顺序从链表头部开始处理，最终通过反射调用订阅方法。 BackgroundPosterBackgroundPoster 是一个 Runnable。 和上面的 HandlerPoster 一样把事件插进链表的尾部。123456789101112131415public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; // 插入链表的尾部 queue.enqueue(pendingPost); // executorRunning 标记当前线程是否正在执行任务 if (!executorRunning) &#123; executorRunning = true; // private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); // 这里的线程执行者就是默认的 newCachedThreadPool eventBus.getExecutorService().execute(this); &#125; &#125;&#125; 执行部分和主线程一样，最终都是调用了 eventBus.invokeSubscriber(pendingPost);，用反射调用订阅方法。1234567891011121314151617181920212223242526@Override public void run() &#123; try &#123; try &#123; while (true) &#123; // 取出头部的数据，如果头部为空就过 1s 后再取。 PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; Log.w(\"Event\", Thread.currentThread().getName() + \" was interruppted\", e); &#125; &#125; finally &#123; executorRunning = false; &#125; &#125; AsyncPosterAsyncPoster 也是一个 Runnable，和 BackgroundPoster 不同它内部并没有标记线程是否在处理任务，它不会等前一个事件处理结束，而是直接新建一个新线程去处理，最终也是走向反射调用订阅方法。1234567891011121314151617181920212223242526class AsyncPoster implements Runnable &#123; private final PendingPostQueue queue; private final EventBus eventBus; AsyncPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this); &#125; @Override public void run() &#123; PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException(\"No pending post available\"); &#125; eventBus.invokeSubscriber(pendingPost); &#125;&#125; 分发的过程如下图所示： 反注册123456789101112131415/** Unregisters the given subscriber from all event classes. */public synchronized void unregister(Object subscriber) &#123; // 获取订阅者订阅的所有方法 List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; // 解除注册 unsubscribeByEventType(subscriber, eventType); &#125; // 从队列中移除 typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, \"Subscriber to unregister was not registered before: \" + subscriber.getClass()); &#125;&#125; 1234567891011121314151617private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; // 获取订阅某个事件的所有的订阅者 List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); // 遍历这些订阅者，从中删除当前订阅者 for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 反注册就非常简单了，如上所示，先找出当前订阅者订阅的所有方法，遍历每个方法的订阅者集合，将当前订阅者从集合中删除。 Subscriber Index开启索引需要使用 EventBus 注解解析器。 需要在 build.gradle 中配置：1234567891011121314android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; // 配置代码生成的路径 arguments = [ eventBusIndex : 'com.example.myapp.MyEventBusIndex' ] &#125; &#125; &#125;&#125;compile 'org.greenrobot:eventbus:3.0.0'annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1' 重新 build 之后会在 app/build/generated/source/apt 路径下生成一个文件。 1234567891011121314151617181920212223242526272829public class ZZREventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); // 将方法信息存入 map 表中 putIndex(new SimpleSubscriberInfo(com.zzr.business.invest.InvestFragment.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo(\"onRefreshData\", com.zzr.model.OnRefreshInvestEvent.class, ThreadMode.MAIN), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; apt 生成的这个文件将所有调用方法信息自动生成，以订阅者的 class 类型名为 key 存到 map 表中缓存。这样的效率显然要比反射查找要高很多。 12345678910111213141516171819private SubscriberInfo getSubscriberInfo(FindState findState) &#123; if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; if (subscriberInfoIndexes != null) &#123; // 从 subscriberInfoIndexes 中查找 for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null;&#125; 总结一遍分析下来，我们发现 EventBus 3.0 在性能上比之前提高了很多，前提是你开启了 Subscriber Index，唯一一处性能损耗就是调用订阅方法时是用反射调用的，不过这点影响几乎可以忽略不计。同时我们发现 APT 技术真的是非常强大，非常受各大框架的青睐。 虽然 EventBus 能帮助我们解耦代码，但是我们也不能滥用。滥用的话管理 Event 事件很不方便。所以只在关键地方用它，一些简单的地方使用回调、Activity 的 onActivityResult() 其实就可以了。 参考https://github.com/greenrobot/EventBus http://greenrobot.org/files/eventbus/javadoc/3.0/ http://greenrobot.org/eventbus/ https://kymjs.com/code/2015/12/12/01/ http://liuwangshu.cn/application/eventbus/2-eventbus-sourcecode.html","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"开源库源码解析","slug":"开源库源码解析","permalink":"https://luwenjie.me/tags/开源库源码解析/"}]},{"title":"ButterKnife 的工作原理","slug":"butterknife‘s_theory","date":"2017-08-31T09:12:00.000Z","updated":"2017-08-31T09:34:30.000Z","comments":true,"path":"2017/08/31/butterknife‘s_theory/","link":"","permalink":"https://luwenjie.me/2017/08/31/butterknife‘s_theory/","excerpt":"使用 butterknife 很简单。在 Activity 中只需在setContentView() 之后配置一句 ButterKnife.bind(this)，就可以省略繁琐的 findViewById 代码。可以推测它肯定是在内部帮我们处理然后生成了 findViewById 代码。它是如何生成的呢？使用反射是可以达到这个目的的，但是一定存在性能问题。Butterknife 使用的是 APT(Annotation Processing Tool) 编译时解析技术，动态生成findViewById 代码。很多著名的开源库都使用了 APT，比如 Dagger2，DeepLinkDispatch。","text":"使用 butterknife 很简单。在 Activity 中只需在setContentView() 之后配置一句 ButterKnife.bind(this)，就可以省略繁琐的 findViewById 代码。可以推测它肯定是在内部帮我们处理然后生成了 findViewById 代码。它是如何生成的呢？使用反射是可以达到这个目的的，但是一定存在性能问题。Butterknife 使用的是 APT(Annotation Processing Tool) 编译时解析技术，动态生成findViewById 代码。很多著名的开源库都使用了 APT，比如 Dagger2，DeepLinkDispatch。 APT(Annotation Processing Tool)首先需要了解一下 Annotation Processing。Annotation Processing 发布于 java 1.5，是一个年代久远但是十分牛逼的 API。 APT 的作用是根据注解帮助我们生成一些模板代码，减少我们的重复工作。代码生成的时机发生在 编译时，javac 会 build 所有的注解，并且在编译时扫描且处理它们。我们使用 Annotation Processor 用来定制我们处理注解生成代码的规则。 具体使用规则可以看文档 中的 AbstractProcessor类。 可以用 6 步来概括这个过程： java compiler 开始 build Annotation Processors 开始工作 轮询内部所有的注解，找到注解的类、方法、变量 利用刚刚解析的数据生成一个新类（这里就会生成新的代码） 创建一个文件，将生成的代码写入 编译检查是否所有的 annotation processors 都执行了，如果还有没有执行的，就继续循环。 ButterKnife 的工作过程不难推测完成 findViewById 的过程肯定是由ButterKnife.bind(this) 这句代码完成的。我们着手看看它的内部做了什么。 123456@NonNull @UiThreadpublic static Unbinder bind(@NonNull Activity target) &#123; // 得到当前 Activity 的顶级 View，即 DecorView View sourceView = target.getWindow().getDecorView(); return createBinding(target, sourceView);&#125; 12345678910111213141516private static Unbinder createBinding(@NonNull Object target, @NonNull View source) &#123; Class&lt;?&gt; targetClass = target.getClass(); // 根据 class 创建构造器 Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass); if (constructor == null) &#123; return Unbinder.EMPTY; &#125; //noinspection TryWithIdenticalCatches Resolves to API 19+ only type. return constructor.newInstance(target, source); // ... &#125; 123456789101112131415161718192021222324252627282930313233private static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123; Constructor&lt;? extends Unbinder&gt; // 先从 map 表里找，有的话直接返回 // 这里将构造器缓存起来了 bindingCtor = BINDINGS.get(cls); if (bindingCtor != null) &#123; return bindingCtor; &#125; String clsName = cls.getName(); // 过滤以 android. 和 java. 开头的类 // 这些是 framework 的类，不处理 if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) &#123; if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\"); return null; &#125; try &#123; // 获取APT生成的类 clsName Class&lt;?&gt; bindingClass = Class.forName(clsName + \"_ViewBinding\"); //noinspection unchecked // 然后得到这个新类的构造器对象 bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class); if (debug) Log.d(TAG, \"HIT: Loaded binding class and constructor.\"); &#125; // .. 省略异常 // 将新生成的构造器存入 map BINDINGS.put(cls, bindingCtor); return bindingCtor; &#125; 到这里我们知道ButterKnife.bind(this) 做的事就是找到 apt 生成的那个类的构造器然后通过构造器创建那个类的实例。其中用 LinkedHashMap 缓存了这些构造器，提高性能。 ButterKnife 生成的代码位于：app/build/generated/source/apt 路径下。 我们来看看这个新生成的类: 它实现了 Unbinder 接口, 类的命名以原类名加后缀 “_ViewBinding”。 1234567public interface Unbinder &#123; @UiThread void unbind(); Unbinder EMPTY = new Unbinder() &#123; @Override public void unbind() &#123; &#125; &#125;;&#125; 123456789101112131415161718192021222324252627282930public class LoginActivity_ViewBinding implements Unbinder &#123; private LoginActivity target; @UiThread public LoginActivity_ViewBinding(LoginActivity target) &#123; this(target, target.getWindow().getDecorView()); &#125; @UiThread public LoginActivity_ViewBinding(LoginActivity target, View source) &#123; // 获得原来的 Activity 对象 this.target = target; // 这里 findViewById 就由 Utils.findRequiredViewAsType这个方法封装了，直接返回类型转换后的对象。 // 这里为了能访问到 target 中的变量，mContainer 是不能为 private 的，否则会报错访问不到。 target.mContainer = Utils.findRequiredViewAsType(source, R.id.login_container, \"field 'mContainer'\", FrameLayout.class);&#125; @Override @CallSuper public void unbind() &#123; LoginActivity target = this.target; // 解绑时注意 target 不能为空 if (target == null) throw new IllegalStateException(\"Bindings already cleared.\"); this.target = null; // 将所有变量置为空 target.mContainer = null; &#125;&#125; 它做的事非常简单，构造器中传入了原来的 Activity 对象和当前 Activity 的顶级 View，使用封装后的方法完成了 findViewById 的代码。如此一来整个过程就明白了。 findRequiredViewAsType() 方法做的事就是平常我们天天需要手写的 findViewById，这里将其做了封装处理。12345public static &lt;T&gt; T findRequiredViewAsType(View source, @IdRes int id, String who, Class&lt;T&gt; cls) &#123; View view = findRequiredView(source, id, who); return castView(view, id, who, cls); &#125; 一图胜千言： 参考http://jakewharton.github.io/butterknife/ https://github.com/JakeWharton/butterknife Annotation Processing : Don’t Repeat Yourself, Generate Your Code.：https://medium.com/@iammert/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"开源库源码解析","slug":"开源库源码解析","permalink":"https://luwenjie.me/tags/开源库源码解析/"}]},{"title":"Android开发艺术探索笔记-第15章 性能优化","slug":"androidArt15","date":"2017-08-29T10:37:00.000Z","updated":"2017-08-29T10:54:32.000Z","comments":true,"path":"2017/08/29/androidArt15/","link":"","permalink":"https://luwenjie.me/2017/08/29/androidArt15/","excerpt":"2015年Google在YouTube上发布了关于An-droid性能优化典范的专题，通过一系列短视频来帮助开发者创建更快更优秀的Android应用，课程专题不仅仅介绍了Android系统中有关性能问题的底层工作原理，同时也介绍了如何通过工具来找出性能问题以及提升性能的建议，地址是：https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE","text":"2015年Google在YouTube上发布了关于An-droid性能优化典范的专题，通过一系列短视频来帮助开发者创建更快更优秀的Android应用，课程专题不仅仅介绍了Android系统中有关性能问题的底层工作原理，同时也介绍了如何通过工具来找出性能问题以及提升性能的建议，地址是：https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE 性能优化方法主要有： 布局优化 绘制优化 内存泄漏优化 响应速度优化 ListView 优化 Bitmap 优化 线程优化 一些性能优化建议 布局优化思想是减少布局的层级。 有选择的使用一些性能不高的布局：如 RelativeLayout，它的布局需要花费更多的时间。 使用 &lt;inclue&gt;、&lt;merge&gt;、和 ViewStub 绘制优化避免在 onDraw() 中执行大量的操作。 避免在 onDraw() 中创建新的局部对象，因为 onDraw() 会被多次调用，会导致频繁 GC。 不能做耗时操作。 内存泄漏优化避免写出有内存泄漏的代码，利用 MAT 等工具查找。 静态变量 单例 属性动画 响应速度优化和 ANR 日志分析避免将耗时操作放在主线程中执行。Activiy 5s 无法响应屏幕触摸事件就会发生 ANR，BroadcastReceiver 是 10s。 一个进程发生 ANR 后，系统会在 /data/anr 创建一个文件 traces.txt ListView 和 Bitmap 优化ListView 复用 ViewHolder 当列表在滑动时不适合做大量异步认为 可以开启硬件加速 Bitmap 通过 BitmapFactory.Options 根据需要对图片进行采样，利用 inSampleSize 进行裁剪减小 Bitmap 的大小。 线程优化采样线程池，复用线程。控制线程的最大并发数。 一些建议 避免创建过多的对象； 不要过多使用枚举，枚举占用的内存空间要比整型大； 常量请使用static final来修饰； 使用一些Android特有的数据结构，比如SparseArray和Pair等，它们都具有更好的性能； 适当使用软引用和软引用； 采用内存缓存和磁盘缓存； 尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。 MAT 分析工具全称 Eclipse Memory Analyzer。 下载地址：http://www.eclipse.org/mat/downloads.php 提高程序的可维护性 命名规范 代码留出适当的空白区分不同的代码块 只给关键的地方写注释 一段繁琐的业务逻辑，应该适当拆分为几个小的函数或者类。","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第9章 四大组件的功能","slug":"androidArt9","date":"2017-08-26T02:37:00.000Z","updated":"2017-08-26T02:41:15.000Z","comments":true,"path":"2017/08/26/androidArt9/","link":"","permalink":"https://luwenjie.me/2017/08/26/androidArt9/","excerpt":"本章讲述Android中的四大组件的工作过程。本章的意义在于加深读者对四大组件的工作方式的认识，由于四大组件的特殊性，我们有必要对它们的工作过程有一定的了解，这也有助于加深对Android整体的体系结构的认识。","text":"本章讲述Android中的四大组件的工作过程。本章的意义在于加深读者对四大组件的工作方式的认识，由于四大组件的特殊性，我们有必要对它们的工作过程有一定的了解，这也有助于加深对Android整体的体系结构的认识。 四大组件的运行状态除了 BroadcastReceiver 以外，其他三种组件都必须在 AndroidManifest.xml 中注册。 Activity 负责前台和用户交互。Service 是一种计算型组件，有 2 种状态：启动状态和绑定状态。BroadcastReceiver 是一种消息型组件，用于在不同的组件和不同应用之间传递消息。ContentProvider 是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。 Activity 的工作过程 Activity#startActivityForResult12345678910111213141516171819202122232425@Override public void startActivityForResult( String who, Intent intent, int requestCode, @Nullable Bundle options) &#123; Uri referrer = onProvideReferrer(); if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; options = transferSpringboardActivityOptions(options); // 先由 Instrumentation 执行 execStartActivity Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, who, intent, requestCode, options); // 再由 ActivityThread 执行 sendActivityResult if (ar != null) &#123; mMainThread.sendActivityResult( mToken, who, requestCode, ar.getResultCode(), ar.getResultData()); &#125; cancelInputsAndStartExitTransition(options); &#125; mInstrumentation 在 ActivityThread 的 handleBindApplication() 中初始化完成。在启动 Activity 的时候在 attach() 中传给 Activity。 handleBindApplication() 由 ActivityThread$ApplicationThread 的 bindApplication()调用。 Instrumentation#execStartActivity123456789101112131415161718192021public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123;// ... try &#123; // ... // 真正启动 Activity 的是 ActivityManagerNative.getDefault int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); // 检查 Activity 启动的结果，抛出一些异常 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 来看一下 ActivityManagerNative, 1public abstract class ActivityManagerNative extends Binder implements IActivityManager ActivityManagerService 继承自 ActivityManagerNative12public final class ActivityManagerService extends ActivityManagerNative implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback 这个方法返回的是 AMS(ActivityManagerService)123456/** * Retrieve the system's default/global activity manager. */static public IActivityManager getDefault() &#123; return gDefault.get();&#125; gDefault 是一个 Singleton 单例对象，第一次创建时调用 create() 创建出 AMS。12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125; &#125;; AMS 和 ActivityStack 互相调用现在 startActivity 的执行过程走到了 AMS 里面。 AMS 中的 startActivity() 内部的调用逻辑顺序。 startActivity() startActivityAsUser() startActivityMayWait() startActivityLocked() startActivityUnchecked() resumeTargetStackIfNeeded() ActivityStackSupervisor#resumeFocusedStackTopActivityLocked() ActivityStack#resumeTopActivityUncheckedLocked() ActivityStack#resumeTopActivityInnerLocked() ActivityStackSupervisor#startSpecificActivityLocked() ActivityStackSupervisor#realStartActivityLocked() 最终会走到 realStartActivityLocked()com.android.server.am.ActivityStackSupervisor#realStartActivityLocked123456789101112131415161718192021final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; // ... // 这里才是真正启动了 Activity 的地方。 // app.thread 是 IApplicationThread app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); // ... return true;&#125; IApplicationThread 及它的实现者IApplicationThread 是一个 Binder 类型的接口，内部包含大量启动和停止 Activity 以及 Service 的接口。 不难猜测，IApplicationThread 的实现者完成了大量和 Activity 以及 Service 启动/停止相关的功能。1public interface IApplicationThread extends IInterface IApplicationThread 的实现者是 ActivityThread 的内部类 ApplicationThread。 1private class ApplicationThread extends ApplicationThreadNative 12public abstract class ApplicationThreadNative extends Binder implements IApplicationThread ApplicationThreadNative 的作用其实和系统为 AIDL 文件生成的类是一样的。 ApplicationThreadNative 就是 IApplicationThread 的实现者，由于 ApplicationThreadNative 被系统定义为抽象类，所以 ApplicationThread 就成了 IApplicationThread 最终的实现者。 android.app.ActivityThread$ApplicationThread#scheduleLaunchActivity12345678910public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; // .... sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg); &#125; 最终使用 mH 发送一条 msg 通知启动 Activity。 mH 是一个名为 H 的 Handler。 H 处理启动 Activity 的逻辑：123456789case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);&#125; 启动 Activity 的具体细节这里又走到了 ActivityThread#handleLaunchActivity()。 123456789101112131415161718192021222324252627282930313233private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; // ... // Initialize before creating the activity WindowManagerGlobal.initialize(); // 由 performLaunchActivity 创建出了 Activity 对象 Activity a = performLaunchActivity(r, customIntent); // ... if (a != null) &#123; // ... // 执行 resume 状态 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); // 判断 pause if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; performPauseActivityIfNeeded(r, reason); if (r.isPreHoneycomb()) &#123; r.state = oldState; &#125; &#125; &#125; else &#123; try &#123; // finish Activity ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; performLaunchActivity 主要做了 5 件事： 从 ActivityClientRecord 中获取待启动的 Activity 的组件信息 通过 Instrumentation 的 newActivity 方法使用类加载器创建 Activity 对象 通过 LoadedApk 的 makeApplication 方法来尝试创建 Application 对象 创建 ContextImpl 对象并通过 Activity 的 attach 方法来完成一些重要数据的初始化 调用 Activity 的 onCreate 方法 ActivityThread#performLaunchActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // 1. 从 ActivityClientRecord 中获取待启动的 Activity 的组件信息 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; // 2. 通过 Instrumentation 的 newActivity 方法使用类加载器创建 Activity 对象 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; try &#123; //3. 通过LoadedApk的makeApplication方法来尝试创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); // ... // 4. 创建ContextImpl对象并通过Activity的attach方法来完成一些重要数据的初始化 if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); // ... // ContextImpl 通过 Activty 的 attach 和 Activity 建立关联 // 在 attach 中 Activity 会完成 Window 的创建并和 Window 关联， // 这样 Window 接收到外部输入事件后就可以将事件传递给 Activity activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); // ... // 5. 调用 Activity 的 onCreate 方法, // 此时完成了 Activity 的启动 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; // ... mActivities.put(r.token, r); // ... return activity;&#125; newActivity()就是通过类加载器创建 Activity 对象 android.app.Instrumentation#newActivity12345678910111213public Activity newActivity(Class&lt;?&gt; clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance) throws InstantiationException, IllegalAccessException &#123; Activity activity = (Activity)clazz.newInstance(); ActivityThread aThread = null; activity.attach(context, aThread, this, token, 0, application, intent, info, title, parent, id, (Activity.NonConfigurationInstances)lastNonConfigurationInstance, new Configuration(), null, null, null); return activity;&#125; android.app.LoadedApk#makeApplication 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; // 一个 app 只能有一个 Application return mApplication; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"makeApplication\"); Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = \"android.app.Application\"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) &#123; initializeJavaContextClassLoader(); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // 通过 Instrumentation 的 newApplication创建对象。也是用类加载器加载的。 app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; // ... &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; instrumentation.callApplicationOnCreate(app); &#125; // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); return app; &#125; Service 的工作过程Service 分为两种工作状态： 启动状态，主要用于执行后台计算 绑定状态，主要用于其他组件和 Service 的交互 这两种状态可以共存。 12345Intent intentService = new Intent(this,MyService.class);// 启动startService(intentService);// 绑定bindService(intentService,mServiceConnection,BIND_AUTO_CREATE); 启动过程 从 ContextWrapper 的 startService 开始。123public ComponentName startService(Intent service) &#123; return mBase.startService(service);&#125; Activity 创建的时候会通过 attach() 将一个 ContextImpl 对象关联起来，这个 ContextImpl 对象就是上面的 mBase。 ContextWrapper 的大部分实现都是由 mBase 实现。这是桥接模式。 ContextImpl 中 startService() 的最终实现时 startServiceCommon(): android.app.ContextImpl#startServiceCommon1234567891011121314private ComponentName startServiceCommon(Intent service, UserHandle user) &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); // 这里通过 AMS 远程调用 startService ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service,service.resolveTypeIfNeeded(getContentResolver()), getOpPackageName(), user.getIdentifier()); // .... return cn; &#125; com.android.server.am.ActivityManagerService#startService123456789101112131415161718192021@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"startService\"); // Refuse possible leaked file descriptors // ... synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); // mServices 是 ActiveService，辅助 AMS 管理 Service. ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, callingPackage, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 在 AMS 的 startService() 内部的调用链。 ActiveService#startServiceLocked() ActiveService#startServiceInnerLocked() ActiveService#bringUpServiceLocked() ActiveService#sendServiceArgsLocked() ActiveService#realStartServiceLocked() com.android.server.am.ActiveService#startServiceInnerLocked1234567891011121314151617181920212223242526272829303132// ServiceRecord 描述的是一个 Service 记录，它贯穿整个 Service 的启动过程。ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ServiceState stracker = r.getTracker(); if (stracker != null) &#123; stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); &#125; r.callStart = false; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; // 将具体的启动工作交给了 bringUpServiceLocked String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); if (error != null) &#123; return new ComponentName(\"!!\", error); &#125; if (r.startRequested &amp;&amp; addToStarting) &#123; boolean first = smap.mStartingBackground.size() == 0; smap.mStartingBackground.add(r); r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT; // ... if (first) &#123; smap.rescheduleDelayedStarts(); &#125; &#125; else if (callerFg) &#123; smap.ensureNotStartingBackground(r); &#125; return r.name; &#125; com.android.server.am.ActiveService#realStartServiceLocked1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; // ... r.app = app; r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); final boolean newService = app.services.add(r); bumpServiceExecutingLocked(r, execInFg, \"create\"); mAm.updateLruProcessLocked(app, false, null); mAm.updateOomAdjLocked(); boolean created = false; try &#123; // ... synchronized (r.stats.getBatteryStats()) &#123; r.stats.startLaunchedLocked(); &#125; mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); // 通过 ActivityThread 的 scheduleCreateService 创建 Service 对象 app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; // ... &#125; finally &#123; // ... &#125; if (r.whitelistManager) &#123; app.whitelistManager = true; &#125; requestServiceBindingsLocked(r, execInFg); updateServiceClientActivitiesLocked(app, null, true); // If the service is in the started state, and there are no // pending arguments, then fake up one so its onStartCommand() will // be called. if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null)); &#125; // 调用 Service 的其他方法。比如 onStartCommand. sendServiceArgsLocked(r, execInFg, true); // ... &#125; 和 Activity 一样通过 Handler 发送 msg。 ActivityThread#scheduleCreateService12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; ActivityThread#handleCreateService123456789101112131415161718192021222324252627282930313233343536373839404142private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; // 通过类加载器创建 Service 的实例 java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; // ... &#125; try &#123; // 创建 ContextImpl 对象 ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); // 创建 Application Application app = packageInfo.makeApplication(false, mInstrumentation); // 通过 attach 将 Service 对象和 ContextImpl 对象关联。 service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); // 调用 service 的 onCreate service.onCreate(); // 将 service 存入集合中 mServices.put(data.token, service); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; &#125; &#125; // ...&#125; 除此之外 ActivieService#sendServiceArgsLocked() 内部会调用 ActivityThread 的 scheduleServiceArgs(), 最终调用 handleServiceArgs() android.app.ActivityThread#handleServiceArgs1234567891011121314151617181920212223242526 private void handleServiceArgs(ServiceArgsData data) &#123; Service s = mServices.get(data.token); if (data.args != null) &#123; data.args.setExtrasClassLoader(s.getClassLoader()); data.args.prepareToEnterProcess(); &#125; int res; if (!data.taskRemoved) &#123; // 调用了 service 的 onStartCommand() res = s.onStartCommand(data.args, data.flags, data.startId); &#125; else &#123; s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; QueuedWork.waitToFinish(); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); ensureJitEnabled(); &#125; Service 的绑定过程和启动过程一样是从 ContextImpl 中的 bindServiceCommon() 开始。 ContextImpl#bindServiceCommon1234567891011121314151617181920212223242526private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; IServiceConnection sd; // 将客户端的 ServiceConnection 对象转成 ServiceDispatcher.InnerConnection。 // 因为服务的绑定有可能是跨进程的，ServiceConnection 对象必须借助于 // Binder 才能让远程服务回调自己的方法。 sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(this); // 调用 AMS 的 bindService int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); return res != 0;&#125; android.app.LoadedApk#getServiceDispatcher1234567891011121314151617181920212223242526272829private final ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices;public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; // mService 是一个 map synchronized (mServices) &#123; // 一顿操作，map 有的话从 map 取，没有就创建存进去。 LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; sd = map.get(c); &#125; if (sd == null) &#123; sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) &#123; map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mServices.put(context, map); &#125; map.put(c, sd); &#125; else &#123; sd.validate(context, handler); &#125; // 返回内部保寸的 IServiceConnection 对象 return sd.getIServiceConnection(); &#125;&#125; ActivityManagerService#bindService1234567891011public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"bindService\"); // ... synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId); &#125;&#125; AMS 的调用过程： bindService() ActiveServices#bindServiceLocked() ActiveServices#bringUpServiceLocked() ActiveServices#realStartServiceLocked() ActiveServices#requestServiceBindingsLocked() ActiveServices#requestServiceBindingLocked() ActivityThread$ApplicationThread#scheduleBindService() 接着和启动过程类似。都是最终调用 ActivityThread 来创建 Service 实例并执行 onCreate()。 Service 的绑定过程会调用 ActiveServices 的 requestServiceBindingsLocked()。最终调用 ActivityThread$ApplicationThread 的 scheduleBindService()。然后通过 H 这个 Handler 转向 ActivityThread 的 handleBindService() ActivityThread#handleBindService()123456789101112131415161718192021private void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); if (!data.rebind) &#123; // 调用 Service 的 onBind 方法 IBinder binder = s.onBind(data.intent); // 调用 AMS 的 publishService。通知客户端已经成功连接 ActivityManagerNative.getDefault().publishService( data.token, data.intent, binder); &#125; else &#123; // 调用 Service 的 onReBind 方法 s.onRebind(data.intent); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; 通知客户端绑定成功AMS 的 publishService() 调用了 ActiveServices#publishServiceLocked() 123456789101112131415161718192021222324void publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123; final long origId = Binder.clearCallingIdentity(); Intent.FilterComparison filter = new Intent.FilterComparison(intent); IntentBindRecord b = r.bindings.get(filter); if (b != null &amp;&amp; !b.received) &#123; b.binder = service; b.requested = true; b.received = true; for (int conni=r.connections.size()-1; conni&gt;=0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni); for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); // c 是 ConnectionRecord // conn 是 LoadedApk.ServiceDispatcher.InnerConnection // service 是 Service 的 onBind() 返回的 Binder c.conn.connected(r.name, service); &#125; &#125; &#125; serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false);&#125; 看看 InnerConnection 这个类： LoadedApk.ServiceDispatcher.InnerConnection123456789101112131415private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; // 调用了 ServiceDispatcher 的 connected sd.connected(name, service); &#125; &#125; &#125; LoadedApk.ServiceDispatcher#connected1234567891011public void connected(ComponentName name, IBinder service) &#123; if (mActivityThread != null) &#123; // mActivityThread 是 ActivityThread 中的 H，不会为空 // 所以 RunConnection 会运行在主线程中，所以客户端 // ServiceConnection 中的方法是在主线程中被回调的。 // RunConnection 内部也是调用了 doConnected mActivityThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnected(name, service); &#125;&#125; LoadedApk.ServiceDispatcher#doConnected 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void doConnected(ComponentName name, IBinder service) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; old = mActiveConnections.get(name); if (old != null &amp;&amp; old.binder == service) &#123; // Huh, already have this one. Oh well! // 绑定的和之前的一样就直接 return return; &#125; if (service != null) &#123; // 新的 service 连接了 // A new service is being connected... set it all up. info = new ConnectionInfo(); info.binder = service; info.deathMonitor = new DeathMonitor(name, service); service.linkToDeath(info.deathMonitor, 0); mActiveConnections.put(name, info); &#125; else &#123; // The named service is being disconnected... clean up. mActiveConnections.remove(name); &#125; if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // If there was an old service, it is now disconnected. if (old != null) &#123; // 将老的断开 mConnection.onServiceDisconnected(name); &#125; // If there is a new service, it is now connected. if (service != null) &#123; // 新的连接 mConnection.onServiceConnected(name, service); &#125;&#125; 所以绑定只会绑定一次。 停止过程和解除绑定的过程，系统的执行过程是类似的。 BroadcastReceiver 的工作过程主要包含： 广播的注册过程 广播的发送和接收过程 定义广播：1234567public class MyBroadcastReceiver extends BroadcastReceiver &#123; // 此处不可以做耗时操作。参考值：10s以内 @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); &#125;&#125; 注册广播： 静态注册 12345&lt;receiver android:name=\".MyBroadcastReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"me.luwenjie.chapter9.receiver\"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册 123IntentFilter filter = new IntentFilter();filter.addAction(\"me.luwenjie.chapter9.receiver\");registerReceiver(new MyBroadcastReceiver(),filter); 发送广播12Intent intent = new Intent(\"me.luwenjie.chapter9.receiver\");sendBroadcast(intent); 注册过程静态注册的广播在应用安装时由系统自动完成注册，由 PMS（PackageManagerServcie）来完成整个注册过程。 动态注册从 ContextWrapper 的 registerReceiver() 开始。内部由 ContextImpl 实现。 调用链： 1234567891011121314151617181920212223242526272829303132333435private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; // 从 mPackageInfo 获取 IIntentReceiver 对象 // 这是一个 IPC，BroadcastReceiver 作为 Android // 一个组件是不能直接跨进程传递的，需要通过 IIntentReceiver // 中转。IIntentReceiver 是一个 Binder 接口。 rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; final Intent intent = ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; LoadedApk#getReceiverDispatcher1234567891011121314151617181920212223242526272829303132public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; // 已注册就从存储中查找 if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; // 否则新建存储 if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125;&#125; AMS#registerReceiver 12345678910111213141516171819202122232425262728293031public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; // ... synchronized (this) &#123; // ... ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); if (rl == null) &#123; rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver); // ... // 将远程的 IIntentReceiver 对象存储 mRegisteredReceivers.put(receiver.asBinder(), rl); &#125; // ... BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId); rl.add(bf); // 将 IntentFilter 对象存储 mReceiverResolver.addFilter(bf); // ... return sticky; &#125;&#125; 发送和接收过程 ContextImpl#sendBroadcast1234567891011public void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); intent.prepareToLeaveProcess(this); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());&#125; AMS 内部最终调用了 broadcastIntentLocked() 系统从 Android 3.1 开始为 Intent 添加了 2 个标记： FLAG_INCLUDE_STOPPED_PACKAGES 包含已经停止的应用，广播会发送给已经停止的应用 FLAG_EXCLUDE_STOPPED_PACKAGES 不包含已经停止的应用，广播不会发送给已经停止的应用 系统为所有广播默认添加了 FLAG_EXCLUDE_STOPPED_PACKAGES。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; intent = new Intent(intent); // By default broadcasts do not go to stopped apps. // 默认情况下，广播不会发送给已经停止的应用 // intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); // 根据 intentFilter 查找出匹配的广播接收者并经过一系列的条件过滤。 // 最终将满足条件的广播接收者添加到 BroadcastQueue 中，BroadcastQueue // 就会将广播发送给相应的广播接收者。 // ... if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); // 将广播发送给相应的接收者 queue.scheduleBroadcastsLocked(); &#125; &#125; else &#123; // There was nobody interested in the broadcast, but we still want to record // that it happened. if (intent.getComponent() == null &amp;&amp; intent.getPackage() == null &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123; // This was an implicit broadcast... let's record it for posterity. addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0); &#125; &#125; return ActivityManager.BROADCAST_SUCCESS;&#125; com.android.server.am.BroadcastQueue#scheduleBroadcastsLocked123456789public void scheduleBroadcastsLocked() &#123; if (mBroadcastsScheduled) &#123; return; &#125; // 给内部的 Handler 发送了一条 msg。该 Handler 运行在主线程 mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; com.android.server.am.BroadcastQueue#processNextBroadcast 12345678910111213141516171819202122232425262728293031final void processNextBroadcast(boolean fromMsg) &#123; synchronized(mService) &#123; BroadcastRecord r; mService.updateCpuStats(); if (fromMsg) &#123; mBroadcastsScheduled = false; &#125; // First, deliver any non-serialized broadcasts right away. // 先分发无序广播。无序广播存储在 mParallelBroadcasts 中。 while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0); r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size(); // 遍历 for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); // 分发广播 deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i); &#125; addBroadcastToHistoryLocked(r); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, \"Done with parallel broadcast [\" + mQueueName + \"] \" + r); &#125;// ....&#125; 最终调用 LoadedApk$ReceiverDispatcher#performReceive1234567891011121314151617181920public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; // 新建 Args 对象 final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); // ... // 通过 ActivityThread 中的 H 执行 args 中的逻辑 if (intent == null || !mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); args.sendFinished(mgr); &#125; &#125; &#125;&#125; Arg 中的 run(): 1234567891011121314151617public void run() &#123; // ... try &#123; ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); intent.prepareToEnterProcess(); setExtrasClassLoader(cl); receiver.setPendingResult(this); // 调用了 onReceive receiver.onReceive(mContext, intent); &#125; if (receiver.getPendingResult() != null) &#123; finish(); &#125; &#125; &#125; ContentProvider 的工作过程ContentProvider 是一种内容共享型组件，通过 Binder 向其他组件或应用提供数据。 启动当 ContentProvider 所在的进程启动时，ContenProvider 会同时被启动并被发布到 AMS 中。 这时 ContentProvider 的 onCreate() 要先于 Application 的 onCreate() 执行。 ActivityThread#handleBindApplication 中的代码片段：1234567891011121314151617// ....// 先初始化 ContentProvidersif (!ArrayUtils.isEmpty(data.providers)) &#123;installContentProviders(app, data.providers); // For process that contains content providers, we want to // ensure that the JIT is enabled \"at some point\". mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);&#125; // ...// 接着调用 application 的 onCreatemInstrumentation.callApplicationOnCreate(app); ContentProvider 启动完成后，外界就可以通过它提供的增删改查四个接口来操作 ContentProvider 中的数据。即通过 Binder 调用 insert、delete、update、query 四个方法。 外界无法直接访问 ContentProvider，只能通过 AMS 根据 Uri 来获取对应的 ContentProvider 的 Binder 接口 IContentProvider，然后通过它访问内部的数据。 单实例一般来说，ContentProvider 都是单实例。这由属性 android:multiprocess 决定，false 即为单实例，默认为 false。 开启多实例时，在每个调用者的进程中都存在一个 ContentProvider 对象。在实际开发中，并未出现多实例的具体使用场景，官方解释这样可以减少进程间通信的开销。 访问 ContentProvider需要通过 ContentResolver。这是个抽象类。实现类是 ContextImpl$ApplicationContentResolver 1public abstract class ContentResolver 当 ContentProvider 所在的线程为启动时，第一次访问它就会触发 ContentProvider 的创建。通过 ContentResolver 的四个方法都可以触发。 ContextImpl$ApplicationContentResolver#query123456789101112131415161718192021222324252627public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder, @Nullable CancellationSignal cancellationSignal) &#123; // .... try &#123; // ... // Wrap the cursor object into CursorWrapperInner object. // 获取 IContentProvider 对象 final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri); // ... return wrapper; &#125; catch (RemoteException e) &#123; &#125; finally &#123; &#125; &#125; acquireProvider() 最终调用了 ActivityThread 的 acquireProvider()。 ActivityThread#acquireProvider1234567891011121314151617181920212223242526272829public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; // 首先查找是否已经存在，存在的话直接返回 final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; // 当 2 个进程同时请求时，只会保证第一个成功。无法用锁，因为请求需要很长时间，同一个进程可能会重新进入锁。 // 没有查找到就发送一个进程间请求给 AMS 让其启动 IActivityManager.ContentProviderHolder holder = null; try &#123; holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; // Install provider will increment the reference count for us, and break // any ties in the race. // 修改引用计数 holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider; &#125; AMS 是如何启动 ContentProvider的？上面的 getContentProvider() 调用了 getContentProviderImpl() AMS#getContentProviderImpl1234567891011121314 private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) &#123;// ... // 通过 startProcessLocked 启动进程proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, \"content provider\", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false); // ... return cpr != null ? cpr.newHolder(conn) : null; &#125; startProcessLocked() 的内部通过 Progress 的 start() 来完成一个新进程的启动。 新进程启动后的入口方法就是 ActivityThread 的 main()。然后就和上述 启动过程 一样。 完整的过程","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第8章 Window 的创建过程","slug":"androidArt8","date":"2017-08-20T09:31:00.000Z","updated":"2017-08-20T09:32:46.000Z","comments":true,"path":"2017/08/20/androidArt8/","link":"","permalink":"https://luwenjie.me/2017/08/20/androidArt8/","excerpt":"Android 中所有的视图都是通过 Window 来呈现的，不管是 Activity、Dialog 还是 Toast，它们的视图实际上都是附加在 Window 上的，因此 Window 实际是 View 的直接管理者。","text":"Android 中所有的视图都是通过 Window 来呈现的，不管是 Activity、Dialog 还是 Toast，它们的视图实际上都是附加在 Window 上的，因此 Window 实际是 View 的直接管理者。 Window 和 WindowManager使用示例: 将一个 Button 添加到屏幕坐标为 (100,300) 的位置。 12345678910111213141516171819 Button button = new Button(this);button.setText(\"button\");WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT);layoutParams.gravity = Gravity.START | Gravity.TOP;layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION;layoutParams.format = PixelFormat.TRANSPARENT;layoutParams.x = 100;layoutParams.y = 300;WindowManager windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);windowManager.addView(button, layoutParams); WindowManager.LayoutParams 的 Api 文档：https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html Flag表示 Window 的属性，控制 Window 的显示特征。 常用的几个 FLAG： FLAG_NOT_FOCUSABLE： 不会接收事件的焦点，此标记会同时启用 FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的 Window。 FLAG_NOT_TOUCH_MODAL 在此模式下，系统会将当前 Window 区域以外的单击事件传递给底层的 Window，当前 Window 区域以内的单击事件则自己处理。这个标记很重要，一般来说都需要开启此标记，否则其他 Window 将无法收到单击事件。 FLAG_SHOW_WHEN_LOCKED 开启此模式可以让 Window 显示在锁屏的界面。 Type表示 Window 的类型。 应用 Window 对应着一个 Activity 子 Window 不能单独存在，需要附属在特定的父 Window 中。例如：Dialog 系统 Window 需要声明权限才能创建，例如：Toast 和系统状态栏 z-orderedWindow 是分层的，每个 Window 都有对应的 z-ordered。层级大的在上面。 应用 Window 的层级为 1~99 子 Window 的层级为 100~1999 系统 Window 的层级为 2000~2999 WindowManager继承自 ViewManager1public interface WindowManager extends ViewManager android.view.ViewManager12345678910111213141516public interface ViewManager&#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; Window 的内部机制Window 是个抽象类，每一个 Window 都对应一个 View 和一个 ViewRootImpl，window 并不是实际存在的，是以 View 的形式存在。 通过 WindowManager 来访问 Window。 WindowManagerImp 内部通过 WindowManagerGlobal 来添加，更新，移除 View。这是典型的桥接模式。 WindowManagerGlobal 的列表集合123456789101112/** 存储 View */private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();/** 存储 ViewRootImpl */private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();/** 存储 LayoutParams */private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();/** 存储正在被删除的 View */private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;(); 添加WindowManagerGlobal#addView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; /* 错误检查 */ if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; /* 检查是否是子 window，是的话就调整下参数 */ final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there's no parent, then hardware acceleration for this view is // set from the application's hardware acceleration setting. // 如果没有父类window，按应用程序的硬件加速设置这个 View 的硬件加速 final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; /* 观察系统属性的变化 */ synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false); /* 检查是否有正在的删除的 View */ if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(\"View \" + view + \" has already been added to the window manager.\"); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; // 将对象存储到列表中 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; /* 通过 ViewRootImpl#setView 更新界面并完成 Window 的添加过程。 内部通过 requestLayout 绘制界面 */ root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; ViewRootImpl#setView 最终通过 IWindowSession 这个 Binder 对象来完成添加过程。实现类是 Session。这个过程是一个 IPC 调用。 android.view.ViewRootImpl.java # setView 方法片段 12345678910111213141516171819202122try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);&#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(\"Adding window failed\", e);&#125; finally &#123; if (restore) &#123; attrs.restore(); &#125;&#125; 在 mWindowSession 内部会通过 WindowManagerService 来实现 Window 的添加。 IWindowSession.Stub#addToDisplay12345678910public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) &#123; return mService.addWindow(this,window,seq,attrs,viewVisibility,displayId, outContentInsets,outInputChannel);&#125; 这样，Window 的添加请求最终交给了 WindowManagerService 去处理。 Window 的删除过程和添加一样，先通过 WindowManagerImpl, 再通过 WindowManagerGlobal 来实现的。 android.view.WindowManagerGlobal#removeView12345678910111213141516171819public void removeView(View view, boolean immediate) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; synchronized (mLock) &#123; // 查找待删除的 View 的索引。 int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); // 删除 removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException(\"Calling with view \" + view + \" but the ViewAncestor is attached to \" + curView); &#125;&#125; android.view.WindowManagerGlobal#removeViewLocked123456789101112131415161718192021private void removeViewLocked(int index, boolean immediate) &#123;// 通过 ViewRootImpl 来完成删除操作 ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = // 执行 die，完成具体的删除操作 root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; android.view.ViewRootImpl#die12345678910111213141516171819// immediate 为true代表同步删除，false 代表异步执行。一般不需要同步以免发生错误。 boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(mTag, \"Attempting to destroy the window while drawing!\\n\" + \" window=\" + this + \", title=\" + mWindowAttributes.getTitle()); &#125; // 异步删除时只是发送了一个 DIE 消息，Handler 执行 doDie() mHandler.sendEmptyMessage(MSG_DIE); return true; &#125; die 方法中如果是异步删除，就发送一个 MSG, ViewRootImpl 中的 Handler 会执行 doDie()。如果是同步，直接执行 diDie()。 android.view.ViewRootImpl#doDie1234567891011121314151617181920212223242526272829303132333435363738394041void doDie() &#123; checkThread(); if (LOCAL_LOGV) Log.v(TAG, \"DIE in \" + this + \" of \" + mSurface); synchronized (this) &#123; if (mRemoved) &#123; return; &#125; mRemoved = true; if (mAdded) &#123; // 真正删除 View 的操作在这个方法中 dispatchDetachedFromWindow(); &#125; if (mAdded &amp;&amp; !mFirst) &#123; destroyHardwareRenderer(); if (mView != null) &#123; int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) &#123; // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try &#123; if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mWindowSession.finishDrawing(mWindow); &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; mSurface.release(); &#125; &#125; mAdded = false; &#125; // 刷新数据，包括 mRoots、mParams、以及 mDyingViews. 需要将当前 Window 所关联的这三类对象从列表中删除。 WindowManagerGlobal.getInstance().doRemoveView(this);&#125; 主要的删除操作由这个方法完成:android.view.ViewRootImpl#dispatchDetachedFromWindow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void dispatchDetachedFromWindow() &#123; // 垃圾回收相关的工作。移除回调，清除数据和消息 if (mView != null &amp;&amp; mView.mAttachInfo != null) &#123; mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false); // 当 View 从 Window 中移除时，这个方法就会被调用。可以在这个 // 方法中做一些资源回收的工作，比如终止动画、停止线程。 mView.dispatchDetachedFromWindow(); &#125; mAccessibilityInteractionConnectionManager.ensureNoConnection(); mAccessibilityManager.removeAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mAccessibilityManager.removeHighTextContrastStateChangeListener( mHighContrastTextManager); removeSendWindowContentChangedCallback(); destroyHardwareRenderer(); setAccessibilityFocus(null, null); mView.assignParent(null); mView = null; mAttachInfo.mRootView = null; mSurface.release(); if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) &#123; mInputQueueCallback.onInputQueueDestroyed(mInputQueue); mInputQueue.dispose(); mInputQueueCallback = null; mInputQueue = null; &#125; if (mInputEventReceiver != null) &#123; mInputEventReceiver.dispose(); mInputEventReceiver = null; &#125; // 通过 Session 的 remove 方法删除。这同样是是一个 IPC 过程，最终调用 WindowManagerService 的 RemoveWindow try &#123; mWindowSession.remove(mWindow); &#125; catch (RemoteException e) &#123; &#125; // Dispose the input channel after removing the window so the Window Manager // doesn't interpret the input channel being closed as an abnormal termination. if (mInputChannel != null) &#123; mInputChannel.dispose(); mInputChannel = null; &#125; mDisplayManager.unregisterDisplayListener(mDisplayListener); unscheduleTraversals();&#125; Window 的更新过程android.view.WindowManagerGlobal#updateViewLayout12345678910111213141516171819202122232425public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; // 检查异常 if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; // 给View设置新的params final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); // 将老的 params 删除，添加新的 params。 synchronized (mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); // 更新 ViewRootImpl 中的 LayoutParams root.setLayoutParams(wparams, false); &#125; &#125; 在 ViewRootImpl 中会通过 scheduleTraversals 方法对 View 重新布局。 还会通过 WindowSession 来更新 Window 的视图，这个过程最终是由 WindowMangerService 的 relayoutWindow 来具体实现的，同样是个 IPC 过程。 Window 的创建过程View 不能单独存在，必须依附在 Window 这个抽象的概念上。 有 View 的地方就有 Window。 Activity、Dialog、Toast。 Activity 的创建过程Activity 的启动过程很复杂，最终会由 ActivityThread 中的 performLaunchActivity() 来完成整个启动过程。 android.app.ActivityThread#performLaunchActivity()123456789101112131415161718192021222324252627282930313233343536373839404142 try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; // 调用 attach() 为其关联运行过程中所需要的上下文环境变量 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window);&#125; 在 Acrivity 的 attach 方法中，系统会创建 Activity 所属的 Window 对象并为其设置回调接口。Window 对象的创建是通过 PolicyManager 的 makeNewWindow 方法实现的。（新版本直接创建了 PhoneWindow） 由于 Activity 实现了 Window 的 callback 接口，因此当 Window 接收到外界状态的改变时就会回调 Activity 的方法。 123456789101112mWindow = new PhoneWindow(this, window);mWindow.setWindowControllerCallback(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);mWindow.getLayoutInflater().setPrivateFactory(this);if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode);&#125;if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions);&#125; Activity 的视图是怎么加载在 Widnow 上的？直接看 Activity 的 setContentView 的实现。 android.app.Activity#setContentView12345 public void setContentView(@LayoutRes int layoutResID) &#123; // 交给了 window 去实现 getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; Window 的具体实现是 PhoneWindow 类。 com.android.internal.policy.PhoneWidnow#setContentView123456789101112131415161718192021222324252627@Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; // 安装 Decor installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 如果没有 DecorView 就创建它。 DecorView 是一个 FrameLayout，是 Activity 中的顶级 View，一般来说内部包含标题栏和内部栏，这个会随着主题而变化。内容栏的 id 是 android.R.id.content。 com.android.internal.policy.PhoneWindow#installDecor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; // 直接创建，此时还是一个空白的 FrameLayout mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById( R.id.decor_content_parent); if (decorContentParent != null) &#123; mDecorContentParent = decorContentParent; // 设置一堆东西 mDecorContentParent.setUiOptions(mUiOptions); // ...... &#125; else &#123; mTitleView = (TextView) findViewById(R.id.title); if (mTitleView != null) &#123; // 设置title，省略部分代码 &#125; &#125; if (mDecor.getBackground() == null &amp;&amp; mBackgroundFallbackResource != 0) &#123; mDecor.setBackgroundFallback(mBackgroundFallbackResource); &#125; // Only inflate or create a new TransitionManager if the caller hasn't // already set a custom one. // 省略部分代码 &#125; &#125; generateLayout() 初始化 mContentParent。 com.android.internal.policy.PhoneWindow#generateLayout123456789101112131415161718192021222324252627282930313233343536protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle(); // 省略部分代码... // 从这里开始。Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // 省略一堆判断... mDecor.startChanging(); // 加载布局 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); // 这个 id 所对应的 ViewGroup 就是 mContentParent。 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125; // 省略设置背景标题等... mDecor.finishChanging(); return contentParent; &#125; 上述方法中的 ID_ANDROID_CONTENT 的定义如下。 android.view.Window#ID_ANDROID_CONTENT1234/** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 将 View 添加到 DecoreView 的 mContentParent 中。1mLayoutInflater.inflate(layoutResID, mContentParent); 将 Activity 的视图直接添加到 DecorView 的 mContentParent 中。因此设置布局的方法叫 setContentView 回调 Activity 的 onContentChanged 方法通知 Activity 视图改变123 if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged();&#125; Activity 实现了 Window 的 Callback 接口。Activity 的布局文件被添加到 DecorView 的 mContentParent 中，于是需要通知 Activity，使其可以做相应的处理。 Activity 中的 onContentChanged 是空实现。 12 public void onContentChanged() &#123;&#125; 显示经过上述步骤，DecorView 已经被创建并初始化完毕。Activity 的布局文件已经被添加到 DecorView 的 mContentParent 中，但是这时 DecorView 还没有被 WindowManager 正式添加到 Widnow 中。 Window 更多表示一种抽象的功能集合。 虽然在 Activity 的 attach 方法中 Window 已经被创建，此时由于 DecorView 没有被 WindowManager 识别，所以这时的 Window 无法提供具体功能，他无法接收外界的输入信息。 在 ActivityThread 的 handleResumeActivity() 中，首先调用 Activity 的 onResume()，接着调用 Activity 的 makeVisible()。在这个方法中，DecorView 真正完成了添加和显示这两个过程，此时 Activity 的视图才能被用户真正看到。 android.app.ActivityThread#handleResumeActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (!checkAndUpdateLifecycleSeq(seq, r, \"resumeActivity\")) &#123; return; &#125; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, \"Resume \" + r + \" started activity: \" + a.mStartedActivity + \", hideForNow: \" + r.hideForNow + \", finished: \" + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, \"Launch \" + r + \" mStartedActivity set\"); r.hideForNow = true; &#125; // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; if (r.newConfig != null) &#123; performConfigurationChangedForActivity(r, r.newConfig, REPORT_TO_ACTIVITY); if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Resuming activity \" + r.activityInfo.name + \" with newConfig \" + r.activity.mCurrentConfig); r.newConfig = null; &#125; if (localLOGV) Slog.v(TAG, \"Resuming \" + r + \" with isForward=\" + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) &#123; l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) &#123; ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); &#125; &#125; r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, \"Scheduling idle handler for \" + r); Looper.myQueue().addIdleHandler(new Idler()); &#125; r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) &#123; try &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; else &#123; // If an exception was thrown when trying to resume, then // just end this activity. try &#123; ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; &#125; Activity#makeVisible12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; Dialog 的 Window 创建过程#1. 创建 Winow同样是直接 new PhoneWindow 创建 Window，和 Activity 一致。1234567891011121314151617181920Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; // ... mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setOnWindowSwipeDismissedCallback(() -&gt; &#123; if (mCancelable) &#123; cancel(); &#125; &#125;); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); &#125; #2. 初始化 DecorView 并将 Dialog 的视图添加到 DecorView 中和 Activity 一样。123 public void setContentView(@LayoutRes int layoutResID) &#123; mWindow.setContentView(layoutResID);&#125; #3. 将 DecorView 添加到 Window 中并显示12345678public void show() &#123; // ... mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage();&#125; 删除的时候通过 mWindowManager.removeViewImmediate(mDecor); 移除 DecorView。12345678910111213141516171819202122232425 void dismissDialog() &#123; if (mDecor == null || !mShowing) &#123; return; &#125; if (mWindow.isDestroyed()) &#123; Log.e(TAG, \"Tried to dismissDialog() but the Dialog's window was already destroyed!\"); return; &#125; try &#123; mWindowManager.removeViewImmediate(mDecor); &#125; finally &#123; if (mActionMode != null) &#123; mActionMode.finish(); &#125; mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); &#125; &#125;` Dialog 必须采用 Activity 的 Context，如若使用 Apllication 的 Context，就会报错没有 token。 token 一般只有 Activity 才有。 系统 Window 不需要 token 就可以显示。 12Caused by: android.view.WindowManager$BadToken-Exception: Unable to add window --token null is not for an application Toast 的 Window 创建过程Toast 也是基于 Window 来实现的。 内部有 2 类 IPC 过程： Toast 访问 NotificationManagerService NotificationManagerService 回调 Toast 里的 TN 接口 Toast 属于系统 Window。","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第7章 Android 动画深入分析","slug":"AndroidArtChapter7","date":"2017-07-30T10:53:00.000Z","updated":"2017-07-30T10:53:07.000Z","comments":true,"path":"2017/07/30/AndroidArtChapter7/","link":"","permalink":"https://luwenjie.me/2017/07/30/AndroidArtChapter7/","excerpt":"Android 动画分为 3 种，View 动画、帧动画、属性动画。在本章中，首先简单介绍View动画以及自定义View动画的方式，接着介绍View动画的一些特殊的使用场景，最后对属性动画做一个全面性的介绍，另外还介绍使用动画的一些注意事项。","text":"Android 动画分为 3 种，View 动画、帧动画、属性动画。在本章中，首先简单介绍View动画以及自定义View动画的方式，接着介绍View动画的一些特殊的使用场景，最后对属性动画做一个全面性的介绍，另外还介绍使用动画的一些注意事项。 View 动画作用对象是 View。支持 4 种 动画效果。 平移动画 缩放动画 旋转动画 透明度动画 View 动画的种类 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@[package:]anim/interpolator_resource&quot; android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;alpha android:fromAlpha=&quot;float&quot; android:toAlpha=&quot;float&quot;/&gt; &lt;scale android:fromXScale=&quot;float&quot; android:toXScale=&quot;float&quot; android:fromYScale=&quot;float&quot; android:toYScale=&quot;float&quot; android:pivotX=&quot;float&quot; android:pivotY=&quot;float&quot;/&gt; &lt;translate android:fromXDelta=&quot;float&quot; android:toXDelta=&quot;float&quot; android:fromYDelta=&quot;float&quot; android:toYDelta=&quot;float&quot;/&gt; &lt;rotate android:fromDegrees=&quot;float&quot; android:toDegrees=&quot;float&quot; android:pivotX=&quot;float&quot; android:pivotY=&quot;float&quot;/&gt; &lt;/set&gt; android:interpolater 集合所采用的插值器，默认为@android:anim/accelerate_decelerate_interpolator android:shareInterpolater 集合中的动画是否和集合共享一个插值器。 自定义 View 动画继承 Animation 。 123456789101112public class CustomAnimation extends Animation &#123; @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); // 做一些初始化工作 &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; super.applyTransformation(interpolatedTime, t); // 进行相应的矩阵变化 &#125;&#125; 帧动画顺序播放一组预先定义好的图片。系统提供了 AnimationDrawable 来使用帧动画。 frame_animation.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"false\"&gt; &lt;item android:drawable=\"@mipmap/ic_launcher\" android:duration=\"500\"/&gt; &lt;item android:drawable=\"@mipmap/ic_launcher_round\" android:duration=\"500\"/&gt; &lt;item android:drawable=\"@mipmap/egg\" android:duration=\"500\"/&gt;&lt;/animation-list&gt; 1234textView.setBackgroundResource(R.drawable.frame_animation);AnimationDrawable background = (AnimationDrawable) textView.getBackground();background.start(); 帧动画的使用比较简单，但是比较容易引起OOM，所以在使用帧动画时应尽量避免使用过多尺寸较大的图片。 View 动画的特殊使用场景LayoutAnimation作用于 ViewGroup, 为 ViewGroup 指定一个动画，当它的子元素出场时都会具有这种效果。 layout_animation.xml12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\" android:delay=\"0.5\" android:animationOrder=\"normal\" android:animation=\"@anim/anim_item\" &gt;&lt;/layoutAnimation&gt; anim_item.xml123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:interpolator=\"@android:anim/accelerate_interpolator\" android:shareInterpolator=\"true\" &gt; &lt;alpha android:fromAlpha=\"0.0\" android:toAlpha=\"1.0\" /&gt; &lt;translate android:fromXDelta=\"500\" android:toXDelta=\"0\" /&gt;&lt;/set&gt; android:delay 子元素开始动画的时间延迟，如果子元素入场动画的时间周期为300ms，0.5 代表每个子元素都要延迟150ms才能播放入场动画。总体来说，第一个子元素延迟150ms开始播放入场动画，第2个子元素延迟300ms开始播放入场动画，依次类推。 android:animationOrder normal表示顺序显示，reverse表示逆向显示，random则是随机播放入场动画。 android:animation 为元素指定具体的入场动画 指定android:layoutAnimation属性123456&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerview\" android:layoutAnimation=\"@anim/layout_animation\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; Activity 的切换效果Github项目解析（九）–&gt;实现Activity跳转动画的五种方式 123456789101112131415161718192021222324/** * Call immediately after one of the flavors of &#123;@link #startActivity(Intent)&#125; * or &#123;@link #finish&#125; to specify an explicit transition animation to * perform next. * * &lt;p&gt;As of &#123;@link android.os.Build.VERSION_CODES#JELLY_BEAN&#125; an alternative * to using this with starting activities is to supply the desired animation * information through a &#123;@link ActivityOptions&#125; bundle to * &#123;@link #startActivity(Intent, Bundle)&#125; or a related function. This allows * you to specify a custom animation even when starting an activity from * outside the context of the current top activity. * * @param enterAnim A resource ID of the animation resource to use for * the incoming activity. Use 0 for no animation. * @param exitAnim A resource ID of the animation resource to use for * the outgoing activity. Use 0 for no animation. */public void overridePendingTransition(int enterAnim, int exitAnim) &#123; try &#123; ActivityManagerNative.getDefault().overridePendingTransition( mToken, getPackageName(), enterAnim, exitAnim); &#125; catch (RemoteException e) &#123; &#125;&#125; 在 startActiviy 或者 finish 之后立刻执行。 属性动画API11 之后加入。 API11 之前使用 nineoldandroids 代替。 使用属性动画对任意对象的属性进行动画。默认帧率是 10ms/帧。 常用的动画类： ValueAnimator ObjectAnimator : 继承自ValueAnimator AnimatorSet : 动画集合 1234567891011121314151617181920212223242526272829303132333435363738/** * 改变一个对象（myObject）的translationY属性，让其沿着Y轴向上平移一段距离：它的高度，该动画在 * 默认时间内完成，动画的完成时间是可以定义的。 */private void example1(View view) &#123; ObjectAnimator.ofFloat(view, \"translationY\", view.getHeight()).start();&#125;/** * 改变一个对象的背景色属性，典型的情形是改变View的背景色，下面的动画可以让背景色在3秒内实现从0xFFFF8080到 * 0xFF8080FF的渐变，动画会无限循环而且会有反转的效果。 */private void example2(View view) &#123; ObjectAnimator animator = ObjectAnimator.ofInt(view, \"backgroundColor\", 0xFFFF8080, 0xFF8080FF); animator.setDuration(3000); animator.setEvaluator(new ArgbEvaluator()); animator.setRepeatCount(ValueAnimator.INFINITE); // 无限循环 animator.setRepeatMode(ValueAnimator.REVERSE); animator.start();&#125;/** * 动画集合，5秒内对View的旋转、平移、缩放和透明度都进行了改变。 */private void example3(View view) &#123; AnimatorSet set = new AnimatorSet(); set.playSequentially( ObjectAnimator.ofFloat(view,\"rotationX\",0,360), ObjectAnimator.ofFloat(view,\"rotationY\",0,180), ObjectAnimator.ofFloat(view,\"translationX\",0,90), ObjectAnimator.ofFloat(view,\"translationY\",0,90), ObjectAnimator.ofFloat(view,\"scaleX\",1,1.5f), ObjectAnimator.ofFloat(view,\"scaleY\",1,0.5f), ObjectAnimator.ofFloat(view,\"alpha\",1,0.25f,1) ); set.setDuration(5000).start();&#125; 插值器和估值器TimeInterpolate: 根据时间流逝的百分比来计算当前的属性值改变的百分比。系统预置了： LinearInterpolate (线性插值器：匀速动画) AccelerateDecelerateInterpolator (加减速插值器，动画两头慢中间快) DecelerateInterpolater (减速插值器：动画越来越慢) TypeEvaluator：类型估值算法。根据当前属性改变的百分比来计算改变后的属性值。系统预置的有 IntEvaluator FloatEvaluator ArgbEvaluator (针对Color属性) android.view.animation.LinearInterpolator1234567891011121314151617181920212223242526/** * An interpolator where the rate of change is constant */@HasNativeInterpolatorpublic class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory &#123; public LinearInterpolator() &#123; &#125; public LinearInterpolator(Context context, AttributeSet attrs) &#123; &#125; /** * 输入值和返回值一样 */ public float getInterpolation(float input) &#123; return input; &#125; /** @hide */ @Override public long createNativeInterpolator() &#123; return NativeInterpolatorFactoryHelper.createLinearInterpolator(); &#125;&#125; android.animation.IntEvaluator 123456789101112131415161718192021222324/** * This evaluator can be used to perform type interpolation between &lt;code&gt;int&lt;/code&gt; values. */public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; /** * This function returns the result of linearly interpolating the start and end values, with * &lt;code&gt;fraction&lt;/code&gt; representing the proportion between the start and end values. The * calculation is a simple parametric calculation: &lt;code&gt;result = x0 + t * (v1 - v0)&lt;/code&gt;, * where &lt;code&gt;x0&lt;/code&gt; is &lt;code&gt;startValue&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt; is &lt;code&gt;endValue&lt;/code&gt;, * and &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;fraction&lt;/code&gt;. * * @param fraction The fraction from the starting to the ending values 估值小数 * @param startValue The start value; should be of type &lt;code&gt;int&lt;/code&gt; or * &lt;code&gt;Integer&lt;/code&gt; 开始值 * @param endValue The end value; should be of type &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;Integer&lt;/code&gt;结束值 * @return A linear interpolation between the start and end values, given the * &lt;code&gt;fraction&lt;/code&gt; parameter. */ public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 属性动画要求对象的属性必须有 set 和 get 方法。 自定义插值器需要实现 Interpolator 或者 TimeInterpolater，自定义估值算法需要实现 TypeEvaluator。 如果要对其他类型（非 int 、float、Color）做动画，必须要自定义类型估值算法。 属性动画的监听器主要有 2 个接口： AnimatorUpdateListener 和 AnimatorListener。 android.animation.Animator.AnimatorListener1234567891011public static interface AnimatorListener &#123; void onAnimationStart(Animator animation); void onAnimationEnd(Animator animation); void onAnimationCancel(Animator animation); void onAnimationRepeat(Animator animation);&#125; android.animation.ValueAnimator.AnimatorUpdateListener1234567891011 // 监听整个动画过程，每播放一帧就会回调一次。public static interface AnimatorUpdateListener &#123; /** * &lt;p&gt;Notifies the occurrence of another frame of the animation.&lt;/p&gt; * * @param animation The animation which was repeated. */ void onAnimationUpdate(ValueAnimator animation); &#125; 对任意属性做动画Q：给Button加一个动画，让这个Button的宽度从当前宽度增加到500px。 A：View动画只支持4种类型：平移（Translate），旋转（Rotate）,缩放（Scale），透明度（Alpha）。无法达到需求。 属性动画的原理：需要动画对象提供 get，set 方法，属性动画根据外界传递的该属性的初始值和最终值，以动画效果多次去调用 set 方法。 总结：对 Object 的属性 abc 做动画，需要同时满足 2 个条件： Object 必须要提供 setAbc() 方法，如果动画的时候没有传递初始值，那么还需要提供 getAbc() 方法。因为系统需要去获取 adc 属性的初始值（若不满足，app 直接 crash）。 Object 的 setAbc() 方法对属性 abc 所做的改变必须能够通过某种方法反映出来，比如会带来 Ui的改变。（若不满足，动画没有效果但不会 crash）。 如果直接对 Button 的 windth 使用属性动画就会没有动画效果。 set方法在 TextView 中 android.widget.TextView#setWidth12345678// 设置最大宽度和最小宽度 public void setWidth(int pixels) &#123; mMaxWidth = mMinWidth = pixels; mMaxWidthMode = mMinWidthMode = PIXELS; requestLayout(); invalidate(); &#125; get方法在 View 中。 android.view.View#getWidth1234// 获取 view 的宽度public final int getWidth() &#123; return mRight - mLeft;&#125; 解决方法 给对象加上 set，get 方法 内部SDK没有权限。 包装类 12345678910111213141516 private class ViewWraper &#123; private View mTarget; public ViewWraper(View target) &#123; mTarget = target; &#125; public int getWidth() &#123; return mTarget.getWidth(); &#125; public void setWidth(int width) &#123; mTarget.getLayoutParams().width = width; mTarget.requestLayout(); &#125;&#125; 监听动画过程，自行实现属性的改变。 ValueAnimator 本身不作用于任何对象，直接使用它没有任何动画效果。它可以对一个值做动画，然后我们可以监听其动画过程。 属性动画的工作原理 属性动画要求动画作用的对象提供该属性的set方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供get方法，因为系统要去获取属性的初始值。 android.animation.ObjectAnimator#start1234567891011121314151617@Override public void start() &#123; // 如果当前动画、等待的动画（Pending）和延迟的动画（delay）中有何当前相同的动画，就把相同的动画给取消掉。 AnimationHandler.getInstance().autoCancelBasedOn(this); if (DBG) &#123; Log.d(LOG_TAG, \"Anim target, duration: \" + getTarget() + \", \" + getDuration()); for (int i = 0; i &lt; mValues.length; ++i) &#123; PropertyValuesHolder pvh = mValues[i]; Log.d(LOG_TAG, \" Values[\" + i + \"]: \" + pvh.getPropertyName() + \", \" + pvh.mKeyframes.getValue(0) + \", \" + pvh.mKeyframes.getValue(1)); &#125; &#125; // 调用父类的 start super.start(); &#125; android.animation.ValueAnimator#start12345678910111213141516171819202122232425262728293031323334353637383940414243private void start(boolean playBackwards) &#123;// 需要运行在有 looper 的线程中 if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\"); &#125; mReversing = playBackwards; // Special case: reversing from seek-to-0 should act as if not seeked at all. if (playBackwards &amp;&amp; mSeekFraction != -1 &amp;&amp; mSeekFraction != 0) &#123; if (mRepeatCount == INFINITE) &#123; // Calculate the fraction of the current iteration. float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction)); mSeekFraction = 1 - fraction; &#125; else &#123; mSeekFraction = 1 + mRepeatCount - mSeekFraction; &#125; &#125; mStarted = true; mPaused = false; mRunning = false; mAnimationEndRequested = false; // Resets mLastFrameTime when start() is called, so that if the animation was running, // calling start() would put the animation in the // started-but-not-yet-reached-the-first-frame phase. mLastFrameTime = 0; AnimationHandler animationHandler = AnimationHandler.getInstance(); animationHandler.addAnimationFrameCallback(this, (long) (mStartDelay * sDurationScale)); if (mStartDelay == 0 || mSeekFraction &gt;= 0) &#123; // If there's no start delay, init the animation and notify start listeners right away // to be consistent with the previous behavior. Otherwise, postpone this until the first // frame after the start delay. startAnimation(); if (mSeekFraction == -1) &#123; // No seek, start at play time 0. Note that the reason we are not using fraction 0 // is because for animations with 0 duration, we want to be consistent with pre-N // behavior: skip to the final value immediately. setCurrentPlayTime(0); &#125; else &#123; setCurrentFraction(mSeekFraction); &#125; &#125; &#125; android.animation.ValueAnimator#doAnimationFrame12345678910111213141516171819202122232425262728293031323334353637383940414243public final void doAnimationFrame(long frameTime) &#123; AnimationHandler handler = AnimationHandler.getInstance(); if (mLastFrameTime == 0) &#123; // First frame handler.addOneShotCommitCallback(this); if (mStartDelay &gt; 0) &#123; startAnimation(); &#125; if (mSeekFraction &lt; 0) &#123; mStartTime = frameTime; &#125; else &#123; long seekTime = (long) (getScaledDuration() * mSeekFraction); mStartTime = frameTime - seekTime; mSeekFraction = -1; &#125; mStartTimeCommitted = false; // allow start time to be compensated for jank &#125; mLastFrameTime = frameTime; if (mPaused) &#123; mPauseTime = frameTime; handler.removeCallback(this); return; &#125; else if (mResumed) &#123; mResumed = false; if (mPauseTime &gt; 0) &#123; // Offset by the duration that the animation was paused mStartTime += (frameTime - mPauseTime); mStartTimeCommitted = false; // allow start time to be compensated for jank &#125; handler.addOneShotCommitCallback(this); &#125; // The frame time might be before the start time during the first frame of // an animation. The \"current time\" must always be on or after the start // time to avoid animating frames at negative time intervals. In practice, this // is very rare and only happens when seeking backwards. final long currentTime = Math.max(frameTime, mStartTime); boolean finished = animateBasedOnTime(currentTime); if (finished) &#123; endAnimation(); &#125;&#125; 在初始化的时候，如果属性的初始值没有提供，则get方法会被调用，get方法是用反射来调用的。 android.animation.PropertyValuesHolder#setupValue1234567891011121314151617181920212223private void setupValue(Object target, Keyframe kf) &#123; if (mProperty != null) &#123; Object value = convertBack(mProperty.get(target)); kf.setValue(value); &#125; else &#123; try &#123; if (mGetter == null) &#123; Class targetClass = target.getClass(); setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); &#125; catch (InvocationTargetException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; &#125; &#125; 当下一帧到来的时候，PropertyValuesHolder 中的 setAnimatedValue 会将新的属性值设置给对象。set 也是通过反射来调用的。 android.animation.PropertyValuesHolder#setAnimatedValue123456789101112131415void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; try &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125; catch (InvocationTargetException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; &#125; &#125; 注意事项 OOM主要出现在帧动画中，尽量避免使用帧动画。 内存泄漏当有无限循环的动画时，需要在 Activity 退出时及时停止。View 动画不存在此问题。 兼容性在 3.0 以下需要适配。 View 动画的问题View 动画是对 View 的影像做动画，并不是真正的改变 View 的状态，因此有时会出现动画完成后 View 无法隐藏的现象，即 view.setVisible(GONE) 失效了，这时只需要调用 view.clearAnimation() 清除 View 动画就可以解决。 不要使用 px尽量使用 dp 动画元素的交互将view移动（平移）后，在Android 3.0以前的系统上，不管是View动画还是属性动画，新位置均无法触发单击事件，同时，老位置仍然可以触发单击事件。尽管View已经在视觉上不存在了，将View移回原位置以后，原位置的单击事件继续生效。从3.0开始，属性动画的单击事件触发位置为移动后的位置，但是View动画仍然在原位置。 硬件加速建议开启，提高动画流程性","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第5章 RemoteViews","slug":"androidArt5","date":"2017-07-20T10:48:00.000Z","updated":"2017-07-20T10:52:26.000Z","comments":true,"path":"2017/07/20/androidArt5/","link":"","permalink":"https://luwenjie.me/2017/07/20/androidArt5/","excerpt":"RemoteViews表示的是一个View结构，它可以在其他进程中显示，由于它在其他进程中显示，为了能够更新它的界面，Re-moteViews提供了一组基础的操作用于跨进程更新它的界面。这听起来有点神奇，竟然能跨进程更新界面！但是RemoteViews的确能够实现这个效果。RemoteViews在Android中的使用场景有两种：通知栏和桌面小部件。","text":"RemoteViews表示的是一个View结构，它可以在其他进程中显示，由于它在其他进程中显示，为了能够更新它的界面，Re-moteViews提供了一组基础的操作用于跨进程更新它的界面。这听起来有点神奇，竟然能跨进程更新界面！但是RemoteViews的确能够实现这个效果。RemoteViews在Android中的使用场景有两种：通知栏和桌面小部件。 RemoteViews 的应用主要用在通知栏和桌面小部件。 通知栏是通过 NotificationManager 的 notify() 方法实现的，除了默认效果外，还可以自定义布局。 桌面小部件是通过 AppWidgetProvider 来实现的。AppWidgetProvider 本质是一个广播。 这二者的界面都运行在系统的 SystemServer 进程，无法直接更新 View，只能跨进程更新。 通知栏123456789101112131415161718192021222324RemoteViews remoteViews = new RemoteViews(getPackageName(),R.layout.remoteview);remoteViews.setTextViewText(R.id.text,\"修改文字\");int id = 1;Intent resultIntent = new Intent(this, NotificationActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);// Adds the back stackstackBuilder.addParentStack(NotificationActivity.class);// Adds the Intent to the top of the stackstackBuilder.addNextIntent(resultIntent);// Gets a PendingIntent containing the entire back stackPendingIntent resultPendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);NotificationCompat.Builder builder = new NotificationCompat.Builder(this);builder.setSmallIcon(R.mipmap.ic_launcher_round) .setContentTitle(\"title\") .setContentInfo(\"info \") .setContent(remoteViews) .setContentText(\"text\") .setTicker(\"ticker\");builder.setContentIntent(resultPendingIntent);NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mNotificationManager.notify(id, builder.build()); 提供当前应用的包名和布局文件的id创建一个 RemoteViews 对象。 无法直接更新 RemoteViews，必须通过 RemoteViews 提供的一系列方法更新。 桌面小部件AppWidgetProvider 用于实现桌面小部件。 public class AppWidgetProvider extends BroadcastReceiver 本质上是一个广播。 MyAppWidgetProvider.java12345678910111213141516171819202122232425262728293031323334353637383940public class MyAppWidgetProvider extends AppWidgetProvider &#123; private final static String TAG = \"MyAppWidgetProvider\"; public static final String CLICK_ACTION = \"com.luwenjie.appwidget\"; public MyAppWidgetProvider() &#123; super(); &#125; @Override public void onReceive(final Context context, final Intent intent) &#123; super.onReceive(context, intent); Log.d(TAG, \"onReceive, action = \" + intent.getAction()); // 判断是不是自己的ACTION。 if (intent.getAction().equals(CLICK_ACTION))&#123; Toast.makeText(context,\"clicked it\",Toast.LENGTH_SHORT).show(); new Thread(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher); AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); for (int i = 0; i &lt; 37; i++) &#123; float degree = (i * 10 )%360; RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.widget); remoteViews.setImageViewBitmap(R.id.imageView,rotateBitmap(context,bitmap,degree)); Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent pendingIntent= PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.imageView,pendingIntent); appWidgetManager.updateAppWidget(new ComponentName(context,MyAppWidgetProvider.class),remoteViews); SystemClock.sleep(30); &#125; &#125; &#125;).start(); &#125; &#125;&#125; 12345678910111213&lt;!--声明小部件--&gt; &lt;receiver android:name=\".appwidget.MyAppWidgetProvider\" &gt; &lt;meta-data android:name=\"android.appwidget.provider\" android:resource=\"@xml/appwidget_provider_info\" /&gt; &lt;intent-filter&gt; &lt;action android:name=\"me.wenjie.click.action\"/&gt; &lt;!--作为小部件标识必须存在--&gt; &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; PendingIntent一种出于 pending 状态的 Intent。接下来有一个 Intent 将在某个不确定的时刻发生。Intent 是立即发生。 其中 requestCode 和 flags 的意义： requstCode 表示 PendingIntent 发送方的请求码，多数情况下设为0，requestCode 会影响到 flags 的效果。 flag flag 的类型： FLAG_ONE_SHOT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT, FLAG_UP_DATE_CURRENT。 匹配规则:如果 2 个 PendingIntent 他们的的 Intent 相同, requestCode 也相同。这 2 个 PeddingIntent 就是相同的。 Intent 的匹配规则： ComponentName 和 intet-filter 都想同时，Intent就是相同的。 _FLAG_ONESHOT当前描述的 PendingIntent 只能被使用 1 次，然后就被自动 cancel。同类的通知栏点击后只能打开一次。 _FLAG_NOCREATE当前描述的 PendingIntent 不会主动创建, 很少见，无法单独使用。在开发中没有太多使用意义。 _FLAG_CANCELCURRENT当前描述的 PendingIntent 如果已经存在，那么都会被 cancel。系统会创建一个新的 PendingIntent。被 cancel 的消息通知栏点击后不会响应。 _FLAG_UPDATECURRENT当前描述的 PendingIntent 如果已经存在, 内部的 Intent 中的 Extras 会被替换成最新的。 manager.notify(1,notification)若 id 都是同一个，后续的通知会把之前的通知完全替代掉。每次的 id 不同时，会弹出多个通知。 id 不相同，当 PendingIntent 也不匹配时，这种情况不管采用任何标记位，这些通知互相之间不会互相干扰。 当 PendingIntent 匹配时： 采用了 FLAG_ONE_SHOT: 后续通知中的 PendingIntent 和第一条保持一致，单击任何一条通知后，剩下的通知都无法打开。 采用 FLAG_CANCEL_CURRENT: 只有最新的通知可以被打开，之前弹出的所有通知均无法打开。 采用 FLAG_UPDATE_CURRENT: 之前弹出的通知中的 PendingIntent 全会被更新，和最新的保持一致。都是可以打开的。 RemoteViews 的内部机制支持的类型： FrameLayout、 LinearLayout、 RelativeLay-out、 GridLayout。 AnalogClock、 Button、 Chronometer、 ImageButton、 ImageView、 ProgressBar、 TextView、 ViewFlipper、 ListView、 GridView、 StackView、 AdapterViewFlipper、 ViewStub。 一系列 set 方法通过反射来完成。 RemoteViews 主要用于通知栏和桌面小部件。NotificationManager 和 AppWidgetManager 通过 Binder 分别和 SystemServer 进程中 NotificationMangerService 和 AppWidgetService 进行通信。 所以，通知栏和小部件的布局文件实际上是在 NotificationMangerService 和 AppWidgetService 中被加载的，service 运行在系统的 SystemServer 中，这就构成了跨进程通信。 RemoteViews 通过 Bidner 传递到 SystemServer 进程，系统通过包名信息得到对应的资源。 在 SystemServer 中通过 LayoutInflater 去加载布局文件。 操作系统对 View 执行一系列界面更新任务，这些就是我们之前通过 set 方法提交的。set 方法只是先记录更新操作。等到 RemoteViews 被加载后才能执行。此时 RemoteView 就可以在 SystemServer 中显示。 更新时通过 set 方法通过 NotificationManager 和 AppWidgetManager 才提交更新。 系统没有直接通过 Binder 去支持 View 的跨进程访问，而是提供了一个 Action。Action 代表一个 View 操作。 系统首先将 View 操作封装到 Action 对象并将这些对象跨进程运输到远处进程 接着在远程进程中执行 Action 对象的具体操作。每次调用 set 方法，RemoteViews 中就会添加一个对应的 Action 对象。 当通过 manager 来提交更新时，Action 对象就会传输到远程进程并依次执行。 远程进程通过 RemoteViews 的 apply 方法来执行 View 的更新操作。apply 方法内部会遍历所有的 Action 对象并调用它们的 apply 方法。 好处：不需要大量的 Binder 接口，避免了大量的 IPC 操作，提高性能。 源码分析RemoteViews.java12345678910111213141516171819202122232425public void setTextViewText(int viewId, CharSequence text) &#123; setCharSequence(viewId, \"setText\", text);&#125;// 内部添加了一个反射动作：ReflectionActionpublic void setCharSequence(int viewId, String methodName, CharSequence value) &#123; addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value));&#125;// 先将所有的action加入一个 actionList 中。这里仅仅是保存了起来，并没有操作。private void addAction(Action a) &#123; if (hasLandscapeAndPortraitLayouts()) &#123; throw new RuntimeException(\"RemoteViews specifying separate landscape and portrait\" + \" layouts cannot be modified. Instead, fully configure the landscape and\" + \" portrait layouts individually before constructing the combined layout.\"); &#125; if (mActions == null) &#123; mActions = new ArrayList&lt;Action&gt;(); &#125; mActions.add(a); // update the memory usage stats a.updateMemoryUsageEstimate(mMemoryUsageCounter);&#125; 执行的过程看 Action 实现类的 apply 方法。 RemoteViews#apply123456789101112// public View apply(Context context, ViewGroup parent, OnClickHandler handler) &#123; // 获取remoteView RemoteViews rvToApply = getRemoteViewsToApply(context); // 通过 layoutInflater 加载布局文件 View result = inflateView(context, rvToApply, parent); loadTransitionOverride(context, handler); // 遍历执行 mActions 的 action 的apply rvToApply.performApply(result, parent, handler); return result; &#125; Remoteviews#Action#apply12public abstract void apply(View root, ViewGroup rootParent, OnClickHandler handler) throws ActionException; Remoteviews#ReflectionAction#apply1234567891011121314151617181920212223private final class ReflectionAction extends Action &#123; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final View view = root.findViewById(viewId); if (view == null) return; Class&lt;?&gt; param = getParameterType(); if (param == null) &#123; throw new ActionException(\"bad type: \" + this.type); &#125; try &#123; // 通过反射来调用方法 getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value)); &#125; catch (ActionException e) &#123; throw e; &#125; catch (Exception ex) &#123; throw new ActionException(ex); &#125; &#125; &#125; 单击事件RemoteViews 只支持发起 PendingIntent，不支持 onClickListener。 setOnClickFillInIntent 用于给普通View设置单击事件，但是不能给集合View（ListView 和 StackView）设置单击事件。 因为开销大，系统禁止了。 必须通过 setPendingIntentTemplate 和 setOnClickFillInIntent 组合使用才可以。 RemoteViews 的意义模拟一个通知栏过程实现跨进程的UI更新。 2 个 Activity 在不同的进程中。 A 扮演通知栏的角色，B 不停的发送通知消息。 在B中创建 RemoteVies 对象，在A中显示。 A123456789101112131415161718192021222324252627282930313233343536public class AActivity extends Activity &#123; private LinearLayout mRemoteViesContent; private BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; RemoteViews remoteViews = intent.getParcelableExtra(BActivity.EXTRA_REMOTE_VIEWS); if (remoteViews != null) &#123; // 收到广播后,取出 remoteView 对象 updateUI(remoteViews); &#125; &#125; &#125;; private void updateUI(RemoteViews remoteViews) &#123; // 通过 apply 加载布局执行更新操作。 View view = remoteViews.apply(this, mRemoteViesContent); mRemoteViesContent.addView(view); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_meaninga); initView(); startActivity(new Intent(this,BActivity.class)); &#125; private void initView() &#123; mRemoteViesContent = (LinearLayout) findViewById(R.id.remoteviews_content); IntentFilter intentFilter = new IntentFilter(BActivity.REMOTE_ACTION); registerReceiver(receiver, intentFilter); &#125; @Override protected void onDestroy() &#123; unregisterReceiver(receiver); super.onDestroy(); &#125;&#125; B1234567891011121314151617181920212223242526public class BActivity extends Activity &#123; public static final String REMOTE_ACTION = \"remoteAction\"; public static final String EXTRA_REMOTE_VIEWS = \"extraRemoteViews\"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_meaningb); RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.simulate_notification); remoteViews.setImageViewResource(R.id.simulate_notification_image, R.mipmap.ic_launcher_round); remoteViews.setTextViewText(R.id.simulate_notification_text, \"msg from process:\" + Process.myPid()); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, CActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); PendingIntent pendingIntent2 = PendingIntent.getActivity(this, 0, new Intent(this, DActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); remoteViews.setOnClickPendingIntent(R.id.simulate_notification_image, pendingIntent); remoteViews.setOnClickPendingIntent(R.id.simulate_notification_text, pendingIntent2); Intent intent = new Intent(REMOTE_ACTION); intent.putExtra(EXTRA_REMOTE_VIEWS, remoteViews); sendBroadcast(intent); &#125;&#125; 2 个不同进程之间更新UI可以通过AIDL实现，如果更新较为频繁，AIDL效率低且AIDL接口变得很复杂。RemoteViews 就没有这些问题，但是RemoteViews只支持固定的View。 布局文件加载问题12View view = remoteViews.apply(this,mRemoteViewsContent); mRemoteViewsContent.addView(view); 这种写法在一个App的多进程中传递没什么问题。如果 A 和 B 属于不同的App，B 中的布局文件id传递到A中不一定对应。 这种情况可以约定一个资源名称，通过资源名字来找id。 1234int layoutId = getResources().getIdentifier(\"layout_simulated_ notification\",\"layout\",getPackageName());View view = getLayoutInflater().inflate(layoutId,mRemoteViewsContent, false);remoteViews.reapply(this,view);mRemoteViewsContent.addView(view);","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第2章 Android的IPC机制","slug":"AndroidArtChapter2","date":"2017-06-28T08:37:00.000Z","updated":"2017-07-15T05:20:16.000Z","comments":true,"path":"2017/06/28/AndroidArtChapter2/","link":"","permalink":"https://luwenjie.me/2017/06/28/AndroidArtChapter2/","excerpt":"本章主要讲解Android中的IPC机制。首先介绍Android中的多进程概念以及多进程开发模式中常见的注意事项，接着介绍Android中的序列化机制和Binder，然后详细介绍Bundle、文件共享、AIDL、Messenger、ContentProvider和Socket等进程间通信的方式。为了更好地使用AIDL来进行进程间通信，本章还引入了Binder连接池的概念。最后，本章讲解各种进程间通信方式的优缺点和适用场景。通过本章，可以让读者对Android中的IPC机制和多进程开发模式有深入的理解。","text":"本章主要讲解Android中的IPC机制。首先介绍Android中的多进程概念以及多进程开发模式中常见的注意事项，接着介绍Android中的序列化机制和Binder，然后详细介绍Bundle、文件共享、AIDL、Messenger、ContentProvider和Socket等进程间通信的方式。为了更好地使用AIDL来进行进程间通信，本章还引入了Binder连接池的概念。最后，本章讲解各种进程间通信方式的优缺点和适用场景。通过本章，可以让读者对Android中的IPC机制和多进程开发模式有深入的理解。 简介IPC (Inter-Process Communication)：进程间通信或者跨进程通信，指 2 个进程之间进行数据交换的过程。 线程：CPU 调度的最小单元。进程：一个执行单元，在 PC 和移动设备上指一个程序或者一个应用。 一个进程可以包含多个线程。 其他操作系统的 IPC 机制： Windows：剪贴板，管道，邮槽 多进程 App 因为某些原因，有些模块需要运行在单独的线程中。 加大一个 App 的可使用内存。多线程可以获取更多的可使用内存限制。 2 个 App 之间传递数据。 Android 中的多进程模式开启多进程 在 AndroidMenifest 文件中指定四大组件（Activity、Service、Receiver、ContentProvider）的 android:process 属性。 通过 JNI 在 native 层 fork 一个新的进程。 12345&lt;activity android:name=\".BAct\" android:process=\":ThreadB\"/&gt; &lt;activity android:name=\".BAct\" android:process=\".ThreadB\"/&gt; process 的命名： 以:为前缀：在当前进程前面加上包名。属于当前App的私有进程，其他App的组件不可以和她跑在同一个进程中。 以.为前缀：不会附加包名。全局进程，其他App通过 ShareUID 的方式可以和她跑在一个进程中。 运行机制例子123&lt;activity android:name=\".SecondActivity\" android:process=\":secondThread\" /&gt; UserManager 123public class UserManager &#123; public static int sUserId = 1;&#125; MainActivity#onCreate1234567@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); UserManager.sUserId += 1; Log.d(TAG, \"userId = \" + UserManager.sUserId); startActivity(new Intent(this, SecondActivity.class)); &#125; SecondActivity#onCreate1234@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, \"userId = \" + UserManager.sUserId);&#125; 指定 SecondActivity 的 process 为 :secondThread, 在主线程中先将 userId +1，再打开 SecondActivity, 分别打印 userId 的值。 1206-11 18:06:49.639 5078-5078/com.venjer.ibinderdemo D/MainActivity: userId = 206-11 18:06:50.668 5171-5171/com.venjer.ibinderdemo:secondThread D/SecondActivity: userId = 1 结果他们的值是不一样的。 原因Android 为每一个 App 分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，导致在不同的虚拟机中访问同一个类的对象会产生多个副本。 使用多进程造成的问题 静态成员和单例模式完全失效 线程同步机制完全失效 锁的不是同一块内存的对象 Sharepreferences 的可靠性下降 SharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失, 因为 SharedPreferences 底层是通过读/写XML文件来实现的，并发写显然是可能出问题的，甚至并发读/写都有可能出问题。 Application 会多次创建 运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的，同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application。 系统提供跨进程方式解决 使用 Intent 传递数据 基于 Binder 的 Messenger 和 AIDL 以及 Socket。 IPC 基础概念Serializable 接口Serializable 是 Java 所提供的一个序列化接口。 在类的声明中指定类似下面的标识1private static final long serialVersionUID = 8711368828010083044L; 不添加 serialVersionUID 也可以序列化，但是会对反序列化过程产生影响。 使用 ObjectOutputStream 和 ObjectInputStream 实现正反序列化。 例子123456public class User &#123; private static final long serialVersionUID = 519067123721295773L; public int userId; public String userName; public boolean isMale;&#125; 1234567891011121314151617181920User user = new User();user.isMale = true;user.userName = \"djkh\";user.userId = 0;try &#123; // 序列化 ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"cache.txt\")); outputStream.writeObject(user); outputStream.close(); // 反序列化 ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"cache.txt\")); User newUser = (User) inputStream.readObject(); inputStream.close(); Log.d(TAG,newUser.userName);&#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace();&#125; serialVersionUID 的工作机制原则上序列化后的数据中的 serialVersionUID 只有和当前类的 serialVersionUID 相同时才能正常的被反序列化。 序列化的时候系统会把当前类的 serialVersionUID 写入序列化的文件中(也可能是其他中介)。反序列化的时候检查 serialVersionUID, 如果和之前不一致会报如下错误。 1234java.io.InvalidClassException: Main; local class incompatible: stream classdesc serialVersionUID = 8711368828010083044,local class serial- VersionUID = 8711368828010083043。 注意 静态成员变量不属于对象，不会参与序列化过程 使用 transient 关键字标记的成员变量不会参与序列化过程 Parcelable 接口实现 Parcelable 接口的对象可以通过 Intent 和 Binder 传递。 1234567891011121314151617181920212223242526272829303132public class User implements Parcelable &#123; public int asd; public String asd1; public String asd2; protected User(Parcel in) &#123; asd = in.readInt(); asd1 = in.readString(); asd2 = in.readString(); &#125; public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel parcel, int i) &#123; parcel.writeInt(asd); parcel.writeString(asd1); parcel.writeString(asd2); &#125;&#125; Parcel内部包装了可序列化的数据，可以在 Binder 中自由传输。 writeToParcel: 序列化CREATOR：反序列化，内部标明了如何创建序列化对象和数组。describeContents: 内容描述功能，默认返回0；仅当对象中存在文件描述时返回 1。 区别Parcelable 效率较高，主要用在内存序列化上。将对象序列化到存储设备中或者将对象序列化后通过网络传输建议使用 Serializable。 Binderandroid.os.Binder 是一个类，实现了 IBinder 接口。 1public class Binder implements IBinder Binder 是 Android 中的一种跨进程通信方式，可以理解为一种虚拟的物理设备，设备驱动是 dev/binder。 从 Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManager..）和相应的 ManagerService 的桥梁。 从 Android 应用层来说，Binder 是客户端和服务端进行通信的媒介。 图片来自@Gityuan AIDL 的例子新建实体类 Book，实现 Parcelable 接口。在 aidl 文件中引用自定义的对象需要同时声明那个对象的aidl。 Book.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package me.luwenjie.myapplication;import android.os.Parcel;import android.os.Parcelable;/** * created by venjer on 15/06/2017 14:13 */public class Book implements Parcelable &#123; public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel in) &#123; return new Book(in); &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;; private int bookId; private String bookName; protected Book(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125; public int getBookId() &#123; return bookId; &#125; public void setBookId(int bookId) &#123; this.bookId = bookId; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel parcel, int i) &#123; parcel.writeInt(bookId); parcel.writeString(bookName); &#125;&#125; Book.aidl12345// Book.aidlpackage me.luwenjie.myapplication;// Declare any non-default types here with import statementsparcelable Book; IBookManager.aidl12345678910// IBookManager.aidlpackage me.luwenjie.myapplication;// Declare any non-default types here with import statementsimport me.luwenjie.myapplication.Book;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 系统根据 IBookManager.aidl 自动生成的 IBookManager.java 接口。它继承了 IInterface 接口，定义了 aidl 中声明的方法。同时内部有一个继承 android.os.Binder 的 Stub 静态抽象类。Stub 内部还有一个静态 Proxy 代理类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/* * This file is auto-generated. DO NOT MODIFY. * Original file: /Users/venjerLu/Documents/AndroidStudioStorage/MyApplication2/app/src/main/aidl/me/luwenjie/myapplication/IBookManager.aidl */package me.luwenjie.myapplication;public interface IBookManager extends android.os.IInterface &#123; public java.util.List&lt;me.luwenjie.myapplication.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(me.luwenjie.myapplication.Book book) throws android.os.RemoteException; /** Local-side IPC implementation stub class. */ /** * 客户端和服务端都位于同一个进程时，方法调用不会走 transact 过程，位于不同进程时， * 方法调用需要走 transact 过程，这个逻辑由 Proxy 代理类完成。 */ public static abstract class Stub extends android.os.Binder implements me.luwenjie.myapplication.IBookManager &#123; /** 声明2个整型的id分别用于标识这2个方法，用于标识在 transact 过程中客户端请求的是哪个方法。 */ static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); /** Binder 的唯一标识 */ private static final java.lang.String DESCRIPTOR = \"me.luwenjie.myapplication.IBookManager\"; /** Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an me.luwenjie.myapplication.IBookManager interface, * generating a proxy if needed. */ /** * 将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象 * 如果是同一进程，返回 Stub 对象本身。不同进程返回的是 Stub.Proxy */ public static me.luwenjie.myapplication.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof me.luwenjie.myapplication.IBookManager))) &#123; return ((me.luwenjie.myapplication.IBookManager) iin); &#125; return new me.luwenjie.myapplication.IBookManager.Stub.Proxy(obj); &#125; /** * 返回当前的 Binder 对象 */ @Override public android.os.IBinder asBinder() &#123; return this; &#125; /** * 运行在服务端中的 Binder 线程池中。当客户端发起跨进程请求时，远程请求会通过系统底层封装 * 后交由此方法处理。 * @param code 通过 code 确定客户端请求的目标方法是什么 * @param data 从 data 中取出目标方法所需要的参数，然后执行目标方法。 * @param reply 目标方法执行完毕后向 reply 中写入返回值 * @param flags 额外的操作标记，默认的RPC是0，单向的RPC是&#123;@link #FLAG_ONEWAY&#125; * @return 返回false客户端的请求会失败。因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调 * 用我们的服务 * @throws android.os.RemoteException */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;me.luwenjie.myapplication.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); me.luwenjie.myapplication.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = me.luwenjie.myapplication.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements me.luwenjie.myapplication.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * 运行在客户端 * @return * @throws android.os.RemoteException */ @Override public java.util.List&lt;me.luwenjie.myapplication.Book&gt; getBookList() throws android.os.RemoteException &#123; // 创建输入型 Parcel 对象 _data, 输出型对象 _reply android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;me.luwenjie.myapplication.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); // 发起 RPC(远程过程调用)请求，同时当前线程挂起，服务端的 onTarnsact 会被调用。 // RPC 过程返回后，当前线程继续执行，从 _reply 中取出 RPC 过程的返回结果，最后返回 _reply // 中的数据。 mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(me.luwenjie.myapplication.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; /** * 和 getBookList 一样。它没有返回值，所以不需要从 _reply 中取值。 * @param book * @throws android.os.RemoteException */ @Override public void addBook(me.luwenjie.myapplication.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; &#125;&#125; Binder 的工作机制 当客户端发起远程请求时，当前线程会被挂起直至服务端返回数据，如果一个远程方法是很耗时的，那么不能在 UI 线程中发起请求。 因为服务端的 Binder 方法运行在 Binder 的线程池中，所以 Binder 方法不管是否耗时都应该采用同步的方式去实现。因为它已经运行在一个线程中了。 手动实现 BinderAIDL 是为了方便生成代码。系统根据 AIDL 生成代码的格式是固定的。 将 Stub 从生成的代码中剥离出来。 IBookManager1234567891011121314public interface IBookManager extends IInterface&#123; /** 声明2个整型的id分别用于标识这2个方法，用于标识在 transact 过程中客户端请求的是哪个方法。 */ int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION); int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); /** Binder 的唯一标识 */ java.lang.String DESCRIPTOR = \"me.luwenjie.myapplication.IBookManager\"; List&lt;Book&gt; getBookList() throws RemoteException; void addBook(Book book)throws RemoteException;&#125; BookManagerImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class BookManagerImpl extends Binder implements IBookManager &#123; public BookManagerImpl() &#123; //super(); this.attachInterface(this, IBookManager.DESCRIPTOR); &#125; /** * 将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象 * 如果是同一进程，返回 Stub 对象本身。不同进程返回的是 Stub.Proxy */ public static IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof IBookManager))) &#123; return ((IBookManager) iin); &#125; return new Proxy(obj); &#125; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return null; &#125; @Override public void addBook(Book book) throws RemoteException &#123; &#125; @Override public IBinder asBinder() &#123; return this; &#125; /** * 运行在服务端中的 Binder 线程池中。当客户端发起跨进程请求时，远程请求会通过系统底层封装 * 后交由此方法处理。 * * @param code 通过 code 确定客户端请求的目标方法是什么 * @param data 从 data 中取出目标方法所需要的参数，然后执行目标方法。 * @param reply 目标方法执行完毕后向 reply 中写入返回值 * @param flags 额外的操作标记，默认的RPC是0，单向的RPC是&#123;@link #FLAG_ONEWAY&#125; * @return 返回false客户端的请求会失败。因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调 * 用我们的服务 * @throws android.os.RemoteException */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;me.luwenjie.myapplication.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); me.luwenjie.myapplication.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = me.luwenjie.myapplication.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements IBookManager&#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * 运行在客户端 * @return * @throws android.os.RemoteException */ @Override public java.util.List&lt;Book&gt; getBookList() throws android.os.RemoteException &#123; // 创建输入型 Parcel 对象 _data, 输出型对象 _reply android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;me.luwenjie.myapplication.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); // 发起 RPC(远程过程调用)请求，同时当前线程挂起，服务端的 onTarnsact 会被调用。 // RPC 过程返回后，当前线程继续执行，从 _reply 中取出 RPC 过程的返回结果，最后返回 _reply // 中的数据。 mRemote.transact(TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(me.luwenjie.myapplication.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; /** * 和 getBookList 一样。它没有返回值，所以不需要从 _reply 中取值。 * @param book * @throws android.os.RemoteException */ @Override public void addBook(Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125;&#125; linkToDeath 和 unlinkToDeathBinder 运行在服务端进程，如果服务端进程异常终止，这时客户端到服务端的连接断开(Binder死亡)，导致调用失败。 通过 linkToDeath 给 Binder 设置一个死亡代理，当 Bidner 死亡时，我们就会收到通知。 12345678910111213141516171819202122232425262728/** * Register the recipient for a notification if this binder * goes away. If this binder object unexpectedly goes away * (typically because its hosting process has been killed), * then the given &#123;@link DeathRecipient&#125;'s * &#123;@link DeathRecipient#binderDied DeathRecipient.binderDied()&#125; method * will be called. * * &lt;p&gt;You will only receive death notifications for remote binders, * as local binders by definition can't die without you dying as well. * * @throws RemoteException if the target IBinder's * process has already died. * * @see #unlinkToDeath */ public void linkToDeath(DeathRecipient recipient, int flags) throws RemoteException; /** * Interface for receiving a callback when the process hosting an IBinder * has gone away. * * @see #linkToDeath */ public interface DeathRecipient &#123; public void binderDied(); &#125; 当 Binder 死亡时，系统就会回调 binderDied 方法。 Android 中的 IPC 方式Bundle1public final class Bundle extends BaseBundle implements Cloneable, Parcelable Bundle 实现了 Parcelable 接口，可以方便的在不同的进程之间传输。 只能传输 Bundle 支持的数据。 使用文件共享2 个文件通过读/写同一个文件来交换数据。有一定的局限性，比如并发读/写的问题。 适合在对数据同步要求不高的进程之间进行通信，并且要求妥善处理并发读/写的问题。 SharePreference 是 Android 中的轻量级存储方案。 它通过键值对的方式来存储数据，底层采用 XML 文件来存储键值对。本质上 SharePreference 也属于文件的一种，由于系统对它的读写有一定的缓存策略，内存中会有一份 SharePreference 文件的缓存，多进程的时候变得不可靠，有很大几率丢失数据。 使用 Messenger一种轻量级的 IPC 方案，底层实现是 AIDL。 构造方法可以看出 AIDL 的痕迹。1234567 public Messenger(Handler target) &#123; mTarget = target.getIMessenger();&#125;public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target);&#125; 例子： 客户端 MessengerActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MessengerActivity extends AppCompatActivity &#123; private static final String TAG = \"MessengerActivity\"; private final Messenger clientMessenger = new Messenger(new WeakHandler(this)); private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 得到服务端的 Messenger Messenger service1 = new Messenger(service); Message message = Message.obtain(null, MessengerService.MSG_FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString(\"msg\", \"hello,this is client\"); message.setData(bundle); message.replyTo = clientMessenger; try &#123; service1.send(message); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); Intent intent = new Intent(this, MessengerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(mConnection); &#125; private static class WeakHandler extends Handler &#123; private final WeakReference&lt;MessengerActivity&gt; mActivity; public WeakHandler(MessengerActivity activity) &#123; mActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MessengerActivity activity = mActivity.get(); if (activity != null) &#123; switch (msg.what) &#123; case MessengerService.MSG_FROM_SERVICE: Log.d(TAG, \"receive msg from Service:\" + msg.getData().getString(\"reply\")); break; &#125; &#125; &#125; &#125;&#125; 服务端 MessengerService 1234567891011121314151617181920212223242526272829303132public class MessengerService extends Service &#123; public static final int MSG_FROM_CLIENT = 0X1000; public static final int MSG_FROM_SERVICE = 0X1001; private static final String TAG = \"MessengerService\"; private final Messenger messenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return messenger.getBinder(); &#125; private static class MessengerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_FROM_CLIENT: Log.d(TAG,\"receive msg from Client:\" + msg.getData().getString(\"msg\")); // 得到客户端的 Messenger Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(\"reply\",\"yes，i have received, i will reply to you after a moment\"); replyMsg.setData(bundle); try &#123; client.send(replyMsg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; &#125; &#125; &#125;&#125; 123&lt;service android:name=\".MessengerService\" android:process=\":remote\"/&gt; 在 Messenger 中进行数据传输必须将数据放入 Message 中，Messenger 和 Message 都实现了 Parcelable 接口，因此可以跨进程传输。 Message 可以使用的载体： arg1 arg2 object 2.2 之前不支持跨进程, 2.2 之后只支持系统提供的 Parcelable 对象传输 Bundle replyTo Messenger 的工作原理： 使用 AIDLMessenger 以串行的方式处理客户端发来的消息，如果有大量的消息同时发送，服务端仍然只能一个个处理。 ADIL 支持的数据类型： 基本数据类型, String, CharSequence List, 只支持 ArrayList, 里面每个元素都必须能够被 AIDL 支持 Map, 只支持 HashMap，里面每个元素都必须被 AIDL 支持，包括 key 和 value Parcelable AIDL, 所有 AIDL 接口本身也可以在 AIDL 文件中使用 除了基本类，其他类型的参数必须标上方向：in(输入型参数), out(输出型参数), inout(输入输出型参数) 客户端调用服务端的方法，被调用的方法运行在 Binder 线程池中，同时客户端被挂起，如果服务端的方法比较耗时，并且客户端运行在UI线程就会发生 ANR。避免在客户端的 UI 线程访问远程方法。 服务端的方法本身就运行在 Binder 线程池，可以执行大量任务。非常不建议在服务端方法中开启线程去进行异步任务。 当远程客户端需要调用客户端的 listener 中的方法时，被调用的方法也运行在 Binder 客户端的线程池中。同样不可以在服务端的 UI 线程调用客户端的耗时方法。 如果要在客户端的 Binder 线程池的方法里访问 UI，必须使用 Handler 切换到 UI 线程。 RemoteCallbackList1public class RemoteCallbackList&lt;E extends IInterface&gt; 系统专门提供的用于删除跨进程 Listener 的类。支持任意的 AIDL 类型。 内部有一个 ArrayMap&lt;IBinder, Callback&gt; 来保存所有的 AIDL 回调。 虽然多进程时服务端会生成一个不同的对象，但是他们对应的底层的 Binder 是同一个。只需要根据 Binder 查找对应的 listener 删除。 当客户端进程终止后，它可以自动移除客户端所注册的 listener。 内部自动实现了线程同步的功能。各个方法都加了 synchronized 锁。 12345678final int N = mListenerList.beginBroadcast(); for (int i = 0; i &lt; N; i++) &#123; IOnNewBookArrivedListener l = mListenerList.getBroadcastItem(i); if (l != null) &#123; //TODO handle l &#125; &#125;mListenerList.finishBroadcast(); beginBroadcast和finishBroadcast必须配对使用，哪怕只是想获取里面的元素数量。 Binder 意外死亡服务端意外停止，需要重新连接服务。 给 Binder 设置 DeathRecipient 监听，Binder 死亡时会收到 binderDied() 回调，此方法在 Binder 线程池中被调用，不能访问 UI 在 ServiceConnection 中 onServiceDisconnected() 方法重连，此方法在 UI 线程中调用，可以访问 UI。 权限 在 onBind() 中验证。例如使用 permission 验证。 在服务端的 onTransact 方法进行验证，验证失败直接返回 false。可以采用 permission，Uid 和 Pid 例子：图书管理类，每隔5s后台加一本书并通知前台加了什么书。Book.aidl 1234567// IBook.aidlpackage me.luwenjie.myapplication;// Declare any non-default types here with import statements//import me.luwenjie.myapplication.Book;parcelable Book; IBookListener.aidl12345678// IOnNewBookArrivedListener.aidlpackage me.luwenjie.myapplication;// Declare any non-default types here with import statementsimport me.luwenjie.myapplication.Book;interface IBookListener &#123; void onAddBook(in Book book);&#125; IBookManager.aidl123456789101112// IBookManager.aidlpackage me.luwenjie.myapplication;// Declare any non-default types here with import statementsimport me.luwenjie.myapplication.Book;import me.luwenjie.myapplication.IBookListener;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IBookListener listener); void unregisterListener(IBookListener listener);&#125; BookManagerService 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class BookManagerService extends Service &#123; private static final String TAG = \"BookManagerService\"; private CopyOnWriteArrayList&lt;Book&gt; mBooks = new CopyOnWriteArrayList&lt;&gt;(); private RemoteCallbackList&lt;IBookListener&gt; mBookListeners = new RemoteCallbackList&lt;&gt;(); private AtomicBoolean mIsServiceDestoryed = new AtomicBoolean(false); private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBooks; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBooks.add(book); &#125; @Override public void registerListener(IBookListener listener) throws RemoteException &#123; mBookListeners.register(listener); //if (!mBookListeners.contains(listener)) &#123; // mBookListeners.add(listener); //&#125; else &#123; // Log.d(TAG, listener + \"already exits\"); //&#125; Log.d(TAG, \"listeners.size = \" + getListenerSize()); &#125; @Override public void unregisterListener(IBookListener listener) throws RemoteException &#123; mBookListeners.unregister(listener); //if (mBookListeners.contains(listener)) &#123; // mBookListeners.remove(listener); //&#125; else &#123; // Log.d(TAG, listener + \"，not exits\"); //&#125; Log.d(TAG, \"listeners.size = \" + getListenerSize()); &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // 验证 permission int i = checkCallingOrSelfPermission(\"me.luwenjie.permission.BOOKMANAGER\"); if (i == PackageManager.PERMISSION_DENIED) &#123; Log.d(TAG, \"PERMISSION_DENIED：me.luwenjie.permission.BOOKMANAGER\"); return false; &#125; // 验证包名 String packageName; String[] packages = getPackageManager().getPackagesForUid(getCallingUid()); if (packages != null &amp;&amp; packages.length &gt; 0) &#123; packageName = packages[0]; if (!packageName.startsWith(\"me.luwenjie\")) &#123; return false; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; &#125;; private int getListenerSize() &#123; int i = mBookListeners.beginBroadcast(); mBookListeners.finishBroadcast(); return i; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; int i = checkCallingOrSelfPermission(\"me.luwenjie.permission.BOOKMANAGER\"); if (i == PackageManager.PERMISSION_DENIED) &#123; Log.d(TAG, \"PERMISSION_DENIED：me.luwenjie.permission.BOOKMANAGER\"); return null; &#125; Log.d(TAG, \"PERMISSION_GRANTED\"); return mBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); mBooks.add(new Book(\"think in java\", \"48.90\")); mBooks.add(new Book(\"Android开发艺术探索\", \"78.90\")); new Thread(new ServiceWorker()).start(); &#125; /** * 避免直接在 UI 线程调用客户端的耗时方法，防止服务端无响应 */ private void onAddBook(Book book) &#123; mBooks.add(book); int size = mBookListeners.beginBroadcast(); for (int i = 0; i &lt; size; i++) &#123; IBookListener item = mBookListeners.getBroadcastItem(i); if (item != null) &#123; try &#123; item.onAddBook(book); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; mBookListeners.finishBroadcast(); //for (IBookListener listener : mBookListeners) &#123; // try &#123; // listener.onAddBook(book); // &#125; catch (RemoteException e) &#123; // e.printStackTrace(); // &#125; //&#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); mIsServiceDestoryed.set(true); &#125; private class ServiceWorker implements Runnable &#123; @Override public void run() &#123; while (!mIsServiceDestoryed.get()) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int bookId = mBooks.size() + 1; int price = new Random().nextInt(100); Book newBook = new Book(\"newBook#\" + bookId, price + \"\"); onAddBook(newBook); &#125; &#125; &#125;&#125; BookManagerActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class BookManagerActivity extends AppCompatActivity &#123; private static final String TAG = \"BookManagerActivity\"; private static final int MESSAGE_NEW_BOOK_ADD = 1; private IBookManager mRemoteManager; private WeakHandler mHandler = new WeakHandler(this); private IBookListener mBookListener = new IBookListener.Stub() &#123; @Override public void onAddBook(Book book) throws RemoteException &#123; Message message = mHandler.obtainMessage(MESSAGE_NEW_BOOK_ADD, book); message.sendToTarget(); // 如果要在客户端的 Binder 线程池的方法里访问 UI，必须使用 Handler 切换到 UI 线程。 // mHandler.post() &#125; &#125;; private final ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mRemoteManager = IBookManager.Stub.asInterface(service); try &#123; mRemoteManager.registerListener(mBookListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_bookmanager); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); findViewById(R.id.bt_add).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 在子线程去调用远程服务端的耗时方法 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; int price = new Random().nextInt(100); int name = mRemoteManager.getBookList().size() + 1; addABook(\"new Book#\" + name, \"\" + price); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;); &#125; private void addABook(String name, String price) &#123; try &#123; List&lt;Book&gt; list = mRemoteManager.getBookList(); Log.d(TAG, \"query book list,list type:\" + list.getClass().getCanonicalName()); Log.d(TAG, \"query book list:\" + list.toString()); for (Book book : list) &#123; Log.d(TAG, \"book info: \" + book.getName() + \", \" + book.getPrice()); &#125; // 添加一本书 final Book newBook = new Book(name, price); mRemoteManager.addBook(newBook); List&lt;Book&gt; newBookList = mRemoteManager.getBookList(); Log.i(TAG, \"query book list:\" + newBookList.toString()); for (Book book : newBookList) &#123; Log.d(TAG, \"newBook info: \" + book.getName() + \", \" + book.getPrice()); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(mConnection); // 反注册监听器，这里会发现不起作用。后台找不到注册过的这个监听器， // 这里的监听器是从前台传到后台的，难道中间发生了变化？ // 因为这是多进程，操作的不是同一个对象，Binder 会把客户端传过来的对象 // 重新转化并生成一个新的对象。对象是不能跨进程传输的，本质上是通过序列化反序列化来完成。 // 所以 AIDL 中的自定义对象都需要实现 Parcelable。 // 必须使用 RemoteCallbackList 来解决这个问题。 if (mRemoteManager != null &amp;&amp; mRemoteManager.asBinder().isBinderAlive()) &#123; Log.d(TAG, \"unregister listener:\" + mBookListener); try &#123; mRemoteManager.unregisterListener(mBookListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class WeakHandler extends Handler &#123; private final WeakReference&lt;BookManagerActivity&gt; mActivity; WeakHandler(BookManagerActivity activity) &#123; mActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; BookManagerActivity activity = mActivity.get(); if (activity != null) &#123; switch (msg.what) &#123; case MESSAGE_NEW_BOOK_ADD: Log.d(TAG, \"receive new book :\" + msg.obj); break; &#125; &#125; &#125; &#125;&#125; 使用 ContentProvider用于不同应用共享数据，天生适合进程间通信。 与 Messenger 一样，底层实现也是 Binder。 1234Uri uri = Uri.parse(\"content://me.luwenjie.BookContentProvider\");getContentResolver().query(uri,null,null,null,null);getContentResolver().query(uri,null,null,null,null);getContentResolver().query(uri,null,null,null,null); 调用 3 次 query，onCreate 在主线程执行，三次 query 在 Binder 线程池的 3 个不同的线程执行。1234onCreate, mainquery, Binder:6895_2query, Binder:6895_3query, Binder:6895_2 例子BookContentProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109** * created by venjer on 23/06/2017 18:52 * 除了(onCreate()) 方法都运行在 ContentProvider 的进程中 */public class BookContentProvider extends ContentProvider &#123; public static final String AUTHORITY = \"me.luwenjie.BookContentProvider\"; public static final Uri BOOK_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/book\"); public static final Uri USER_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/user\"); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); private static final String TAG = \"BookContentProvider\"; static &#123; // 分别为 book 表和 user 表指定了 Uri。 sUriMatcher.addURI(AUTHORITY, \"book\", BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, \"user\", USER_URI_CODE); &#125; private ContentResolver mContentResolver; private SQLiteDatabase mDb; /** * 由系统回调运行在主线程中 */ @Override public boolean onCreate() &#123; Log.d(TAG, \"onCreate, \" + Thread.currentThread().getName()); initProviderData(); mContentResolver = getContext().getContentResolver(); return false; &#125; private void initProviderData() &#123; mDb = new DbOpenHelper(getContext()).getWritableDatabase(); mDb.execSQL(\"delete from \" + DbOpenHelper.BOOK_TABLE_NAME); mDb.execSQL(\"delete from \" + DbOpenHelper.USER_TABLE_NAME); mDb.execSQL(\"insert into book values(3,'Android');\"); mDb.execSQL(\"insert into book values(4,'iOS');\"); mDb.execSQL(\"insert into book values(5,'Html5');\"); mDb.execSQL(\"insert into user values(1,'jake',1);\"); mDb.execSQL(\"insert into user values(2,'jasmine',0);\"); &#125; @Nullable @Override public String getType(@NonNull Uri uri) &#123; Log.d(TAG, \"getType, \" + Thread.currentThread().getName()); return null; &#125; @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; Log.d(TAG, \"query, \" + Thread.currentThread().getName()); String tableName = getTableName(uri); if (TextUtils.isEmpty(tableName)) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; return mDb.query(tableName, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) &#123; Log.d(TAG, \"insert, \" + Thread.currentThread().getName()); String tableName = getTableName(uri); if (TextUtils.isEmpty(tableName)) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; mDb.insert(tableName, null, values); if (mContentResolver != null) mContentResolver.notifyChange(uri, null); return uri; &#125; @Override public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) &#123; Log.d(TAG, \"delete, \" + Thread.currentThread().getName()); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; int raw = mDb.delete(table, selection, selectionArgs); if (raw &gt; 0 &amp;&amp; mContentResolver != null) mContentResolver.notifyChange(uri, null); return raw; &#125; @Override public int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) &#123; Log.d(TAG, \"update, \" + Thread.currentThread().getName()); return 0; &#125; /** * 通过uri获取表名 */ private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = DbOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DbOpenHelper.USER_TABLE_NAME; break; &#125; return tableName; &#125;&#125; DbOpenHelper12345678910111213141516171819202122232425262728293031323334353637383940public class DbOpenHelper extends SQLiteOpenHelper &#123; public static final String BOOK_TABLE_NAME = \"book\"; public static final String USER_TABLE_NAME = \"user\"; private static final String TAG = \"DbOpenHelper\"; private static final String DB_NAME = \"book_provider.db\"; private static final int DB_VERSION = 1; // 图书和用户信息表 private String CREATE_BOOK_TABLE = \"CREATE TABLE IF NOT EXISTS \" + BOOK_TABLE_NAME + \"(_ID INTEGER PRIMARY KEY,\" + \"name TEXT)\"; private String CREATE_USER_TABLE = \"CREATE TABLE IF NOT EXISTS \" + USER_TABLE_NAME + \"(_ID INTEGER PRIMARY KEY,\" + \"name TEXT,\" + \"sex INT)\"; public DbOpenHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; public DbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public DbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) &#123; super(context, name, factory, version, errorHandler); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_USER_TABLE); db.execSQL(CREATE_BOOK_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; ContentProviderActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ContentProviderActivity extends AppCompatActivity &#123; private static final String TAG = \"ContentProviderActivity\"; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_contentprovider); //Uri uri = Uri.parse(\"content://me.luwenjie.BookContentProvider\"); //getContentResolver().query(uri,null,null,null,null); //getContentResolver().query(uri,null,null,null,null); //getContentResolver().query(uri,null,null,null,null); Uri bookUri = Uri.parse(\"content://me.luwenjie.BookContentProvider/book\"); // 先添加一本 程序设计的艺术 ContentValues values = new ContentValues(); values.put(\"_id\", 6); values.put(\"name\", \"程序设计的艺术\"); getContentResolver().insert(bookUri, values); // 查询所有的书 Cursor bookCursor = getContentResolver().query(bookUri, new String[] &#123; \"_id\", \"name\" &#125;, null, null, null); if (bookCursor != null) &#123; while (bookCursor.moveToNext()) &#123; Book book = new Book(); book.setBookId(bookCursor.getInt(0)); book.setName(bookCursor.getString(1)); Log.d(TAG, \"query book: \" + book.toString()); &#125; bookCursor.close(); &#125; Uri userUri = Uri.parse(\"content://me.luwenjie.BookContentProvider/user\"); Cursor userCursor = getContentResolver().query(userUri, new String[] &#123; \"_id\", \"name\", \"sex\" &#125;, null, null, null); if (userCursor != null) &#123; while (userCursor.moveToNext()) &#123; User user = new User(); user.setUserId(userCursor.getInt(0)); user.setUserName(userCursor.getString(1)); user.setMale(userCursor.getInt(2) == 1); Log.d(TAG, \"query user: \" + user.toString()); &#125; userCursor.close(); &#125; &#125;&#125; AndroidManifest.xml123456&lt;provider android:name=\".BookContentProvider\" android:authorities=\"me.luwenjie.BookContentProvider\" android:permission=\"me.luwenjie.BOOK_PROVIDER\" android:process=\":provider\" /&gt; 使用 Socket套接字，分为流式套接字和用户数据报套接字。对应于网络的传输控制层的 TCP 和 UDP 协议。TCP 协议是面向连接的协议，提供稳定的双向通信功能。UDP 是无连接的，提供不稳定的单向通信功能，也可实现双向通信。 UDP 拥有更好的效率，但是不保证数据的正确传输。 Binder 连接池当有非常多的业务模块都需要使用 AIDL 时，不能无限制的增加 Service 的数量。应该将所有的 AIDL 放在同一个 Service 中去管理。 每个业务模块创建自己的 AIDL 接口并实现此接口，不同的业务模块不能有耦合，向服务端提供自己的唯一标识和其对应的 Binder 对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class BindPool &#123; public static final int BINDER_SECURITY_CENTER = 1; public static final int BINDER_COMPUTE = 2; private static final String TAG = \"BindPool\"; private static volatile BindPool sInstance; private IBindPool mIBinderPool; private CountDownLatch mCountDownLatch; private Context mContext; private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.d(TAG, \"binder died\"); mIBinderPool.asBinder().unlinkToDeath(mDeathRecipient, 0); mIBinderPool = null; connectBinderPoolService(); &#125; &#125;; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mIBinderPool = IBindPool.Stub.asInterface(service); try &#123; mIBinderPool.asBinder().linkToDeath(mDeathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mCountDownLatch.countDown(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; public BindPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; public static BindPool getInstance(Context context) &#123; if (sInstance == null) &#123; synchronized (BindPool.class) &#123; if (sInstance == null) &#123; sInstance = new BindPool(context); &#125; &#125; &#125; return sInstance; &#125; private synchronized void connectBinderPoolService() &#123; mCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try &#123; mCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public IBinder queryBinder(int bindCode) &#123; IBinder binder = null; if (mIBinderPool != null) &#123; try &#123; binder = mIBinderPool.queryBinder(bindCode); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; return binder; &#125; public static class BinderPoolImpl extends IBindPool.Stub &#123; private static final String TAG = \"BinderPoolImpl\"; @Override public IBinder queryBinder(int binderCode) &#123; IBinder iBinder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: iBinder = new SecurityCenterImpl(); break; case BINDER_COMPUTE: iBinder = new ComputeImpl(); break; &#125; return iBinder; &#125; &#125;&#125; 选用合适的 IPC","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第6章 Android的Drawable","slug":"Android开发艺术探索笔记第6章","date":"2017-06-19T08:37:00.000Z","updated":"2017-06-19T04:14:05.000Z","comments":true,"path":"2017/06/19/Android开发艺术探索笔记第6章/","link":"","permalink":"https://luwenjie.me/2017/06/19/Android开发艺术探索笔记第6章/","excerpt":"Drawable表示的是一种可以在Canvas上进行绘制的抽象的概念，它的种类有很多，最常见的颜色和图片都可以是一个Drawable。","text":"Drawable表示的是一种可以在Canvas上进行绘制的抽象的概念，它的种类有很多，最常见的颜色和图片都可以是一个Drawable。 简介1public abstract class Drawable 在Android的设计中，Drawable是一个抽象类，它是所有Drawable对象的基类，每个具体的Drawable都是它的子类，比如ShapeDrawable、BitmapDrawable等。 使用getIntrinsicWidth ，getIntrinsicHeight 获得宽和高，不是所有的 Drawable 都有宽高。 分类常见的有 BitmapDrawable, ShapeDrawable, LayerDrawable 以及 StateListDrawable。 BitmapDrawable12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\" &lt;!--资源id--&gt; android:src=\"@mipmap/ic_launcher\" &lt;!--抗锯齿--&gt; android:antialias=\"true\" &lt;!--抖动--&gt; android:dither=\"true\" &lt;!--过滤--&gt; android:filter=\"true\" &lt;!--位置--&gt; android:gravity=\"center\" &lt;!--平铺模式--&gt; android:tileMode=\"repeat\" &gt;&lt;/bitmap&gt; 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;nine-patch xmlns:android=\"http://schemas.android.com/apk/res/android\" android:src=\"@mipmap/ic_launcher\"&gt; &lt;!--属性和bitmap一样--&gt;&lt;/nine-patch&gt; ShapeDrawable12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:innerRadius=&quot;2dp&quot; android:innerRadiusRatio=&quot;1&quot; android:shape=&quot;rectangle&quot; &gt; &lt;corners android:bottomLeftRadius=&quot;2dp&quot; android:bottomRightRadius=&quot;2dp&quot; android:radius=&quot;3dp&quot; android:topLeftRadius=&quot;2dp&quot; android:topRightRadius=&quot;2dp&quot; /&gt; &lt;gradient android:angle=&quot;2&quot; android:centerColor=&quot;@color/colorAccent&quot; android:centerX=&quot;23&quot; android:centerY=&quot;22&quot; android:endColor=&quot;@color/colorPrimaryDark&quot; android:gradientRadius=&quot;23dp&quot; android:startColor=&quot;@color/colorAccent&quot; android:type=&quot;linear&quot; android:useLevel=&quot;true&quot; /&gt; &lt;padding android:bottom=&quot;2dp&quot; android:left=&quot;2dp&quot; android:right=&quot;2dp&quot; android:top=&quot;2dp&quot; /&gt; &lt;size android:height=&quot;100dp&quot; android:width=&quot;200dp&quot; /&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot; /&gt; &lt;stroke android:width=&quot;2dp&quot; android:color=&quot;@color/colorPrimary&quot; android:dashWidth=&quot;2dp&quot; android:dashGap=&quot;2dp&quot; /&gt;&lt;/shape&gt; android:shape 表示形状，有四个选项：rectangle（矩形）、oval（椭圆）、line（横线）和ring（圆环）。它的默认值是矩形，另外line和ring这两个选项必须要通过标签来指定线的宽度和颜色等。 针对ring这个形状，有5个特殊的属性：android:innerRadius、android:thickness、android:innerRadiusRatio、android:thicknessRatio和android:useLevel。 corner 表示 shape 的四个角度，只适用于矩形的 shape。 gradient 与 标签是互相排斥的。表示渐变效果。 solid 纯色填充 stroke Shape 的描边。 padding 表示包含 Shape 的 View 的空白 size 大小。 LayerDrawable是一种层次化的 Drawable 集合，通过将不同的 Drawable 放置在不同的层上面达到一种叠加后的效果。 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/name\" &lt;!--相对于View向下的偏移量--&gt; android:bottom=\"23dp\" android:drawable=\"@mipmap/ic_launcher\" &lt;!--相对于View向左的偏移量--&gt; android:left=\"23dp\" &lt;!--相对于View向右的偏移量--&gt; android:right=\"23dp\" &lt;!--相对于View向上的偏移量--&gt; android:top=\"23dp\" /&gt;&lt;/layer-list&gt; 文本框输入背景123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"#0ac39e\"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom=\"6dp\"&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"#ffffff\"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom=\"1dp\" android:left=\"1dp\" android:right=\"1dp\"&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"@android:color/black\"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; StateListDrawable LevelListDrawable对于于 标签。它同样表示一个Drawable集合，集合中的每个Drawable都有一个等级（level）的概念。根据不同的等级，LevelListDrawable会切换为对应的Drawable。 TransitionDrawableTransitionDrawable对应于标签，它用于实现两个Drawable之间的淡入淡出效果 InsetDrawableInsetDrawable对应于标签，它可以将其他Drawable内嵌到自己当中，并可以在四周留出一定的间距。当一个View希望自己的背景比自己的实际区域小的时候，可以采用InsetDrawable来实现，同时我们知道，通过LayerDrawable也可以实现这种效果。 ScaleDrawableScaleDrawable对应于标签，它可以根据自己的等级（level）将指定的Drawable缩放到一定比例。 ClipDrawableClipDrawable对应于标签，它可以根据自己当前的等级（level）来裁剪另一个Drawable，裁剪方向可以通过android:clipOrientation和an-droid:gravity这两个属性来共同控制 自定义 DrawableDrawable的使用范围很单一，一个是作为Im-ageView中的图像来显示，另外一个就是作为View的背景，大多数情况下Drawable都是以View的背景这种形式出现的。Drawable的工作原理很简单，其核心就是draw方法。","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第10章 Android的消息机制","slug":"Android开发艺术探索笔记第10章","date":"2017-06-02T10:37:00.000Z","updated":"2017-06-02T03:50:31.000Z","comments":true,"path":"2017/06/02/Android开发艺术探索笔记第10章/","link":"","permalink":"https://luwenjie.me/2017/06/02/Android开发艺术探索笔记第10章/","excerpt":"Handler是Android消息机制的上层接口。很多人认为Handler的作用是更新UI，这的确没错，但是更新UI仅仅是Handler的一个特殊的使用场景。具体来说是这样的：有时候需要在子线程中进行耗时的I/O操作，可能是读取文件或者访问网络等，当耗时操作完成以后可能需要在UI上做一些改变，由于Android开发规范的限制，我们并不能在主线程中访问UI控件，否则就会触发程序异常，这个时候通过Handler就可以将更新UI的操作切换到主线程中执行。","text":"Handler是Android消息机制的上层接口。很多人认为Handler的作用是更新UI，这的确没错，但是更新UI仅仅是Handler的一个特殊的使用场景。具体来说是这样的：有时候需要在子线程中进行耗时的I/O操作，可能是读取文件或者访问网络等，当耗时操作完成以后可能需要在UI上做一些改变，由于Android开发规范的限制，我们并不能在主线程中访问UI控件，否则就会触发程序异常，这个时候通过Handler就可以将更新UI的操作切换到主线程中执行。 概述Handler, Looper, MessageQueue 三者是一个整体。Handler的作用是将一个任务切换到某个指定的线程中去执行。 因为Android规定访问UI只能在主线程中进行，如果在子线程中访问UI，那么程序就会抛出异常。ViewRootImpl对UI操作做了验证，这个验证工作是由ViewRootImpl的checkThread方法来完成的。 ViewRootImpl#checkThread()123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125;&#125; 系统之所以提供Handler，主要原因就是为了解决在子线程中无法访问UI的矛盾。 为什么不允许在子线程中访问UI呢？ Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，那为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂；其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。鉴于这两个缺点，最简单且高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换一下UI访问的执行线程即可。 Handler的工作原理 Handler 创建时会使用当前线程的 Looper 来构建循环系统，如果线程中没有 Looper，就会报错。 需要在执行任务前调用Looper.prepare()创建Looper。 123456E/AndroidRuntime(27568): java.lang.RuntimeException:Can't create handler inside thread that has not called Looper.prepare() Handler的post和send方法最终都会调用sendMessageAtTime() Handler#sendMessageAtTime() 12345678910 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; Handler#enqueueMessage() 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 最后他回调用MessageQueue的enqueueMessage() 将消息放入消息队列，然后Looper发现有新消息到来时，就回处理这个消息，最后消息中的Runnable或者Handler的handleMessage方法就会被调用。 Looper 运行在创建 Handler 所在的线程中，这样Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。 分析ThreadLocal 工作原理 某些数据是以线程为作用域并且不同线程具有不同的数据副本。 使用场景： 对于 Handler，需要获取当前线程的 Looper，不同的线程对应不同的 Looper，通过 ThreadLocal 就可以轻松实现 Looper 在线程中的存取。如果不用 ThreadLocal，系统就必须提供一个 LooperManager 类来管理。 复杂逻辑下的对象传递。比如存储监听器。 ThreaLocal#set()、get() 123456789101112131415161718192021222324252627282930/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 将数据存储在一个 ThradLocalMap 里，每个线程都有一个 map。 消息队列的工作原理MessageQueue 主要有 2 个操作：插入和读取。 MessageQueue#enqueueMessage()12345678910111213141516171819202122232425262728293031323334353637383940414243boolean enqueueMessage(Message msg, long when) &#123; // ... synchronized (this) &#123; // ... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 主要的操作就是一个单链表的插入。 MessageQueue#next()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Message next() &#123; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; next 是一个无限循环的方法，如果消息队列没有消息，next会一直阻塞在这。有新消息到来时，next会返回新消息并将其从单链表删除。 Looper的工作原理构造方法Looper#Looper()1234 private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 构造方法中创建消息队列，把当前的线程对象保存。 使用例子： 123456789101112131415161718class LooperThread extends Thread &#123; public Handler mHandler; @Override public void run() &#123; // 为当前线程创建一个Looper Looper.prepare(); mHandler = new Handler()&#123; @Override public void handleMessage(Message msg)&#123; &#125; &#125;; // 开启消息循环 Looper.loop(); &#125;&#125; Looper#prepare()123456 private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; prepare方法就是将当前线程的looper存入ThreadLocal中。 另外给主线程单独提供了prepareMainLooper()方法，内部也是调用prepare方法，只是保存了静态值sMainLooper。 Looper的退出123456789 // 直接退出Looper public void quit() &#123; mQueue.quit(false);&#125;// 设定一个退出标记，把消息队列中已有的消息处理完再退出。public void quitSafely() &#123; mQueue.quit(true);&#125; Looper 退出后，通过 Handler 发送的消息会失败，Handler 的 send 方法返回 false。 loopLooper#loop()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 这是一个死循环，当 queue.next()==null 时才跳出循环。 如果 MessageQueue 的 next() 返回了新消息，Looper 就会处理这条消息：msg.target.dispatchMessage(msg);，msg.target 就是发送这条消息的 Handler 对象。 Handler#dispatchMessage()123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Handler 的 dispatchMessage 方法是在创建 Handler 时所使用的 Looper 中执行的，这样就成功地将代码逻辑切换到指定的线程中去执行了。 Handler 的工作原理12345678910111213141516171819202122public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; 最终都会调用sendMessageAtTime123456789101112public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; // 向消息队列中插入一条消息，MessageQueue的next方法就会返回消息给 // Looper，Looper收到后开始处理，最终交给Handler处理。 return enqueueMessage(queue, msg, uptimeMillis);&#125; 123456789101112131415public void dispatchMessage(Message msg) &#123; // 检查Message的callback是否为空 if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; // 这里的mCallback是构造方法传入的，默认为null if (mCallback != null) &#123; // 如果这里返回true就不会走下面的handleMessage if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 主线程的消息循环Android 的主线程就是 ActivityThread，入口就是 Java 的 main 方法。 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; // ... // 创建Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); // 创建主线程的Handler，是一个H类 if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); // 循环looper Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; H 类内部定义了一组消息类型，主要包含四大组件的启动和停止等过程。 ActivityThread#H123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122; public static final int DUMP_SERVICE = 123; public static final int LOW_MEMORY = 124; public static final int ACTIVITY_CONFIGURATION_CHANGED = 125; public static final int RELAUNCH_ACTIVITY = 126; public static final int PROFILER_CONTROL = 127; public static final int CREATE_BACKUP_AGENT = 128; public static final int DESTROY_BACKUP_AGENT = 129; public static final int SUICIDE = 130; public static final int REMOVE_PROVIDER = 131; public static final int ENABLE_JIT = 132; public static final int DISPATCH_PACKAGE_BROADCAST = 133; public static final int SCHEDULE_CRASH = 134; public static final int DUMP_HEAP = 135; public static final int DUMP_ACTIVITY = 136; public static final int SLEEPING = 137; public static final int SET_CORE_SETTINGS = 138; public static final int UPDATE_PACKAGE_COMPATIBILITY_INFO = 139; public static final int TRIM_MEMORY = 140; public static final int DUMP_PROVIDER = 141; public static final int UNSTABLE_PROVIDER_DIED = 142; public static final int REQUEST_ASSIST_CONTEXT_EXTRAS = 143; public static final int TRANSLUCENT_CONVERSION_COMPLETE = 144; public static final int INSTALL_PROVIDER = 145; public static final int ON_NEW_ACTIVITY_OPTIONS = 146; public static final int CANCEL_VISIBLE_BEHIND = 147; public static final int BACKGROUND_VISIBLE_BEHIND_CHANGED = 148; public static final int ENTER_ANIMATION_COMPLETE = 149; public static final int START_BINDER_TRACKING = 150; public static final int STOP_BINDER_TRACKING_AND_DUMP = 151; public static final int MULTI_WINDOW_MODE_CHANGED = 152; public static final int PICTURE_IN_PICTURE_MODE_CHANGED = 153; public static final int LOCAL_VOICE_INTERACTION_STARTED = 154; String codeToString(int code) &#123; if (DEBUG_MESSAGES) &#123; switch (code) &#123; case LAUNCH_ACTIVITY: return \"LAUNCH_ACTIVITY\"; case PAUSE_ACTIVITY: return \"PAUSE_ACTIVITY\"; case PAUSE_ACTIVITY_FINISHING: return \"PAUSE_ACTIVITY_FINISHING\"; case STOP_ACTIVITY_SHOW: return \"STOP_ACTIVITY_SHOW\"; case STOP_ACTIVITY_HIDE: return \"STOP_ACTIVITY_HIDE\"; case SHOW_WINDOW: return \"SHOW_WINDOW\"; case HIDE_WINDOW: return \"HIDE_WINDOW\"; case RESUME_ACTIVITY: return \"RESUME_ACTIVITY\"; case SEND_RESULT: return \"SEND_RESULT\"; case DESTROY_ACTIVITY: return \"DESTROY_ACTIVITY\"; case BIND_APPLICATION: return \"BIND_APPLICATION\"; case EXIT_APPLICATION: return \"EXIT_APPLICATION\"; case NEW_INTENT: return \"NEW_INTENT\"; case RECEIVER: return \"RECEIVER\"; case CREATE_SERVICE: return \"CREATE_SERVICE\"; case SERVICE_ARGS: return \"SERVICE_ARGS\"; case STOP_SERVICE: return \"STOP_SERVICE\"; case CONFIGURATION_CHANGED: return \"CONFIGURATION_CHANGED\"; case CLEAN_UP_CONTEXT: return \"CLEAN_UP_CONTEXT\"; case GC_WHEN_IDLE: return \"GC_WHEN_IDLE\"; case BIND_SERVICE: return \"BIND_SERVICE\"; case UNBIND_SERVICE: return \"UNBIND_SERVICE\"; case DUMP_SERVICE: return \"DUMP_SERVICE\"; case LOW_MEMORY: return \"LOW_MEMORY\"; case ACTIVITY_CONFIGURATION_CHANGED: return \"ACTIVITY_CONFIGURATION_CHANGED\"; case RELAUNCH_ACTIVITY: return \"RELAUNCH_ACTIVITY\"; case PROFILER_CONTROL: return \"PROFILER_CONTROL\"; case CREATE_BACKUP_AGENT: return \"CREATE_BACKUP_AGENT\"; case DESTROY_BACKUP_AGENT: return \"DESTROY_BACKUP_AGENT\"; case SUICIDE: return \"SUICIDE\"; case REMOVE_PROVIDER: return \"REMOVE_PROVIDER\"; case ENABLE_JIT: return \"ENABLE_JIT\"; case DISPATCH_PACKAGE_BROADCAST: return \"DISPATCH_PACKAGE_BROADCAST\"; case SCHEDULE_CRASH: return \"SCHEDULE_CRASH\"; case DUMP_HEAP: return \"DUMP_HEAP\"; case DUMP_ACTIVITY: return \"DUMP_ACTIVITY\"; case SLEEPING: return \"SLEEPING\"; case SET_CORE_SETTINGS: return \"SET_CORE_SETTINGS\"; case UPDATE_PACKAGE_COMPATIBILITY_INFO: return \"UPDATE_PACKAGE_COMPATIBILITY_INFO\"; case TRIM_MEMORY: return \"TRIM_MEMORY\"; case DUMP_PROVIDER: return \"DUMP_PROVIDER\"; case UNSTABLE_PROVIDER_DIED: return \"UNSTABLE_PROVIDER_DIED\"; case REQUEST_ASSIST_CONTEXT_EXTRAS: return \"REQUEST_ASSIST_CONTEXT_EXTRAS\"; case TRANSLUCENT_CONVERSION_COMPLETE: return \"TRANSLUCENT_CONVERSION_COMPLETE\"; case INSTALL_PROVIDER: return \"INSTALL_PROVIDER\"; case ON_NEW_ACTIVITY_OPTIONS: return \"ON_NEW_ACTIVITY_OPTIONS\"; case CANCEL_VISIBLE_BEHIND: return \"CANCEL_VISIBLE_BEHIND\"; case BACKGROUND_VISIBLE_BEHIND_CHANGED: return \"BACKGROUND_VISIBLE_BEHIND_CHANGED\"; case ENTER_ANIMATION_COMPLETE: return \"ENTER_ANIMATION_COMPLETE\"; case MULTI_WINDOW_MODE_CHANGED: return \"MULTI_WINDOW_MODE_CHANGED\"; case PICTURE_IN_PICTURE_MODE_CHANGED: return \"PICTURE_IN_PICTURE_MODE_CHANGED\"; case LOCAL_VOICE_INTERACTION_STARTED: return \"LOCAL_VOICE_INTERACTION_STARTED\"; &#125; &#125; return Integer.toString(code); &#125; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case RELAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityRestart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); SomeArgs args = (SomeArgs) msg.obj; handlePauseActivity((IBinder) args.arg1, false, (args.argi1 &amp; USER_LEAVING) != 0, args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY_FINISHING: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); SomeArgs args = (SomeArgs) msg.obj; handlePauseActivity((IBinder) args.arg1, true, (args.argi1 &amp; USER_LEAVING) != 0, args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case STOP_ACTIVITY_SHOW: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStop\"); SomeArgs args = (SomeArgs) msg.obj; handleStopActivity((IBinder) args.arg1, true, args.argi2, args.argi3); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case STOP_ACTIVITY_HIDE: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStop\"); SomeArgs args = (SomeArgs) msg.obj; handleStopActivity((IBinder) args.arg1, false, args.argi2, args.argi3); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case SHOW_WINDOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityShowWindow\"); handleWindowVisibility((IBinder)msg.obj, true); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case HIDE_WINDOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityHideWindow\"); handleWindowVisibility((IBinder)msg.obj, false); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case RESUME_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\"); SomeArgs args = (SomeArgs) msg.obj; handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true, args.argi3, \"RESUME_ACTIVITY\"); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SEND_RESULT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityDeliverResult\"); handleSendResult((ResultData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case DESTROY_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityDestroy\"); handleDestroyActivity((IBinder)msg.obj, msg.arg1 != 0, msg.arg2, false); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case EXIT_APPLICATION: if (mInitialApplication != null) &#123; mInitialApplication.onTerminate(); &#125; Looper.myLooper().quit(); break; case NEW_INTENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityNewIntent\"); handleNewIntent((NewIntentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case RECEIVER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"broadcastReceiveComp\"); handleReceiver((ReceiverData)msg.obj); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (\"serviceCreate: \" + String.valueOf(msg.obj))); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceBind\"); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UNBIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceUnbind\"); handleUnbindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (\"serviceStart: \" + String.valueOf(msg.obj))); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceStop\"); handleStopService((IBinder)msg.obj); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CONFIGURATION_CHANGED: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"configChanged\"); mCurDefaultDisplayDpi = ((Configuration)msg.obj).densityDpi; mUpdatingSystemConfig = true; handleConfigurationChanged((Configuration)msg.obj, null); mUpdatingSystemConfig = false; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CLEAN_UP_CONTEXT: ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj; cci.context.performFinalCleanup(cci.who, cci.what); break; case GC_WHEN_IDLE: scheduleGcIdler(); break; case DUMP_SERVICE: handleDumpService((DumpComponentInfo)msg.obj); break; case LOW_MEMORY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"lowMemory\"); handleLowMemory(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case ACTIVITY_CONFIGURATION_CHANGED: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityConfigChanged\"); handleActivityConfigurationChanged((ActivityConfigChangeData) msg.obj, msg.arg1 == 1 ? REPORT_TO_ACTIVITY : !REPORT_TO_ACTIVITY); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PROFILER_CONTROL: handleProfilerControl(msg.arg1 != 0, (ProfilerInfo)msg.obj, msg.arg2); break; case CREATE_BACKUP_AGENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"backupCreateAgent\"); handleCreateBackupAgent((CreateBackupAgentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case DESTROY_BACKUP_AGENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"backupDestroyAgent\"); handleDestroyBackupAgent((CreateBackupAgentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SUICIDE: Process.killProcess(Process.myPid()); break; case REMOVE_PROVIDER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"providerRemove\"); completeRemoveProvider((ProviderRefCount)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case ENABLE_JIT: ensureJitEnabled(); break; case DISPATCH_PACKAGE_BROADCAST: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"broadcastPackage\"); handleDispatchPackageBroadcast(msg.arg1, (String[])msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SCHEDULE_CRASH: throw new RemoteServiceException((String)msg.obj); case DUMP_HEAP: handleDumpHeap(msg.arg1 != 0, (DumpHeapData)msg.obj); break; case DUMP_ACTIVITY: handleDumpActivity((DumpComponentInfo)msg.obj); break; case DUMP_PROVIDER: handleDumpProvider((DumpComponentInfo)msg.obj); break; case SLEEPING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"sleeping\"); handleSleeping((IBinder)msg.obj, msg.arg1 != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SET_CORE_SETTINGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"setCoreSettings\"); handleSetCoreSettings((Bundle) msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UPDATE_PACKAGE_COMPATIBILITY_INFO: handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData)msg.obj); break; case TRIM_MEMORY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"trimMemory\"); handleTrimMemory(msg.arg1); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UNSTABLE_PROVIDER_DIED: handleUnstableProviderDied((IBinder)msg.obj, false); break; case REQUEST_ASSIST_CONTEXT_EXTRAS: handleRequestAssistContextExtras((RequestAssistContextExtras)msg.obj); break; case TRANSLUCENT_CONVERSION_COMPLETE: handleTranslucentConversionComplete((IBinder)msg.obj, msg.arg1 == 1); break; case INSTALL_PROVIDER: handleInstallProvider((ProviderInfo) msg.obj); break; case ON_NEW_ACTIVITY_OPTIONS: Pair&lt;IBinder, ActivityOptions&gt; pair = (Pair&lt;IBinder, ActivityOptions&gt;) msg.obj; onNewActivityOptions(pair.first, pair.second); break; case CANCEL_VISIBLE_BEHIND: handleCancelVisibleBehind((IBinder) msg.obj); break; case BACKGROUND_VISIBLE_BEHIND_CHANGED: handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 &gt; 0); break; case ENTER_ANIMATION_COMPLETE: handleEnterAnimationComplete((IBinder) msg.obj); break; case START_BINDER_TRACKING: handleStartBinderTracking(); break; case STOP_BINDER_TRACKING_AND_DUMP: handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj); break; case MULTI_WINDOW_MODE_CHANGED: handleMultiWindowModeChanged((IBinder) msg.obj, msg.arg1 == 1); break; case PICTURE_IN_PICTURE_MODE_CHANGED: handlePictureInPictureModeChanged((IBinder) msg.obj, msg.arg1 == 1); break; case LOCAL_VOICE_INTERACTION_STARTED: handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1, (IVoiceInteractor) ((SomeArgs) msg.obj).arg2); break; &#125; Object obj = msg.obj; if (obj instanceof SomeArgs) &#123; ((SomeArgs) obj).recycle(); &#125; if (DEBUG_MESSAGES) Slog.v(TAG, \"&lt;&lt;&lt; done: \" + codeToString(msg.what)); &#125; ActiviyThread 通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActivityThread 的请求后会回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 会向 H 发送消息，H 收到消息后会将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行，即在主线程中执行，这就是主线程的消息循环模型。","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第4章 View的工作原理","slug":"Android开发艺术探索笔记第4章","date":"2017-05-31T10:37:00.000Z","updated":"2017-05-31T10:49:25.000Z","comments":true,"path":"2017/05/31/Android开发艺术探索笔记第4章/","link":"","permalink":"https://luwenjie.me/2017/05/31/Android开发艺术探索笔记第4章/","excerpt":"在本章中主要介绍两方面的内容，首先介绍View的工作原理，接着介绍自定义View的实现方式。在Android的知识体系中，View扮演着很重要的角色，简单来理解，View是Android在视觉上的呈现。","text":"在本章中主要介绍两方面的内容，首先介绍View的工作原理，接着介绍自定义View的实现方式。在Android的知识体系中，View扮演着很重要的角色，简单来理解，View是Android在视觉上的呈现。 ViewRoot 和 DecoreViewViewRootImplViewRoot对应android.view.ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。 在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时创建ViewRooltImpl对象，并将ViewRootImpl对象和DecorView建立联系。 android.view.WindowManagerGlobal#addView() 12345678910111213141516171819202122232425262728293031323334public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //...略... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. //...略... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125;&#125; View的绘制流程是从ViewRoot的performTraversals开始的。流程图： measure 过程决定了View的宽和高，getMeasuredWidth和getMeasuredHeight除了特殊情况都会等于View最终的宽和高。 DecorView DecorView下面有一个竖直的LineaLayout，上面是标题栏，下面是内容栏。 理解MeasureSpec父容器的MeasureSpec 会影响子View的MeasureSpec的生成。 MeasureSpec代表一个32位的int值，高2位代表SpecMode，低30位代表SpecSize。 UNSPECIFIED EXACTLY AT_MOST MeasureSpec和LayoutParams的对应关系具体规则（图片来自@谷歌的小弟）： 在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，再根据这个MeasureSpec来确定View测量后的宽/高。 顶级DecorView的MeasureSpec由窗口的尺寸和其自身的LayoutParam来共同决定。 普通View的MeasureSpec由父View的MeasureSpec和自身的LayoutParam来共同决定。 MeasureSpec 确定后，onMeasure中就可以确定View的测量的宽/高。 DecoreView下面这个方法里的几行代码展示了DecoreView的MeasureSpec的创建过程： ViewRootImpl#measureHierarchy()12345678910private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; // ... // desiredWindowWidth和desiredWindowHeight是屏幕的尺寸 childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // ...&#125; ViewRootImpl#getRootMeasureSpec() 12345678910111213141516171819202122232425262728293031323334/** * Figures out the measure spec for the root view in a window based on it's * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. // match_parent Window强制转成window的size measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; DecorView产生MeasureSpec的规则： LayoutParams.MATCH_PARENT: EXACTLY, 大小为Window的大小。 LayoutParams.WRAP_CONTENT: AT_MOST, 大小不确定，不超过window的大小 固定大小: EXACTLY, 大小为LayoutParams指定的大小。 View的工作流程measure的过程View的measure过程View#onMeasure()1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; View#getDefaultSize 123456789101112131415161718public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: // 大小设置为 getSuggestedMinimum的返回值 result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: // 大小就是MeasureSpec的测量值。 result = specSize; break; &#125; return result;&#125; View#getSuggestedMinimumWidth/heitht12345678910protected int getSuggestedMinimumWidth() &#123; // 得到mMinWidth和背景的最小宽之间的最小值 return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; protected int getSuggestedMinimumHeight() &#123; // 得到mMinHeight和背景的最小高之间的最小值 return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; mMinWidth和mWinHeight分别对应android:minWidth和android:minHeight，这个属性不指定时，默认是0。 Drawable#getMinimumWidth()： 1234public int getMinimumHeight() &#123; final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;&#125; Drawable#getIntrinsicHeight()： 12345678910// 返回Drawable的高，如果是纯色没有高就返回-1.// shapeDrawable就没有原始的宽高，BitmapDrawable有原始宽/高（图片的尺寸）public int getIntrinsicHeight() &#123; return -1;&#125;public int getIntrinsicWidth() &#123; return -1;&#125; 直接继承View的自定义控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。 需要给模式为AT_MOST的情况设置默认值：1234567891011121314151617181920@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getMode(heightMeasureSpec); boolean wIsAT_MOST = widthMode == MeasureSpec.AT_MOST; boolean hIsAT_MOST = heightMode == MeasureSpec.AT_MOST; if (wIsAT_MOST &amp;&amp; hIsAT_MOST) &#123; setMeasuredDimension(mWidth, mHeight); &#125; else if (wIsAT_MOST) &#123; setMeasuredDimension(mWidth, heightSize); &#125; else if (hIsAT_MOST) &#123; setMeasuredDimension(widthSize, mHeight); &#125;else&#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; &#125; TextView、ImageView等针对wrap_content情形，它们的onMeasure方法均做了特殊处理。 ViewGroup的measure过程ViewGroup#measureChildren1234567891011protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; // 遍历测量 measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; ViewGroup#measureChild123456789101112protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); // 根据View的lp和父View的MeasureSpec算出子View的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; ViewGroup是一个抽象类，测量过程onMeasure()需要子类去自行实现。不同的容器类测量细节不一样。 LinearLayout#onMeasure12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; LinearLayout#measureVertical123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123; // ... // See how tall everyone is. Also remember max width. // 遍历子元素并对每个子元素执行 measureChildBeforeLayout for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == View.GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; if (hasDividerBeforeChildAt(i)) &#123; mTotalLength += mDividerHeight; &#125; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); totalWeight += lp.weight; final boolean useExcessSpace = lp.height == 0 &amp;&amp; lp.weight &gt; 0; if (heightMode == MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123; // Optimization: don't bother measuring children who are only // laid out using excess space. These views will get measured // later if we have space to distribute. final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin); skippedMeasure = true; &#125; else &#123; if (useExcessSpace) &#123; // The heightMode is either UNSPECIFIED or AT_MOST, and // this child is only laid out using excess space. Measure // using WRAP_CONTENT so that we can find out the view's // optimal height. We'll restore the original height of 0 // after measurement. lp.height = LayoutParams.WRAP_CONTENT; &#125; // Determine how big this child would like to be. If this or // previous children have given a weight, then we allow it to // use all available space (and we will shrink things later // if needed). final int usedHeight = totalWeight == 0 ? mTotalLength : 0; measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight); final int childHeight = child.getMeasuredHeight(); if (useExcessSpace) &#123; // Restore the original height and record how much space // we've allocated to excess-only children so that we can // match the behavior of EXACTLY measurement. lp.height = 0; consumedExcessSpace += childHeight; &#125; final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); if (useLargestChild) &#123; largestChildHeight = Math.max(childHeight, largestChildHeight); &#125; &#125; /** * If applicable, compute the additional offset to the child's baseline * we'll need later when asked &#123;@link #getBaseline&#125;. */ if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123; mBaselineChildTop = mTotalLength; &#125; // if we are trying to use a child index for our baseline, the above // book keeping only works if there are no children above it with // weight. fail fast to aid the developer. if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123; throw new RuntimeException(\"A child of LinearLayout with index \" + \"less than mBaselineAlignedChildIndex has weight &gt; 0, which \" + \"won't work. Either remove the weight, or don't set \" + \"mBaselineAlignedChildIndex.\"); &#125; boolean matchWidthLocally = false; if (widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT) &#123; // The width of the linear layout will scale, and at least one // child said it wanted to match our width. Set a flag // indicating that we need to remeasure at least that view when // we know our width. matchWidth = true; matchWidthLocally = true; &#125; final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); childState = combineMeasuredStates(childState, child.getMeasuredState()); allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; if (lp.weight &gt; 0) &#123; /* * Widths of weighted Views are bogus if we end up * remeasuring, so keep them separate. */ weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth); &#125; else &#123; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); &#125; i += getChildrenSkipCount(child, i); &#125; if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123; mTotalLength += mDividerHeight; &#125; if (useLargestChild &amp;&amp; (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) &#123; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); // Account for negative margins final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125; &#125; // Add in our padding mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; // Check against our minimum height heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // Reconcile our calculated size with the heightMeasureSpec int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0); heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK; // Either expand children with weight to take up available space or // shrink them if they extend beyond our current bounds. If we skipped // measurement on any children, we need to measure them now. int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace); if (skippedMeasure || remainingExcess != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123; float remainingWeightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == View.GONE) &#123; continue; &#125; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final float childWeight = lp.weight; if (childWeight &gt; 0) &#123; final int share = (int) (childWeight * remainingExcess / remainingWeightSum); remainingExcess -= share; remainingWeightSum -= childWeight; final int childHeight; if (mUseLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123; childHeight = largestChildHeight; &#125; else if (lp.height == 0 &amp;&amp; (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) &#123; // This child needs to be laid out from scratch using // only its share of excess space. childHeight = share; &#125; else &#123; // This child had some intrinsic height to which we // need to add its share of excess space. childHeight = child.getMeasuredHeight() + share; &#125; final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( Math.max(0, childHeight), MeasureSpec.EXACTLY); final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // Child may now not fit in vertical dimension. childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)); &#125; final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); allFillParent = allFillParent &amp;&amp; lp.width == LayoutParams.MATCH_PARENT; final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125; // 子元素测量完毕后，LinearLayout会测量自己的大小 // Add in our padding mTotalLength += mPaddingTop + mPaddingBottom; // TODO: Should we recompute the heightSpec based on the new total length? &#125; else &#123; alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth); // We have no limit, so make all weighted views as tall as the largest child. // Children will have already been measured once. if (useLargestChild &amp;&amp; heightMode != MeasureSpec.EXACTLY) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == View.GONE) &#123; continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); float childExtra = lp.weight; if (childExtra &gt; 0) &#123; child.measure( MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY)); &#125; &#125; &#125; &#125; if (!allFillParent &amp;&amp; widthMode != MeasureSpec.EXACTLY) &#123; maxWidth = alternativeMaxWidth; &#125; maxWidth += mPaddingLeft + mPaddingRight; // Check against our minimum width maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); if (matchWidth) &#123; forceUniformWidth(count, heightMeasureSpec); &#125; &#125; LineaLayout#measureChildBeforeLayout123456789101112131415161718192021 void measureChildBeforeLayout(View child, int childIndex, int widthMeasureSpec, int totalWidth, int heightMeasureSpec, int totalHeight) &#123; measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight); &#125; protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 获取View的宽高measure过程是最复杂的一步，measure完成后，通过getMeasuredWidth/Height可以正确的获取到View的测量宽/高。 在某些极端情况下，系统可能需要多次 measure 才能确定最终的测量宽/高，这时最好在onLayout()中去获取View的测量宽/高，或者最终宽/高。 在Activity启动的时候获取宽高View的measure过程和Activity的生命周期不是同步的，无法保证在 onCreate() 或 onResume() 获取正确的宽高。 解决方法： Activity/View#onWindowFocusChanged表示View已经初始化完毕了，会被多次调用。可以设置一个flag只获取一次。 12345678@Override public void onWindowFocusChanged(boolean hasWindowFocus) &#123; super.onWindowFocusChanged(hasWindowFocus); if (isFocused) &#123; int width = getMeasuredWidth(); int height = getMeasuredHeight(); &#125; isFocused = true;&#125; view.post(runnable)通过post可以将一个 runnable 投递到消息队列的尾部，然后等Looper调用它的时候，View已经初始化好了。 123456789@Override protected void onStart() &#123; super.onStart(); mView.post(new Runnable() &#123; @Override public void run() &#123; int width = mView.getMeasuredWidth(); int height = mView.getMeasuredHeight(); &#125; &#125;);&#125; ViewTreeObserver使用 ViewTreeObserver 的众多回调。比如使用OnGlobalLayoutListener这个接口。当View数的状态发生改变或者View树内部的View的可见性发生改变时，OnGlobalLayoutListener会被回调。 1234567891011@Override protected void onStart() &#123; super.onStart(); mView.getViewTreeObserver() .addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; mView.getViewTreeObserver().removeOnGlobalLayoutListener(this); int width = mView.getMeasuredWidth(); int height = mView.getMeasuredHeight(); &#125; &#125;);&#125; view.measure(int widthMeasureSpec,int heightMeasureSpec)。手动measure来获取View的宽和高。分情况处理，根据View的LayoutParams来分。 match_parent 无法测量。构造这种必须要知道parensize（父容器的剩余时间）。 具体的数值 1234// 宽和高都是100dpint widthMeasureSpec = MeasureSpec.makeMeasureSpec(100,MeasureSpec.EXACTLY);int heightMeasureSpec = MeasureSpec.makeMeasureSpec(100,MeasureSpec.EXACTLY);view.measure(widthMeasureSpec,heightMeasureSepc); wrap_content 1234// View的尺寸使用30位二进制表示，最大是(2^30-1)。int widthMeasureSpec = MeasureSpec.makeMeasureSpec(1&gt;&gt;30-1, MeasureSpec.AT_MOST);int heightMeasureSpec = MeasureSpec.makeMeasureSpec(1&gt;&gt;30-1, MeasureSpec.AT_MOST);view.measure(widthMeasureSpec,heightMeasureSepc); 有2个错误用法，他们违背了系统的内部实现规范（无法通过错误的MeasureSpec去得出合法的SpecMode），导致measure过程错误。不能一定得出measure的正确结果。 第一种 123int widthMeasureSpec = MeasureSpec.makeMeasureSpec(-1,MeasureSpec.UNSPECIFIED);int heightMeasureSpec = MeasureSpec.makeMeasureSpec(-1,MeasureSpec.UNSPECIFIED);view.measure(widthMeasureSpec,heightMeasureSpec); 第二种 1view.measure(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT); layout的过程ViewGroup用来确定子元素的位置，当ViewGroup的位置确定后，会调用onLayout遍历子元素调用其layout，layout中onLayout会被调用。 layout确定View自身的位置，onLayout确定子元素的位置。 View#layout()1234567891011121314151617181920212223242526272829303132333435363738394041424344public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // 首先会通过setFrame来设定View的四个顶点的位置。 // 即初始化mLeft、mRight、mTop和mBottom这四个值，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了。 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; // 调用onLayout确定自子元素的位置 onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; View#setFrame()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; if (DBG) &#123; Log.d(\"View\", this + \" View.setFrame(\" + left + \",\" + top + \",\" + right + \",\" + bottom + \")\"); &#125; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; // Remember our drawn bit int drawn = mPrivateFlags &amp; PFLAG_DRAWN; int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; int newWidth = right - left; int newHeight = bottom - top; boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); // Invalidate our old position invalidate(sizeChanged); mLeft = left; mTop = top; mRight = right; mBottom = bottom; mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom); mPrivateFlags |= PFLAG_HAS_BOUNDS; if (sizeChanged) &#123; sizeChange(newWidth, newHeight, oldWidth, oldHeight); &#125; if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123; // If we are visible, force the DRAWN bit to on so that // this invalidate will go through (at least to our parent). // This is because someone may have invalidated this view // before this call to setFrame came in, thereby clearing // the DRAWN bit. mPrivateFlags |= PFLAG_DRAWN; invalidate(sizeChanged); // parent display list may need to be recreated based on a change in the bounds // of any child invalidateParentCaches(); &#125; // Reset drawn bit to original value (invalidate turns it off) mPrivateFlags |= drawn; mBackgroundSizeChanged = true; if (mForegroundInfo != null) &#123; mForegroundInfo.mBoundsChanged = true; &#125; notifySubtreeAccessibilityStateChangedIfNeeded(); &#125; return changed; &#125; LinearLayout 的 onLayoutLinearLayout#onLayout() 12345678@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; LinearLayout#layoutVertical() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081void layoutVertical(int left, int top, int right, int bottom) &#123; final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go final int width = right - left; int childRight = width - mPaddingRight; // Space available for child int childSpace = width - paddingLeft - mPaddingRight; final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; switch (majorGravity) &#123; case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; &#125; for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; View的getMeasuredWidth和getWidth这两个方法有什么区别1234567public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK;&#125; public final int getWidth() &#123; return mRight - mLeft;&#125; 从getWidth和getHeight的源码再结合mLeft、mRight、mTop和mBottom这四个变量的赋值过程来看，getWidth方法的返回值刚好就是View的测量宽度。 在View的默认实现中，View的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于View的measure过程，而最终宽/高形成于View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。 draw的过程View的绘制过程遵循如下几步： 绘制背景background.draw(canvas)。 绘制自己（onDraw）。 绘制children（dispatchDraw）。 绘制装饰（onDrawScrollBars）。 View#draw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */@CallSuperpublic void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas' layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) &#123; paddingLeft += getLeftPaddingOffset(); &#125; int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) &#123; right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); &#125; final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123; length = (bottom - top) / 2; &#125; // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123; length = (right - left) / 2; &#125; if (verticalEdges) &#123; topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; &#125; if (horizontalEdges) &#123; leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; &#125; saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; if (drawBottom) &#123; canvas.saveLayer(left, bottom - length, right, bottom, null, flags); &#125; if (drawLeft) &#123; canvas.saveLayer(left, top, left + length, bottom, null, flags); &#125; if (drawRight) &#123; canvas.saveLayer(right - length, top, right, bottom, null, flags); &#125; &#125; else &#123; scrollabilityCache.setFadeColor(solidColor); &#125; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; if (drawBottom) &#123; matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); &#125; if (drawLeft) &#123; matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); &#125; if (drawRight) &#123; matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); &#125; canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas);&#125; View绘制过程的传递是通过dispatchDraw来实现的，dis-patchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。 View#setWillNotDraw 12345678910111213/** * If this view doesn't do any drawing on its own, set this flag to * allow further optimizations. By default, this flag is not set on * View, but could be set on some View subclasses such as ViewGroup. * * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125; * you should clear this flag. * * @param willNotDraw whether or not this View draw on its own */public void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);&#125; 如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，系统会进行相应的优化。默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。这个标记位对实际开发的意义是：当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显式地关闭WILL_NOT_DRAW这个标记位。 自定义View分类 继承View重写onDraw 用于实现一些不规则的效果，不方便使用布局的组合方式来实现时使用。需要自己处理wrap_content和padding。 继承ViewGroup派生特殊的Layout 用户实现自定义的布局。采用这种方式稍微复杂一些，需要合适地处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。 继承特定的View（比如TextView） 用于扩展某种已有的View的功能，比如TextView，这种方法比较容易实现。这种方法不需要自己支持wrap_content和padding等。 继承特定的ViewGroup（比如LinearLayout） 采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程。需要注意这种方法和方法2的区别，一般来说方法2能实现的效果方法4也都能实现，两者的主要差别在于方法2更接近View的底层。 注意事项 让View支持wrap_content 如果有必要，让你的View支持padding 尽量不要在View中使用Handler，没必要 View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow View带有滑动嵌套情形时，需要处理好滑动冲突 示例继承View重写onDraw方法12345678910111213141516171819202122232425262728293031public class CircleView extends View &#123; private int mColor = Color.RED; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public CircleView(Context context) &#123; super(context); init(); &#125; public CircleView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth(); int height = getHeight(); int radius = Math.min(width, height) / 2; canvas.drawCircle(width / 2, height / 2, radius, mPaint); &#125;&#125; 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#ffffff\" tools:context=\"me.venjerlu.customviewdemo.MainActivity\" &gt; &lt;me.venjerlu.customviewdemo.CircleView android:id=\"@+id/circleView1\" android:layout_width=\"wrap_content\" android:layout_height=\"100dp\" android:layout_margin=\"10dp\" android:padding=\"10dp\" android:background=\"#000000\" /&gt;&lt;/FrameLayout&gt; 当设置为 wrap_content 时，效果和match_parent一样，我们需要对此设置一个默认值。另外设置了padding却没有效果，需要在onDraw里处理。 修改后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class CircleView extends View &#123; private int mColor = Color.RED; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public CircleView(Context context) &#123; super(context); init(); &#125; public CircleView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int defaultSize = 200; boolean widthIsWrap = widthMode == MeasureSpec.AT_MOST; boolean heightIsWrap = heightMode == MeasureSpec.AT_MOST; if (widthIsWrap &amp;&amp; heightIsWrap) &#123; setMeasuredDimension(defaultSize, defaultSize); &#125; else if (widthIsWrap) &#123; setMeasuredDimension(defaultSize, heightSize); &#125; else if (heightIsWrap) &#123; setMeasuredDimension(widthSize, defaultSize); &#125; else &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, mPaint); &#125;&#125; 自定义属性 在 values 目录下面创建自定义属性的 XML。 在 View 的构造方法中解析处理对应的值。 在布局文件中使用 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"CircleView\"&gt; &lt;attr format=\"color\" name=\"circle_color\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 1234567public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.RED); typedArray.recycle(); init();&#125; 123456789&lt;me.venjerlu.customviewdemo.CircleView android:id=\"@+id/circleView1\" android:layout_width=\"wrap_content\" android:layout_height=\"100dp\" android:layout_margin=\"10dp\" android:padding=\"10dp\" android:background=\"#000000\" app:circle_color=\"@color/colorPrimaryDark\" /&gt; 完整的规范的CircleView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CircleView extends View &#123; private int mColor; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); public CircleView(Context context) &#123; this(context, null); &#125; public CircleView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.RED); typedArray.recycle(); init(); &#125; private void init() &#123; mPaint.setColor(mColor); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int defaultSize = 200; boolean widthIsWrap = widthMode == MeasureSpec.AT_MOST; boolean heightIsWrap = heightMode == MeasureSpec.AT_MOST; if (widthIsWrap &amp;&amp; heightIsWrap) &#123; setMeasuredDimension(defaultSize, defaultSize); &#125; else if (widthIsWrap) &#123; setMeasuredDimension(defaultSize, heightSize); &#125; else if (heightIsWrap) &#123; setMeasuredDimension(widthSize, defaultSize); &#125; else &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int paddingLeft = getPaddingLeft(); int paddingRight = getPaddingRight(); int paddingTop = getPaddingTop(); int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, mPaint); &#125;&#125; 继承ViewGroup派生特殊的Layout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class HorizontalScrollViewEx extends ViewGroup &#123; static final String TAG = \"HorizontalScrollViewEx\"; private int mChildrenSize; private int mChildWidth; private int mChildIndex; // 上次滑动的坐标 private int mLastX = 0; private int mLastY = 0; // 上次滑动的坐标（onInterceptTouchEvent） private int mLastXIntercept = 0; private int mLastYIntercept = 0; private Scroller mScroller; private VelocityTracker mVelocityTracker; public HorizontalScrollViewEx(Context context) &#123; this(context, null); &#125; public HorizontalScrollViewEx(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public HorizontalScrollViewEx(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; if (mScroller == null) mScroller = new Scroller(getContext()); if (mVelocityTracker == null) mVelocityTracker = VelocityTracker.obtain(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; boolean intercepted = false; int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: intercepted = false; if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); intercepted = true; &#125; break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastXIntercept; int deltaY = y - mLastYIntercept; intercepted = Math.abs(deltaX) &gt; Math.abs(deltaY); break; case MotionEvent.ACTION_UP: intercepted = false; break; default: break; &#125; Log.d(TAG, \"intercepted=\" + intercepted); mLastX = x; mLastY = y; mLastXIntercept = x; mLastYIntercept = y; return intercepted; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mVelocityTracker.addMovement(event); int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (!mScroller.isFinished()) &#123; mScroller.abortAnimation(); &#125; break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastXIntercept; int deltaY = y - mLastYIntercept; scrollBy(deltaX, 0); break; case MotionEvent.ACTION_UP: int scrollX = getScrollX(); mVelocityTracker.computeCurrentVelocity(1000); float xVelocity = mVelocityTracker.getXVelocity(); if (Math.abs(xVelocity) &gt;= 50) &#123; mChildIndex = xVelocity &gt; 0 ? mChildIndex - 1 : mChildIndex + 1; &#125; else &#123; mChildIndex = (scrollX + mChildWidth / 2) / mChildWidth; &#125; mChildIndex = Math.max(0, Math.min(mChildIndex, mChildrenSize - 1)); int dx = mChildIndex * mChildWidth - scrollX; smoothScrollBy(dx, 0); mVelocityTracker.clear(); break; default: break; &#125; mLastX = x; mLastY = y; return true; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measuredWidth; int measuredHeight; final int childCount = getChildCount(); measureChildren(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); // 没有子元素就把自己设置为0，0 if (childCount == 0) &#123; setMeasuredDimension(0, 0); &#125; // 判断宽高为wrap_content的情况 else if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; final View childView = getChildAt(0); measuredWidth = childView.getMeasuredWidth() * childCount; measuredHeight = childView.getMeasuredHeight(); setMeasuredDimension(measuredWidth, measuredHeight); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; final View childView = getChildAt(0); measuredHeight = childView.getMeasuredHeight(); setMeasuredDimension(widthSpaceSize, childView.getMeasuredHeight()); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; final View childView = getChildAt(0); measuredWidth = childView.getMeasuredWidth() * childCount; setMeasuredDimension(measuredWidth, heightSpaceSize); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childLeft = 0; final int childCount = getChildCount(); mChildrenSize = childCount; // 这里没有考虑自身的padding和子元素的margin for (int i = 0; i &lt; childCount; i++) &#123; final View childView = getChildAt(i); if (childView.getVisibility() != View.GONE) &#123; final int childWidth = childView.getMeasuredWidth(); mChildWidth = childWidth; childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight()); childLeft += childWidth; &#125; &#125; &#125; @Override public void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; @Override protected void onDetachedFromWindow() &#123; if (mVelocityTracker != null) mVelocityTracker.recycle(); super.onDetachedFromWindow(); &#125; private void smoothScrollBy(int dx, int dy) &#123; mScroller.startScroll(getScrollX(), 0, dx, 0, 500); invalidate(); &#125;&#125; https://github.com/singwhatiwanna/PinnedHeaderExpandableListView 思想首先要掌握基本功，比如View的弹性滑动、滑动冲突、绘制原理等，这些东西都是自定义View所必须的，尤其是那些看起来很炫的自定义View，它们往往对这些技术点的要求更高；熟练掌握基本功以后，在面对新的自定义View时，要能够对其分类并选择合适的实现思路，自定义View的实现方法的分类在4.4.1节中已经介绍过了；另外平时还需要多积累一些自定义View相关的经验，并逐渐做到融会贯通，通过这种思想慢慢地就可以提高自定义View的水平了。","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Android开发艺术探索笔记-第3章 View的事件体系","slug":"yishuyansuo3","date":"2017-05-24T03:17:00.000Z","updated":"2017-05-24T08:09:34.000Z","comments":true,"path":"2017/05/24/yishuyansuo3/","link":"","permalink":"https://luwenjie.me/2017/05/24/yishuyansuo3/","excerpt":"本章将介绍Android中十分重要的一个概念：View，虽然说View不属于四大组件，但是它的作用堪比四大组件，甚至比Receiver和Provider的重要性都要大。在Android开发中，Activity承担这可视化的功能，同时Android系统提供了很多基础控件，常见的有Button、TextView、CheckBox等。很多时候仅仅使用系统提供的控件是不能满足需求的，因此我们就需要能够根据需求进行新控件的定义，而控件的自定义就需要对Android的View体系有深入的理解，只有这样才能写出完美的自定义控件。","text":"本章将介绍Android中十分重要的一个概念：View，虽然说View不属于四大组件，但是它的作用堪比四大组件，甚至比Receiver和Provider的重要性都要大。在Android开发中，Activity承担这可视化的功能，同时Android系统提供了很多基础控件，常见的有Button、TextView、CheckBox等。很多时候仅仅使用系统提供的控件是不能满足需求的，因此我们就需要能够根据需求进行新控件的定义，而控件的自定义就需要对Android的View体系有深入的理解，只有这样才能写出完美的自定义控件。 View的基础知识主要介绍内容： View的位置参数 MotionEvent 和 TouchSlop对象 VelocityTracker GestureDetector Scroller View 的位置参数主要由四个顶点来决定： top：左上角纵坐标 left：左上角横坐标 right：右下角横坐标 bottom：右下角纵坐标 四个顶点坐标都是相对于View的父容器来说的。是相对坐标。 View 的宽高和坐标的关系： 12width = right - left;height = bottom - top 在View的源码中四个坐标对应于mLeft,mRight,mTop,mBottom这四个成员变量。View中有对应的方法获取这四个值： 1234mleft = getLeft();mRight = getRight();mTop = getTop();mBottom = getBottom(); 从Android 3.0 之后，View增加了额外的几个参数： (x, y): View左上角的坐标 translationX: View左上角相对于父容器X方向的偏移量，默认值为0 translationY: View左上角相对于父容器Y方向的偏移量，默认值为0 View中提供了对应的Get/Set方法。 123456789101112131415public float getX() &#123; return mLeft + getTranslationX();&#125;public void setX(float x) &#123; setTranslationX(x - mLeft);&#125;public float getY() &#123; return mTop + getTranslationY();&#125;public void setY(float y) &#123; setTranslationY(y - mTop);&#125; x = left + translationXy = top + translationY 注意：View在平移的过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变。发生变化的是x,y,translationX,translationY。 MotionEvent和TouchSlopMotionEvent手指接触屏幕后会产生一些列事件。典型的有下面几种： ACTION_DOWN: 手指刚接触屏幕 ACTION_MOVE: 手指在屏幕上滑动 ACTION_UP: 手指从屏幕上松开的一瞬间 2种时间序列： 点击屏幕立刻松开, 事件序列为: DOWN-&gt;UP 点击屏幕后滑动一会再松开，事件序列为：DOWN-&gt;MOVE…-&gt;UP 通过MotionEvent可以得到点击事件发生的坐标（x,y）。 getX/getY: 得到相对于View左上角的坐标（x,y）getRawX/getRawY：得到相对于手机屏幕的坐标(x,y) TouchSlopTouchSlop是系统所能识别出的被认为是滑动的最小距离。 这是一个常量，不同设备值可能不一样。 获取方式：ViewConfiguration.get(getCon-text()).getScaledTouchSlop()。 可以利用这个常量做一些滑动的过滤。 在源码中可以找到这个常量的定义：frameworks/base/core/ res/res/values/config.xml 12&lt;!--Base \"touch slop\" value used by ViewConfiguration as a movement threshold where scrolling should begin. --&gt; &lt;dimen name=\"config_viewConfigurationTouchSlop\"&gt;8dp&lt;/dimen&gt; VelocityTracker、GestureDetector和ScrollerVelocityTracker追踪手指在滑动过程中的速度。包括水平和竖直 12345VelocityTracker velocityTracker = VelocityTracker.obtain();// 1000代表速度的单位为1秒velocityTracker.computeCurrentVelocity(1000);float xVelocity = velocityTracker.getXVelocity();float yVelocity = velocityTracker.getYVelocity(); 获取速度之前先计算速度。先调用computeCurrentVelocity 这里的速度是指一段时间手指划过的像素数。 不使用的时候需要调用recyle回收内存。 1velocityTracker.recycle(); GestureDetector手势检测，用于辅助检测用户的单击，滑动，长按，双击等行为。 1234567// 创建GestureDetector对象GestureDetector gestureDetector = new GestureDetector(getContext(), mOnGestureListener);// 设置长按屏幕后可以拖动gestureDetector.setIsLongpressEnabled(false);// 接管事件boolean b = gestureDetector.onTouchEvent(event); OnGestureListener和OnDoubleTapListener中的方法介绍： 实际开发中，如果只是监听滑动相关的，建议在onTouchEvent中实现。如果要监听双击行为就使用GestureDetector。 Scroller用于实现View的弹性滑动。 Scroller 让View在一定时间内完成连续的滑动。Scrller本身无法让View弹性滑动，需要和View的computeScroll方法配合使用才能共同使用。 Scroller只能是父View使用，来滑动子View。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ViewA extends LinearLayout &#123; private Scroller mScroller; public ViewA(Context context) &#123; super(context); init(context); &#125; public ViewA(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ViewA(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public ViewA(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(context); &#125; private void init(Context context) &#123; mScroller = new Scroller(context); &#125; public void smoothScrollTo(int destX, int destY) &#123; int scrollX = getScrollX(); int scrollY = getScrollY(); int deltaX = destX - scrollX; int deltaY = destY - scrollY; // (scrollX,scrollY) 是view左上角的初始坐标。dx,dy是位移量，x正数左移动。y正数上移动 mScroller.startScroll(scrollX, scrollY, -deltaX, -deltaY, 1000); invalidate(); &#125; @Override public void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125;&#125; View 的滑动通过三种方式可以实现View的滑动： 第一种是通过View本身提供的scrollTo/scrollBy方法来实现滑动； 第二种是通过动画给View施加平移效果来实现滑动； 第三种是通过改变View的LayoutParams使得View重新布局从而实现滑动。 使用scrollTo/scrollBy1234567891011121314151617181920212223242526272829303132/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125;/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; mScrollX 和 mScrollY 的改变规则： 在滑动的过程中，mScrollX 的值总是等于View左边缘和View内容左边缘的水平距离。mScrollY的值总是等于View上边缘和View内容上边缘在竖直方向的距离。 设原来View左上角的坐标为(a,b),移动后View内容的左上角坐标为(a’,b’),则：12mScrollX = a - a'mScrollY = b - b' 如果mScrollX&gt;0,View的内容往左边移动了。反之右移了。如果mScrollY&gt;0,View的内容往上移动了，反之就下移了。 mScrollX和mScrollY的变换规律示意: 只能改变View内容的位置而不能改变view在布局中的位置。 使用动画使用属性动画。 改变布局参数 改变LayoutParams。比如右移一个view 10dp，只需要设置它的marginLeft为10dp。 放置一个宽度为0的空view，当我们需要向右移动Button时，只需要重新设置空View的宽度即可，当空View的宽度增大时（假设Button的父容器是水平方向的LinearLayout），Button就自动被挤向右边，即实现了向右平移的效果。 各种滑动方式对比scrollTo/scrollBy 只能滑动View的内容，不能滑动View本身。 动画只能3.0以上使用属性动画，3.0以下使用View动画不能改变本身的属性，动画有一个优点，它可以实现比较复杂的效果。 scrollTo/scrollBy：操作简单，适合对View内容的滑动； 动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果； 改变布局参数：操作稍微复杂，适用于有交互的View。 跟手滑动的例子实现一个跟手滑动的效果，这是一个自定义View，拖动它可以让它在整个屏幕上随意滑动。 实现View的onTouchEvent方法在里面处理ACTION_MOVE事件。 1234567891011121314151617181920212223242526272829@Override public boolean onTouchEvent(MotionEvent event) &#123; float rawX = event.getRawX(); float rawY = event.getRawY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: float deltaX = rawX - mLastX; float deltaY = rawY - mLastY; // 移动后的位移改变量 float translationX = getTranslationX() + deltaX; float translationY = getTranslationY() + deltaY; // setTranslationX setTranslationY, 改变translationX，Y 的值来改变View的位置 setTranslationX(translationX); setTranslationY(translationY); Log.d(TAG,\"move,deltaX:\" + deltaX + \" deltaY:\" + deltaY); break; case MotionEvent.ACTION_UP: break; default: break; &#125; mLastX = rawX; mLastY = rawY; return true; &#125; 弹性滑动主要思想：将一个大的滑动分成很多个小的滑动。实现方式有多种： Scroller Handler#PostDelayed Thread#sleep Scroller当调用Scroller#startScroll()时，内部只是对一些变量进行赋值。 startX 滑动的起点x坐标 startY 滑动的起点y坐标 dx 滑动的x方向距离。正数View就往左移动，负数往右移动 dy 滑动的y方向距离。正数View就往上移动，负数往下移动12345678910111213public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; mMode = SCROLL_MODE; mFinished = false; mDuration = duration; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; mFinalX = startX + dx; mFinalY = startY + dy; mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float) mDuration; &#125; 1234567891011121314151617public void smoothScrollTo(int destX, int destY) &#123; int scrollX = getScrollX(); int scrollY = getScrollY(); int deltaX = destX - scrollX; int deltaY = destY - scrollY; // (scrollX,scrollY) 是view左上角的初始坐标。dx,dy是位移量，x正数左移动。y正数上移动 mScroller.startScroll(scrollX, scrollY, -deltaX, -deltaY, 1000); invalidate(); &#125; @Override public void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; &#125; 只调用startScroll方法无法完成滑动，因为他只是赋值而已。在调用startScroll后需要调用invalidate()重绘。父布局会调用View#draw(Canvas canvas, ViewGroup parent, long drawingTime)这个方法中会调用View#computeScroll();。 复写computeScroll()，computeScrollOffset()返回true代表滑动还未结束，就需要用scrollTo滑动View。然后调用 postInvalidate()继续重绘，这样形成一个递归，直到computeScrollOffset()返回false代表滑动完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Call this when you want to know the new location. If it returns true, * the animation is not yet finished. */ public boolean computeScrollOffset() &#123; if (mFinished) &#123; // 滑动完成直接返回false。 return false; &#125; // 已经滑动的时间 int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); // 如果小于mDuration代表还在滑动 if (timePassed &lt; mDuration) &#123; // 判断2种滑动模式 switch (mMode) &#123; case SCROLL_MODE: final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); break; case FLING_MODE: final float t = (float) timePassed / mDuration; final int index = (int) (NB_SAMPLES * t); float distanceCoef = 1.f; float velocityCoef = 0.f; if (index &lt; NB_SAMPLES) &#123; final float t_inf = (float) index / NB_SAMPLES; final float t_sup = (float) (index + 1) / NB_SAMPLES; final float d_inf = SPLINE_POSITION[index]; final float d_sup = SPLINE_POSITION[index + 1]; velocityCoef = (d_sup - d_inf) / (t_sup - t_inf); distanceCoef = d_inf + (t - t_inf) * velocityCoef; &#125; mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f; mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX)); // Pin to mMinX &lt;= mCurrX &lt;= mMaxX mCurrX = Math.min(mCurrX, mMaxX); mCurrX = Math.max(mCurrX, mMinX); mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY)); // Pin to mMinY &lt;= mCurrY &lt;= mMaxY mCurrY = Math.min(mCurrY, mMaxY); mCurrY = Math.max(mCurrY, mMinY); if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123; mFinished = true; &#125; break; &#125; &#125; else &#123; mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; 动画延迟策略View的事件分发机制 3个重要的方法：1234567891011121314151617// 进行事件的分发，如果事件能够传递给当前的view，此方法一定会被调用。返回的boolean值受到当前View的// onTouchEvent()和下级view的dispatchTouchEvent()的影响，true表示消费了事件，false表示不消费。@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; return super.dispatchTouchEvent(ev);&#125;// 在dispatchTouchEvent()中被调用。用来判断是否拦截事件，如果拦截了，同一事件序列不会再调用此方法。// 返回true为拦截该事件，false为不拦截。@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return super.onInterceptTouchEvent(ev);&#125;// 在dispatchTouchEvent()中被调用。用来处理点击事件，返回true为消费当前事件，false为不消费。如果不// 消费，在同一事件序列中，该View无法再次收到事件。@Override public boolean onTouchEvent(MotionEvent event) &#123; return super.onTouchEvent(event);&#125; 伪代码：1234567891011// 点击事件产生后首先会传递给根ViewGroup，它的dispatchTouchEvent()被调用public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; // 如果它拦截了事件，由onTouchEvent()来处理是否消费，否则交给子类。 if (onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; onTouchListener1234567891011121314151617/** * Interface definition for a callback to be invoked when a touch event is * dispatched to this view. The callback will be invoked before the touch * event is given to the view. */public interface OnTouchListener &#123; /** * Called when a touch event is dispatched to a view. This allows listeners to * get a chance to respond before the target view. * * @param v The view the touch event has been dispatched to. * @param event The MotionEvent object containing full information about * the event. * @return True if the listener has consumed the event, false otherwise. */ boolean onTouch(View v, MotionEvent event);&#125; 如果一个View设置了onTouchListenr，那么onTouchListenr的onTouch方法会被回调。返回true表示onTouchListenr消耗了这个事件，onTouchEvent()不会被调用。在onTouchEvent方法中，如果view设置了OnClickListenr, 那么onClik()方法会被回调。 优先级：OnTouchListener &gt; onTouchEvent &gt; OnClickListener 事件传递过程Activity -&gt; Window -&gt; View。顶级View接收到事件后就会按照事件分发机制去分发事件。 如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent()会被执行。依次类推，都不处理的话最后会返回到Activity的onTouchEvent()处理。 Activity#onTouchEvent(MotionEvent event)123456789101112131415161718/** * Called when a touch screen event was not handled by any of the views * under it. This is most useful to process touch events that happen * outside of your window bounds, where there is no view to receive it. * * @param event The touch screen event being processed. * * @return Return true if you have consumed the event, false if you haven't. * The default implementation always returns false. */public boolean onTouchEvent(MotionEvent event) &#123; if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false;&#125; 一些结论 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。 正常情况下，一个事件序列只能被一个View拦截且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。 某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onIn-terceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。 某个View一旦开始处理事件，如果它不消耗AC-TION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了，这就好比上级交给程序员一件事，如果这件事没有处理好，短期内上级就不敢再把事情交给这个程序员做了，二者是类似的道理。 如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。 ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouch-Event方法默认返回false。 View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable 和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。 View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。 onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。 事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowIn-terceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 源码解析Activity对点击事件的分发过程 Activty#dispatchTouchEvent(MotionEvent ev)1234567891011121314151617181920/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; // 如果window处理了就返回true。 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; Window#superDispatchTouchEvent1234567/** * Used by custom windows, such as Dialog, to pass the touch screen event * further down the view hierarchy. Application developers should * not need to implement or call this. * */ public abstract boolean superDispatchTouchEvent(MotionEvent event); Window是一个抽象类，这个方法也是抽象方法，得去找它的实现类。 12345678910/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */ 源码中说明了唯一的实现类就是android.view.PhoneWindow android.view.PhoneWindow#superDispatchTouchEvent123456789101112131415@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125;// This is the top-level view of the window, containing the window decor.private DecorView mDecor; @Overridepublic final View getDecorView() &#123; if (mDecor == null || mForceDecorInstall) &#123; installDecor(); &#125; return mDecor;&#125; Window将事件交给了DecorView。 1public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks 利用 AS 的Layout Inspector 检查Activity的视图： 我们setContentView()就是把View设置在ContentFrameLayout中。 1234// id为android.R.id.content的View就是 android.support.v7.widget.ContentFrameLayoutView contentView = ((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 目前事件传到DecorView，由于DecorView继承自FrameLayout，也是也一个View。所以会把事件分发下去。 顶级View的分发ViewGroup的拦截ViewGroup#dispatchTouchEvent 检查拦截的逻辑：12345678910111213141516171819202122232425262728// Check for interception. final boolean intercepted; // 满足事件为MotionEvent.ACTION_DOWN或者mFirstTouchTarget不为空时就判断是否需要拦截， // 否则直接拦截。DOWN事件之后的就都会拦截，不会走onInterceptTouchEvent方法。 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; mFirstTouchTarget != null是什么意思？ 123456789101112131415161718192021222324252627282930313233 // First touch target in the linked list of touch targets. private TouchTarget mFirstTouchTarget; ``` 当事件由ViewGroup的子元素成功处理时，`mFirstTouchTarget`被赋值指向子元素。 当ViewGroup不拦截事件，由子类消费事件时，`mFirstTouchTarget != null`。 当ViewGroup拦截事件，`mFristTouchTarget == null`。有一种特殊情况： 通过`requestDisallowInterceptTouchEvent`设置`FLAG_DISAL-LOW_INTERCEPT`标记位。一般用于子View中。 设置这个标记后，ViewGroup只能拦截`ACTION_DOWN`事件。如果是`ACTION_DOWN`就会重置`FLAG_DISALLOW_INTERCEPT`这个标记位，将导致子View中设置的这个标记位无效。```java // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; /** * Resets all touch state in preparation for a new cycle. */ private void resetTouchState() &#123; clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE; &#125; 总结： ViewGroup决定拦截事件后，后续的事件都会交给他处理，不会调用onInterceptTouchEvent()。onInterceptTouchEvent不是每次事件都会被调用的，如果我们想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup。 当子View设置FLAG_DISALLOW_INTERCEPT标记，父View不再拦截事件。FLAG_DISALLOW_INTERCEPT标记位的作用给我们提供了一个思路，当面对滑动冲突时，我们可以是不是考虑用这种方法去解决问题？ ViewGroup不拦截事件时，事件的分发过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final int childrenCount = mChildrenCount;if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; // 遍历所有的子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. // 不能得到焦点就跳到下一个循环 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; // 点击事件的坐标没有落在子元素内或者没有在播放动画，就跳到下一个 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 如果子View.dispatchTouchEvent返回true if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //mFirst-TouchTarget就会被赋值同时跳出for循环 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear();&#125; ViewGroup#dispatchTransformedTouchEvent123456if (child == null) &#123; // 子类为空就转到View的dispatchTouchEvent handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; mFirstTouchTarget 的赋值过程ViewGroup#addTouchTarget1234567891011/** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); // 把新的target插到链表的最前面。 target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 内部是一种单链表结构。 遍历所有的子元素后事件都没有被合适地处理 第一种是ViewGroup没有子元素； 第二种是子元素处理了点击事件，但是在dispatchTouchEvent中返回了false，这一般是因为子元素在onTouchEvent中返回了false。 12345if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; View对点击事件的处理过程分发dispatchTouchEventView#dispatchTouchEvent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */public boolean dispatchTouchEvent(MotionEvent event) &#123; boolean result = false; // .... if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 首先判断有没有设置OnTouchListener, // 如果mOnTouchListener.onTouch(this, event)返回true，那么onTouchEvent()不会被调用 if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; // .... // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result;&#125; 首先会判断有没有设置On-TouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，这样做的好处是方便在外界处理点击事件。 onTouchEventView#onTouchEvent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); // View不可用时 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; // 点击事件消耗了，但是不可用 if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; // 如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; // 执行点击 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: // ... break; case MotionEvent.ACTION_CANCEL: // ... break; case MotionEvent.ACTION_MOVE: // ... break; &#125; return true; &#125; return false; &#125; View#performClick12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 只要View的CLICKABLE``和LONG_CLICKABLE或者CONTEXT_CLICKABLE有一个为true，那么它就会消耗这个事件，即onTouchEvent方法返回true，不管它是不是DISABLE状态。UP的时候会执行performClick()在里面调用mOnClickListener回调的onClick方法。 View的LONG_CLICKABLE和CLICKABLELONG_CLICKABLE属性默认为false。而CLICKABLE属性是否为false和具体的View有关。 设置setOnClickListener/setOnLongClickListener时会自动把标记设置为true。 12345678910111213141516171819202122232425262728293031/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; /** * Register a callback to be invoked when this view is clicked and held. If this view is not * long clickable, it becomes long clickable. * * @param l The callback that will run * * @see #setLongClickable(boolean) */public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l;&#125; View的滑动冲突常见冲突 外部滑动方向和内部滑动方向不一致； 外部滑动方法和内部滑动方向一致 1和2的嵌套 场景1ViewPager的内容是ListView, ViewPager内部已经自动做了滑动处理。 如果是ScrollView，就必须手动处理。否则内外两层只有1个能滑动。 还有外部是上下滑动，内部是横向滑动，属于同一类。 场景2ViewPager中一个左右滑动的ScrollView，我滑动ScrollView不希望切换Viewpager，滑动ScrollView以外的屏幕才切换。 场景31 和 2的叠加， 需要分别处理。 处理规则 场景1： 左右滑动时，让父View拦截点击事件，上下滑动时，让子View拦截事件。根据滑动的距离，角度，速度等判断是水平滑动还是竖直滑动。 场景2 比较特殊，比如ScrollView内部有一个ListView，ListView中的内容滑动到顶部和底部时，响应外部ScrollView的滑动，否则就自己处理上下滑动。 场景3 具体根据业务来决定规则。 解决方式外部拦截法所有事件都经过父View来处理，父View需要自己处理就拦截，不需要就分发给子View。需要重写父View的onInterceptTouchEvent，在内部做相应的拦截。伪代码： 1234567891011121314151617181920212223242526272829303132public boolean onInterceptTouchEvent(MotionEvent ev)&#123; boolean intercepted = false; float x = event.getX(); float y = event.getY(); switch (ev.getAction())&#123; case MotionEvent.ACTION_DOWN: // 这里不能拦截，一旦拦截，后续的事件都会被拦截。 intercepted = false; break; case MotionEvent.ACTION_MOVE: if (父容器需要点击事件)&#123; intercepted = true; &#125;else&#123; intercepted = false; &#125; break; case MotionEvent.ACTION_UP: // 必须返回false，给子类处理。 // 如果返回true，子类无法收到点击事件。 // 父View如果拦截MOVE事件，后续的事件都会自动拦截。 intercepted = false; break; default: break; &#125; mLastX = x; mLastY = y; return intercepted;&#125; 内部拦截法将所有的事件都分发给子View处理，子View需要就处理，不需要就给父View处理。需要配合requestDisallowInterceptTouchEvent配合使用。重写子View的dispatchTouchEvent。伪代码： 12345678910111213141516171819202122232425262728@Override public boolean dispatchTouchEvent(MotionEvent event) &#123; float x = event.getX(); float y = event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 设置不拦截 mViewGroup.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: if (mViewGroup.isNeedEvent())&#123; mViewGroup.requestDisallowInterceptTouchEvent(false); &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event); &#125; 父View需要设置默认拦截除了DOWN事件以外的事件。 ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位的控制，所以一旦父容器拦截AC-TION_DOWN事件，那么所有的事件都无法传递到子元素中去。123@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return ev.getAction() != MotionEvent.ACTION_DOWN;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Retrofit 源码阅读笔记","slug":"deepInRetrofit","date":"2017-05-16T13:57:00.000Z","updated":"2017-05-16T03:48:07.000Z","comments":true,"path":"2017/05/16/deepInRetrofit/","link":"","permalink":"https://luwenjie.me/2017/05/16/deepInRetrofit/","excerpt":"前言 Retrofit 是现在 Android 主流的网络请求库，对比 Volley 它解耦更加彻底，使用更加方便，而且支持 RxJava。具体的区别的可以看看这篇文章——OkHttp, Retrofit, Volley应该选择哪一个？。 Retrofit 中文可以翻译成 在原有基础上改进。它的底层基于 OkHttp。 Retrofit 的精简流程图，图片来自Stay：","text":"前言 Retrofit 是现在 Android 主流的网络请求库，对比 Volley 它解耦更加彻底，使用更加方便，而且支持 RxJava。具体的区别的可以看看这篇文章——OkHttp, Retrofit, Volley应该选择哪一个？。 Retrofit 中文可以翻译成 在原有基础上改进。它的底层基于 OkHttp。 Retrofit 的精简流程图，图片来自Stay： Retrofit 中使用了大量设计模式，分析源码之前最好先熟悉一下这些模式。 建造者模式 工厂模式 外观模式 策略模式 适配器模式 装饰模式 代理模式及 Java 动态代理 还涉及一些基础的 Java 注解的知识，建议先打好基础再分析源码。 Retrofit的类的结构 上层有4个抽象接口，有默认的实现类。核心服务类是ServiceMethod。Platform判断Android，Java平台。 Call123456789101112131415161718192021222324252627282930313233343536373839404142/** * 这是一个Retrofit方法给服务器发送一个request，返回一个response的调用。 * 每个Call生产一组HTTP request和response。对于同一个完全一样请求，实现 * clone方法来创建多个call，这个可以用于轮询和错误重试的场景。 * * Calls 同步执行的时候使用 execute(), 异步执行使用 enqueue()。无论是 * 同步还是异步都可以在请求的时候使用 cancel() 随时被取消。正在写入request或者读取response的Call可能会引起IOException。 * * * @param &lt;T&gt; 请求成功时返回的 response body 类型 */public interface Call&lt;T&gt; extends Cloneable &#123; // 同步发起请求返回response Response&lt;T&gt; execute() throws IOException; // 异步发起请求，结果返回给回调 void enqueue(Callback&lt;T&gt; callback); // 如果call已经调用了execute()或者enqueue()就返回true。不允许一个call重复请求。 boolean isExecuted(); // 取消正在执行中的请求，如果call还没开始执行请求，就不做任何处理。 void cancel(); // 是否取消了请求 boolean isCanceled(); // 创建一个新的和当前完全一样的call Call&lt;T&gt; clone(); // 原始的HTTP请求 Request request();&#125; CallAdapter用于RxJava的转化。123456789101112131415161718192021public interface CallAdapter&lt;R, T&gt; &#123; // 返回解析成java对象的response的类型。 Type responseType(); T adapt(Call&lt;R&gt; call); // 抽象工厂类 abstract class Factory &#123; public abstract CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123; return Utils.getParameterUpperBound(index, type); &#125; protected static Class&lt;?&gt; getRawType(Type type) &#123; return Utils.getRawType(type); &#125; &#125;&#125; Callback123456public interface Callback&lt;T&gt; &#123; void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response); void onFailure(Call&lt;T&gt; call, Throwable t);&#125; Converter1234567891011121314151617181920212223public interface Converter&lt;F, T&gt; &#123; // 实体类和HTTP的RequestBody和ResponseBody的互相转换 T convert(F value) throws IOException; // 抽象工厂 abstract class Factory &#123; public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; return null; &#125; public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; &#125;&#125; 正常请求网络的套路如果我们自己写一个网络请求模块一般是这样的套路： build request 参数，加入到请求队列中 在子线程轮询执行 得到服务器数据后，回调给上层 Retrofit 不外乎也是这种套路，那么它到底有什么精妙的地方呢? 举个栗子先看一个正常 Retrofit 请求的例子：1234567891011121314151617181920212223242526Retrofit build = new Retrofit.Builder().baseUrl(ServiceApi.BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); ServiceApi serviceApi = build.create(ServiceApi.class); serviceApi.getHistoryDate().enqueue(new Callback&lt;String&gt;() &#123; @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) &#123; Log.d(TAG, \"onResponse- \" + response.body()); &#125; @Override public void onFailure(Call&lt;String&gt; call, Throwable t) &#123; Log.d(TAG, \"onFailure- \" + t.getMessage()); &#125; &#125;); /** * API 来自 gank.io，感谢 @代码家 */interface ServiceApi &#123; String BASE_URL = \"http://gank.io/api/\"; /** * 获取某一天的数据 */ @GET(\"day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;\") Call&lt;String&gt; getDataOnSomeday( @Path(\"year\") String year, @Path(\"month\") String month, @Path(\"day\") String day);&#125; 我们通过调用 serviceApi.getHistoryDate().enqueue(callback) 请求数据并在回调中处理数据。就从这行代码作为切入点，看看发出请求的时候到底内部发生了啥？debug serviceApi.getHistoryDate() 这行代码我发现，运行至此的时候调用了动态代理，代码走到了下面的 create(final Class&lt;T&gt; service) 中的 InvocationHandler() 中，回调了 invoke()。 我们来仔细分析一下这个函数。 123456789101112131415161718192021222324252627282930313233343536373839/** * 创建由 service 定义的 API 的实现。 * return 类型还是为 T 的代理对象 */public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; // 检查 service 是否合法，必须是接口且只有 1 个接口， Utils.validateServiceInterface(service); // 创建的时候如果设置验证方法就先验证，否则只在动态代理里面验证。 if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125;``` 很明显这是一个 Java 动态代理。这个方法在 `ServiceApi serviceApi = build.create(ServiceApi.class);` 调用，返回的是一个代理对象。 在`invoke(Object proxy, Method method, Object... args)`中，Retrofit 只关心 method 和 args 两个参数。核心代码是这 3 句：```javaServiceMethod serviceMethod = loadServiceMethod(method);OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.callAdapter.adapt(okHttpCall); ServcieMethodServiceMethod就像是一个中央处理器，传入Retrofit对象和Method对象，调用各个接口和解析器，最终生成一个Request，包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等。最后返回一个Call对象，Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。 使用Java动态代理的目的就要拦截被调用的Java方法，然后解析这个Java方法的注解，最后生成Request由OkHttp发送。 先看 loadServiceMethod(method)，从这里面得到一个 ServiceMethod12345678910111213ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // 先从缓存中取 result = serviceMethodCache.get(method); if (result == null) &#123; // 如果没有就新建，然后加入缓存 result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result; &#125; build方法里面创建了CallAdapter和Converter。处理注解，将其转化成OkHttp Call。 12345678910111213141516171819202122232425262728293031/** * 创建 CallAdapter，创建 Converter，解析注释 * ServiceMethod 的作用是将接口方法的调用适配为 HTTP Call * return ServiceMethod 对象 */public ServiceMethod build() &#123; // 创建callAdapter callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); // 创建Converter responseConverter = createResponseConverter(); // 遍历，解析方法注释 for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; // 参数里的注解的个数 int parameterCount = parameterAnnotationsArray.length; // 创建对应的 parameterHandlers数组。将每个参数的注解解析成parameterHandler对象存入数组。 parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; return new ServiceMethod&lt;&gt;(this); &#125; 这里的parameterHandlers 负责解析API定义时每个方法的参数，并在构造HTTP请求时设置参数。 解析方法注释123456789private void parseMethodAnnotation(Annotation annotation) &#123; if (annotation instanceof DELETE) &#123; parseHttpMethodAndPath(\"DELETE\", ((DELETE) annotation).value(), false); &#125; else if (annotation instanceof GET) &#123; parseHttpMethodAndPath(\"GET\", ((GET) annotation).value(), false); &#125; // ...省略代码&#125; 123456789101112131415161718192021222324252627282930 private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123; this.httpMethod = httpMethod; this.hasBody = hasBody; if (value.isEmpty()) &#123; return; &#125; // Get the relative URL path and existing query string, if present. int question = value.indexOf('?'); if (question != -1 &amp;&amp; question &lt; value.length() - 1) &#123; // Ensure the query string does not have any named parameters. String queryParams = value.substring(question + 1); Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams); &#125; this.relativeUrl = value; this.relativeUrlParamNames = parsePathParameters(value);&#125;static Set&lt;String&gt; parsePathParameters(String path) &#123; Matcher m = PARAM_URL_REGEX.matcher(path); Set&lt;String&gt; patterns = new LinkedHashSet&lt;&gt;(); while (m.find()) &#123; patterns.add(m.group(1)); &#125; return patterns;&#125; parameterHandlers 每个参数都会有一个 ParameterHandler，由 ServiceMethod#parseParameter 方法负责创建，其主要内容就是解析每个参数使用的注解类型（诸如 Path，Query，Field 等），对每种类型进行单独的处理。构造 HTTP 请求时，我们传递的参数都是字符串，那 Retrofit 是如何把我们传递的各种参数都转化为 String 的呢？还是由 Retrofit 类提供 converter！Converter.Factory 除了提供上一小节提到的 responseBodyConverter，还提供 requestBodyConverter 和 stringConverter，API 方法中除了 @Body 和 @Part 类型的参数，都利用 stringConverter 进行转换，而 @Body 和 @Part 类型的参数则利用 requestBodyConverter 进行转换。 CallAdapter123 // #ServiceMethod.javathis.callFactory = builder.retrofit.callFactory(); CallAdapter由retrofit提供，我们可以自己指定，默认是okhttp3.OkHttpClient。 创建callAdapter由retrofit完成。12345678private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);&#125; // # Retrofit.java public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123; return nextCallAdapter(null, returnType, annotations); &#125; 最终走到nextCallAdapter()，通过CallAdapter.Factory来创造。1234567891011121314public CallAdapter&lt;?, ?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123; // ...省略多若干码 // 去除skipPast这个过去的工厂，Retrofit默认传的是null。 int start = adapterFactories.indexOf(skipPast) + 1; // 遍历取出第一个工厂，获得adapter。 for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123; CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) &#123; return adapter; &#125; &#125;&#125; ResponseConverter和callAdapter一样，也是由Retrofit创建的。通过遍历 Converter.Factory 列表，看看有没有工厂能够提供需要的 responseBodyConverter。工厂列表同样可以在构造 Retrofit 对象时进行添加。 OkHttpCallOkHttpCall实现了Call接口。 okHttpCall 关键的部分是: 123456789101112131415161718192021222324252627private okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException(\"Call.Factory returned null.\"); &#125; return call; &#125; // ServiceMethod.java # toRequest() /** Builds an HTTP request from method arguments. */ Request toRequest(Object... args) throws IOException &#123; RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); @SuppressWarnings(\"unchecked\") // It is an error to invoke a method with the wrong arg types. ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; // 省略部分检查代码 for (int p = 0; p &lt; argumentCount; p++) &#123; handlers[p].apply(requestBuilder, args[p]); &#125; return requestBuilder.build(); &#125; 这里由serviceMethod创建request，之前的ParameterHandler这里就用到了，这里把参数传进去一起组成完整request。并且由serviceMethod里的callFactory创建一个Call，默认就是OkHttpCall。 调用execute()执行同步请求： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; // 省略判断代码... call = rawCall = createRawCall(); // 省略判断代码... // 最终调用 parseResponse 解析返回的结果 return parseResponse(call.execute()); &#125; Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; // 这里调用serviceMethod中的方法用对应的ConvertFactory转换 T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125; 参考资料 Retrofit源码分析 - 有心课堂 Retrofit分析-漂亮的解耦套路 Retrofit 官方文档 「Android技术汇」Retrofit2 源码解析和案例说明 深入浅出 Retrofit，这么牛逼的框架你们还不来看看？ 拆轮子系列：拆 Retrofit","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"https://luwenjie.me/tags/Retrofit/"}]},{"title":"工厂方法模式","slug":"工厂方法模式 ","date":"2017-05-15T02:56:00.000Z","updated":"2017-05-15T03:05:17.000Z","comments":true,"path":"2017/05/15/工厂方法模式 /","link":"","permalink":"https://luwenjie.me/2017/05/15/工厂方法模式 /","excerpt":"东汉《风俗通》记录了一则神话故事：“开天辟地，未有人民，女娲搏黄土做人”，讲述的内容就是大家非常熟悉的女娲造人的故事。开天辟地之初，大地上并没有生物，只有苍茫大地，纯粹而洁净的自然环境，寂静而又寂寞，于是女娲决定创造一个新物种（即人类）来增加世界的繁荣，怎么制造呢？","text":"东汉《风俗通》记录了一则神话故事：“开天辟地，未有人民，女娲搏黄土做人”，讲述的内容就是大家非常熟悉的女娲造人的故事。开天辟地之初，大地上并没有生物，只有苍茫大地，纯粹而洁净的自然环境，寂静而又寂寞，于是女娲决定创造一个新物种（即人类）来增加世界的繁荣，怎么制造呢？ 例子：女娲造人 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 人的抽象接口public interface Human &#123; // 肤色 void getColor(); // 说话 void talk();&#125;// 抽象工厂类public class HumanFactory extends AbstractHumanFactory &#123; static final AbstractHumanFactory INSTANCE = new HumanFactory(); @Override @SuppressWarnings(\"unchecked\") public &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) &#123; Human human = null; try &#123; human = c.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return (T) human; &#125;&#125;// 白人实现类public class WhiteHuman implements Human &#123; public void getColor() &#123; System.out.println(\"白色人种的皮肤颜色是白色的！\"); &#125; public void talk() &#123; System.out.println(\"白色人种会说话，一般都是但是单字节。\"); &#125;&#125;// 黄种人实现类public class YellowHuman implements Human &#123; public void getColor() &#123; System.out.println(\"黄色人种的皮肤颜色是黄色的！\"); &#125; public void talk() &#123; System.out.println(\"黄色人种会说话，一般说的都是双字节。\"); &#125;&#125;// 黑人实现类public class BlackHuman implements Human &#123; @Override public void getColor() &#123; Utils.print(\"黑色人种的皮肤颜色是黑色的！\"); &#125; @Override public void talk() &#123; System.out.println(\"黑人会说话，一般人听不懂。\"); &#125;&#125;// 造人工厂实现类public class HumanFactory extends AbstractHumanFactory &#123; static final AbstractHumanFactory INSTANCE = new HumanFactory(); @Override @SuppressWarnings(\"unchecked\") public &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) &#123; Human human = null; try &#123; human = c.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; return (T) human; &#125;&#125;// 分别用工厂创建3种人public class NvWaDemo &#123; public static void main(String[] args)&#123; BlackHuman human = HumanFactory.INSTANCE.createHuman(BlackHuman.class); WhiteHuman human1 = HumanFactory.INSTANCE.createHuman(WhiteHuman.class); YellowHuman human2 = HumanFactory.INSTANCE.createHuman(YellowHuman.class); human.getColor(); human.talk(); human1.getColor(); human1.talk(); human2.getColor(); human2.talk(); &#125;&#125;// 控制台输出---------------黑色人种的皮肤颜色是黑色的！黑人会说话，一般人听不懂。白色人种的皮肤颜色是白色的！白色人种会说话，一般都是但是单字节。黄色人种的皮肤颜色是黄色的！黄色人种会说话，一般说的都是双字节。------------- 定义 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 通用类图： 抽象产品类 Product 负责定义产品的共性。Creator为抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。 应用良好的封装性，代码结构清晰。扩展性强。屏蔽了产品类，只需要知道产品类的接口，不需要关注其具体实现。 扩展简单工厂模式一个模块仅需要一个工厂类，就没有必要抽象工厂类。 多个工厂类做一个比较复杂的模块时，会需要初始化多个工厂。 替代单例模式通过工厂方法模式也可以在内存中只生产一个对象。 1234567891011121314151617181920212223242526272829303132333435// 单例类public class Singleton &#123; private Singleton()&#123; &#125; private void doSomething()&#123; &#125;&#125;// 单例工厂public class SingletonFactory &#123; private static Singleton singleton; static &#123; try &#123; // 获得无参构造 Constructor&lt;Singleton&gt; declaredConstructor = Singleton.class.getDeclaredConstructor(); // 设置无参构造是可以访问的 declaredConstructor.setAccessible(true); // 产生一个实例 singleton = declaredConstructor.newInstance(); &#125; catch (Exception e) &#123; // 处理异常 &#125; &#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 延迟初始化一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。 12345678910111213141516171819public class ProductFactory &#123; private static final Map&lt;String, Product&gt; prMap = new HashMap&lt;&gt;(); public static synchronized Product createProduct(String type) throws Exception &#123; Product product = null; if (prMap.containsKey(type)) &#123; product = prMap.get(type); &#125;else &#123; if (type.equals(\"product1\"))&#123; product = new Product1(); &#125;else &#123; product = new Product2(); &#125; &#125; return product; &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://luwenjie.me/tags/设计模式/"}]},{"title":"快速打包","slug":"快速打包","date":"2017-04-28T09:24:00.000Z","updated":"2017-04-28T09:24:44.000Z","comments":true,"path":"2017/04/28/快速打包/","link":"","permalink":"https://luwenjie.me/2017/04/28/快速打包/","excerpt":"原来使用umeng多渠道打包，配置productFlavors。打包速度实在太慢了。 目前快速打包的方案有下面几个： (图片来自Bugly，侵删)","text":"原来使用umeng多渠道打包，配置productFlavors。打包速度实在太慢了。 目前快速打包的方案有下面几个： (图片来自Bugly，侵删) 由于新版引入了V2签名，所以我选择使用ApkChannelPackage 这个工具。 接入过程看下面链接的文档就行。 执行多渠道打包 若没有通过Gradle Plugin的 productFlavors配置多渠道，那么通过以下TaskchannelDebug 、channelRelease分别负责生成Debug和Release的多渠道包。 例子： ./gradlew channelRelease 若是配置了productFlavors，那么对应的Task则是channelFlavorXDebug、channelFlavorXRelease，FlavorX表示在productFlavors中配置的渠道名称。 除此之外，如果是根据已有基础包生成多渠道包，那么对应的Task则是reBuildChannel 例子： ./gradlew channelZZRRelease 给umeng设置渠道号使用这种方式后就要手动给umeng设置一下渠道号了。1234MobclickAgent.UMAnalyticsConfig umAnalyticsConfig = new MobclickAgent.UMAnalyticsConfig(this, \"appkey\", ChannelReaderUtil.getChannel(App.getContext()));MobclickAgent.startWithConfigure(umAnalyticsConfig); 参考Android 新一代多渠道打包神器&amp;version=12020110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=osqliNw7NZr%2FkzVkQFkW1JhJxgxaGGmDh8Mp9VsM%2FhlVe0yLjm2kidJuYX%2FL%2FSbj) ApkChannelPackage ApkChannelPackage插件接入文档","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"Android开发艺术探索笔记-第1章 Activity的生命周期和启动模式","slug":"Android开发艺术探索笔记第1章","date":"2017-04-26T08:37:00.000Z","updated":"2017-07-20T10:46:48.000Z","comments":true,"path":"2017/04/26/Android开发艺术探索笔记第1章/","link":"","permalink":"https://luwenjie.me/2017/04/26/Android开发艺术探索笔记第1章/","excerpt":"本章主要介绍Activity相关的一些内容。Activity作为四大组件之首，是使用最为频繁的一种组件，中文直接翻译为“活动”，但是笔者认为这种翻译有些生硬，如果翻译成界面就会更好理解。正常情况下，除了Window、Dialog和Toast，我们能见到的界面的确只有Activity。Activity是如此重要，以至于本书开篇就不得不讲到它。当然，由于本书的定位为进阶书，所以不会介绍如何启动Activity这类入门知识，本章的侧重点是Activity在使用过程中的一些不容易搞清楚的概念，主要包括生命周期和启动模式以及IntentFilter的匹配规则分析。","text":"本章主要介绍Activity相关的一些内容。Activity作为四大组件之首，是使用最为频繁的一种组件，中文直接翻译为“活动”，但是笔者认为这种翻译有些生硬，如果翻译成界面就会更好理解。正常情况下，除了Window、Dialog和Toast，我们能见到的界面的确只有Activity。Activity是如此重要，以至于本书开篇就不得不讲到它。当然，由于本书的定位为进阶书，所以不会介绍如何启动Activity这类入门知识，本章的侧重点是Activity在使用过程中的一些不容易搞清楚的概念，主要包括生命周期和启动模式以及IntentFilter的匹配规则分析。 生命周期 正常情况onStart和onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同呢？onStart和onStop区分是否可见，onResume和onPause区分是否在前台。 假设当前Activity为A，如果这时用户打开一个新Activity B，那么B的onResume和A的onPause哪个先执行呢？执行顺序为：12345A-onPauseB-onCreateB-onStartB-onResumeA-onStop onPause()和onStop()不能做耗时的操作，尽量在onStop中做一些保存操作，使得下一个Activity尽快显示出来。 异常情况 情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建当系统配置发生改变后，Activity会被销毁，其onPause、onStop、onDestroy均会被调用。系统会调用onSaveInstanceState来保存当前Activity的状态。这个方法的调用时机是在onStop之前，它和onPause没有既定的时序关系，它既可能在on-Pause之前调用，也可能在onPause之后调用。需要强调的一点是，这个方法只会出现在Activity被异常终止的情况下，正常情况下系统不会回调这个方法。当Activity被重新创建后，系统会调用onRestoreInstanceState，并且把Activity销毁时on-SaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法。因此，我们可以通过onRestoreIn-stanceState和onCreate方法来判断Activity是否被重建了，如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState的调用时机在onStart之后。 如屏幕旋转会触发这种情况。 系统配置中有很多内容，如果当某项内容发生改变后，我们不想系统重新创建Activity，可以给Activity指定configChanges属性，然后我们自己在Activity的onConfigurationChanged方法中处理自己的逻辑。 情况2：资源内存不足导致低优先级的Activity被杀死Activity按照优先级从高到低，可以分为如下三种： 前台Activity——正在和用户交互的Activity，优先级最高。 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。 当系统内存不足时，系统就会按照上述优先级去杀死目标Activity所在的进程，并在后续通过onSaveInstanceState和onRestoreInstanceState来存储和恢复数数据。如果一个进程中没有四大组件在执行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件而独自运行在后台中，这样进程很容易被杀死。比较好的方法是将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死。 启动模式使用清单文件在清单文件中声明 Activity 时，您可以使用 元素的 launchMode 属性指定 Activity 应该如何与任务关联。 launchMode 属性指定有关应如何将 Activity 启动到任务中的指令。您可以分配给 launchMode 属性的启动模式共有四种： “standard”（默认模式） “singleTop” “singleTask” “singleInstance” 使用 Intent 标志 FLAG_ACTIVITY_NEW_TASK : 指定singleTask模式 FLAG_ACTIVITY_SINGLE_TOP : 指定singleTop启动模式 FLAG_ACTIVITY_CLEAR_TOP : 使其Activity之上的所有Activity都出栈。一般和 FLAG_ACTIVITY_NEW_TASK配合使用，如果Ativity实例已经存在，系统会调用他的onNewIntent。若和standard模式配合使用，那么它和它之上的所有Activity都要出栈，系统会创建新的实例放到栈顶。singleTask默认就有此标记的效果。 FLAG_ACTIVITY_EXCLUDE_FROM_RE-CENTS : 具有这个标记的Activity不会出现在历史Ac-tivity的列表中，等同于android:excludeFromRecents=&quot;true&quot;。 使用方法：intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK); 任务栈关联taskAffinity 与 allowTaskReparenting默认值是包名，需要和allowTaskReparenting或者singleTask配对使用。 当 taskAffinity 和 singleTask 配合使用时，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。 当 taskAffinity 和 allowTaskReparenting 配合使用时，如果allowTaskReparenting为true，应用A启动了应用B的Activty C，按Home键回到桌面，再单击B的桌面图标，显示的是Activity C，而不是显示B的主Activity，C从A的任务栈转移到了B的任务栈中。 实践 上图 B 启动 C ，情况会如何? 清单文件： 12345678910111213141516171819202122232425262728293031323334&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".ActivityC\" android:launchMode=\"singleTask\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".ActivityD\" android:launchMode=\"singleTask\" /&gt; &lt;activity android:name=\".ActivityA\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.task\" /&gt; &lt;activity android:name=\".ActivityB\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.task\" /&gt; &lt;/application&gt; 调用顺序 C-&gt;D-&gt;A-&gt;B-&gt;C 结果返回栈中是 A-&gt;B-&gt;C，D被直接出栈。 singleTask模式的Activity切换到栈顶会导致在它之上的栈内的Activity出栈。 IntentFilter 匹配规则启动Activity分为显示调用和隐式调用，隐式调用需要Intent去匹配IntentFilter中所设置的过滤信息。 例：1234567891011121314151617&lt;activity android:name=\"com.ryg.chapter_1.ThirdActivity\" android:configChanges=\"screenLayout\" android:label=\"@string/app_name\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.ryg.task1\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.ryg.charpter_1.c\"/&gt; &lt;action android:name=\"com.ryg.charpter_1.d\"/&gt; &lt;category android:name=\"com.ryg.category.c\"/&gt; &lt;category android:name=\"com.ryg.category.d\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"text/plain\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 只有一个Intent同时匹配action类别、cat-egory类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。 一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。 action 的匹配规则只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。 category 的匹配规则要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。 data 的匹配规则123456789&lt;data android:host=\"string\" android:mimeType=\"string\" android:path=\"string\" android:pathPattern=\"string\" android:pathPrefix=\"string\" android:port=\"string\" android:scheme=\"string\"/&gt; URI结构： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt; 例：content://com.example.project:200/folder/subfolder/etc http://www.baidu.com:80/search/info 参考Android开发艺术探索 Develop API Guides Intent 和 Intent 过滤器 任务和返回栈","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Android开发艺术探索","slug":"Android开发艺术探索","permalink":"https://luwenjie.me/tags/Android开发艺术探索/"}]},{"title":"Java的注解","slug":"Java的注解","date":"2017-04-24T03:17:00.000Z","updated":"2017-05-24T08:06:56.000Z","comments":true,"path":"2017/04/24/Java的注解/","link":"","permalink":"https://luwenjie.me/2017/04/24/Java的注解/","excerpt":"自Java5.0版本引入注解之后，它就成为了Java平台中非常重要的一部分。开发过程中，我们也时常在应用代码中会看到诸如@Override，@Deprecated这样的注解。在很多流行框架中也经常会看到注解的身影。例如Retrofit这样优秀的框架就基于注解巧妙的设计简化网络请求的过程。","text":"自Java5.0版本引入注解之后，它就成为了Java平台中非常重要的一部分。开发过程中，我们也时常在应用代码中会看到诸如@Override，@Deprecated这样的注解。在很多流行框架中也经常会看到注解的身影。例如Retrofit这样优秀的框架就基于注解巧妙的设计简化网络请求的过程。 元注解基于 JDK 1.8 。 java.lang.annotation 包下一共有 6 个元注解。 @Target @Retention @Documented @Inherited @Native @Repeatable @Target标注注解的修饰类型。例如 @Target 它是被用来修饰注解的， 这里就是 ANNOTATION_TYPE 注解类型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 @Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125;public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ // 修饰 class，interface，@interface，enum TYPE, /** Field declaration (includes enum constants) */ // 修饰成员变量，包括枚举中的变量 FIELD, /** Method declaration */ // 修饰方法 METHOD, /** Formal parameter declaration */ // 修饰参数 PARAMETER, /** Constructor declaration */ // 修饰构造方法 CONSTRUCTOR, /** Local variable declaration */ // 修饰局部变量 LOCAL_VARIABLE, /** Annotation type declaration */ // 修饰注解 ANNOTATION_TYPE, /** Package declaration */ // 修饰包 PACKAGE, /** * Type parameter declaration * 表示这个 Annotation 可以用在 Type 的声明式前 * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * 表示这个 Annotation 可以用在所有使用 Type 的地方（如：泛型，类型转换等） * @since 1.8 */ TYPE_USE&#125; @Retention 表示注解在哪个级别被保留，描述了注解在什么时候生效。 1234567891011121314151617181920212223242526272829303132333435363738 @Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();&#125;public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. * * 只在源码中生效，编译的时候会被编译器丢弃 */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. * * 注解被VM虚拟机记录在.class文件中，但是不会被保留在运行时，默认是这种行为 */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement * * 既保存在了.class文件中，也保留在了运行时，所以可以被反射读取。 */ RUNTIME&#125; @Documented用于标记文档，使其成为公共Api。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; @Inherited标记某个注解是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; @Native用于调用底层C或者C++12345678910111213141516171819202122@Documented@Target(ElementType.FIELD)@Retention(RetentionPolicy.SOURCE)public @interface Native &#123;&#125;``` ### @Repeatable java 1.8 新增的注解。是一个语法糖```java@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123; /** * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the * repeatable annotation type. * @return the containing annotation type */ Class&lt;? extends Annotation&gt; value();&#125; 例：12345678910111213141516171819202122232425262728293031323334353637383940414243public class AnnotationDemo &#123; public static void main(String[] args) &#123; Annotation[] annotations = RepeatAnn.class.getAnnotations(); System.out.println(annotations.length); //1 Arrays.stream(annotations).forEach(System.out::println); Annotation[] annotations2 = Annotations.class.getAnnotations(); System.out.println(annotations2.length);//1 Arrays.stream(annotations2).forEach(System.out::println); &#125; @Repeatable(value = Roles.class) public static @interface Role &#123; String name() default \"doctor\"; &#125; @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public static @interface Roles &#123; Role[] value(); &#125; @Role(name = \"who\") @Role(name = \"who2\") @Role(name = \"who3\") public static class RepeatAnn &#123; &#125; @Roles(&#123;@Role(name = \"doctor\"), @Role(name = \"who1\"), @Role(name = \"who2\"), @Role(name = \"who3\"), @Role(name = \"who4\"), @Role(name = \"who5\") &#125; ) public static class Annotations &#123; &#125;&#125; Java 内建注解@Override1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings123456789101112131415161718192021@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; /** * The set of warnings that are to be suppressed by the compiler in the * annotated element. Duplicate names are permitted. The second and * successive occurrences of a name are ignored. The presence of * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must * ignore any warning names they do not recognize. They are, however, * free to emit a warning if an annotation contains an unrecognized * warning name. * * &lt;p&gt; The string &#123;@code \"unchecked\"&#125; is used to suppress * unchecked warnings. Compiler vendors should document the * additional warning names they support in conjunction with this * annotation type. They are encouraged to cooperate to ensure * that the same names work across multiple compilers. * @return the set of warnings to be suppressed */ String[] value();&#125; 自定义注解定义注解格式：1public @interface 注解名 &#123;定义体&#125; 注解参数的可支持数据类型： 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String类型 Class类型 enum类型 Annotation类型 以上所有类型的数组 注解方法不能带有参数。可以用default指定默认值。 例：1234567@Target(PARAMETER)@Retention(RUNTIME)public @interface Part &#123; String value() default \"\"; String encoding() default \"binary\";&#125; 参考深入理解Java：注解（Annotation）自定义注解入门 Java 8 新特性：扩展注解（类型注解和重复注解） ——诺诺”涂鸦”记忆 Java 8 Annotation 新特性在软件质量和开发效率方面的提升 在 Windows 中实现 Java 本地方法","categories":[{"name":"Java","slug":"Java","permalink":"https://luwenjie.me/categories/Java/"}],"tags":[]},{"title":"Fragment的懒加载","slug":"Fragmnet的懒加载","date":"2017-04-21T10:15:00.000Z","updated":"2017-04-21T10:50:14.000Z","comments":true,"path":"2017/04/21/Fragmnet的懒加载/","link":"","permalink":"https://luwenjie.me/2017/04/21/Fragmnet的懒加载/","excerpt":"Fragment的懒加载有2种情况，一种ViewPager+Fragment配合使用的懒加载。一种是单纯只有Fragment的懒加载。我们结合源码来寻找解决方案。","text":"Fragment的懒加载有2种情况，一种ViewPager+Fragment配合使用的懒加载。一种是单纯只有Fragment的懒加载。我们结合源码来寻找解决方案。 Fragment的生命周期首先了解一下Fragment的生命周期。这里我们需要做懒加载的话关注一下初始化的时候它的生命周期就可以了，看看能不能再生命周期里面做一些手脚。 只有Fragment的懒加载一般首页都是像iOS那种底栏的设计UI。点击下方的按钮切换fragment，这时不需要使用ViewPager+Fragment来实现，只需要动态显示或者隐藏Fragment就行。 假设现在首页有A，B，C，D四个页面，点击按钮切换。在Activity初始化先把A页面添加进去，点击其他页面的时候再Add。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"MainActivity\"; final Fragment[] mFragments = new Fragment[4]; private int mCurrentPosition; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.act_main); findViewById(R.id.a_bt).setOnClickListener(this); findViewById(R.id.b_bt).setOnClickListener(this); findViewById(R.id.c_bt).setOnClickListener(this); findViewById(R.id.d_bt).setOnClickListener(this); mFragments[0] = FragmentA.newInstance(); getSupportFragmentManager().beginTransaction() .add(R.id.container, mFragments[0], createTag(mFragments[0])) .commit(); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.a_bt: switchFragment(0); break; case R.id.b_bt: switchFragment(1); break; case R.id.c_bt: switchFragment(2); break; case R.id.d_bt: switchFragment(3); break; &#125; &#125; /** * 切换Fragment * * @param toPosition 点击的position */ private void switchFragment(int toPosition) &#123; if (mCurrentPosition == toPosition) return; FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction(); if (mFragments[toPosition] == null) &#123; mFragments[toPosition] = newFragmentInstance(toPosition); &#125; if (!mFragments[toPosition].isAdded()) &#123; fragmentTransaction.add(R.id.container, mFragments[toPosition], createTag(mFragments[toPosition])); &#125; fragmentTransaction.hide(mFragments[mCurrentPosition]).show(mFragments[toPosition]).commit(); Log.d(TAG, mCurrentPosition + \"\"); mCurrentPosition = toPosition; &#125; private Fragment newFragmentInstance(int position) &#123; switch (position) &#123; case 0: return FragmentA.newInstance(); case 1: return FragmentB.newInstance(); case 2: return FragmentC.newInstance(); case 3: return FragmentD.newInstance(); &#125; return null; &#125; private String createTag(Fragment fragment) &#123; return fragment.getClass().getName(); &#125;&#125; ViewPager + Fragment懒加载一般是这样使用的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141 mViewPager.setAdapter(new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return mFragments[position]; &#125; @Override public int getCount() &#123; return mFragments.length; &#125; &#125;);``` 不难猜测fragment的处理都是在FragmentAdapter这个类里面，所以直接看这个类是如果处理的。### FragmentPagerAdapter源码走读源码其实很简单，是一个单独的类，我把它copy出来方便打印日志和写注释： ```javapublic abstract class FragmentPagerAdapter extends PagerAdapter &#123; private static final String TAG = \"FragmentPagerAdapter\"; private static final boolean DEBUG = true; private final FragmentManager mFragmentManager; private FragmentTransaction mCurTransaction = null; private Fragment mCurrentPrimaryItem = null; public FragmentPagerAdapter(FragmentManager fm) &#123; mFragmentManager = fm; &#125; private static String makeFragmentName(int viewId, long id) &#123; String s = \"android:switcher:\" + viewId + \":\" + id; Log.d(TAG, s); return s; &#125; /** * Return the Fragment associated with a specified position. */ public abstract Fragment getItem(int position); @Override public void startUpdate(ViewGroup container) &#123; if (container.getId() == View.NO_ID) &#123; throw new IllegalStateException(\"ViewPager with adapter \" + this + \" requires a view id\"); &#125; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; // 获得item的唯一id final long itemId = getItemId(position); // Do we already have this fragment? // 由itemId和viewPager的id生成一组Tag标记Fragment String name = makeFragmentName(container.getId(), itemId); // 通过tag去找fragment Fragment fragment = mFragmentManager.findFragmentByTag(name); // 如果不为空的话说明这个fragment已经添加过了，只是被detach了，就重新attach这个fragment if (fragment != null) &#123; if (DEBUG) Log.v(TAG, \"Attaching item #\" + itemId + \": f=\" + fragment); mCurTransaction.attach(fragment); &#125; else &#123; // 如果为空，创建一个Fragment，添加进去。 fragment = getItem(position); if (DEBUG) Log.v(TAG, \"Adding item #\" + itemId + \": f=\" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId)); &#125; // 如果当期显示的fragment不是这里初始化的fragment，将这里的fragment设置为用户不可见 if (fragment != mCurrentPrimaryItem) &#123; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); &#125; return fragment; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) &#123; Log.v(TAG, \"Detaching item #\" + getItemId(position) + \": f=\" + object + \" v=\" + ((Fragment) object).getView()); &#125; mCurTransaction.detach((Fragment) object); &#125; @Override public void setPrimaryItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; // 这里展现给用户可见的fragment是object，所以需要把mCurrentPrimaryItem设置为不可见， // object设置为可见。 if (fragment != mCurrentPrimaryItem) &#123; if (mCurrentPrimaryItem != null) &#123; mCurrentPrimaryItem.setMenuVisibility(false); mCurrentPrimaryItem.setUserVisibleHint(false); &#125; if (fragment != null) &#123; fragment.setMenuVisibility(true); fragment.setUserVisibleHint(true); &#125; mCurrentPrimaryItem = fragment; &#125; &#125; @Override public void finishUpdate(ViewGroup container) &#123; if (mCurTransaction != null) &#123; mCurTransaction.commitNowAllowingStateLoss(); mCurTransaction = null; &#125; &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return ((Fragment) object).getView() == view; &#125; @Override public Parcelable saveState() &#123; return null; &#125; @Override public void restoreState(Parcelable state, ClassLoader loader) &#123; &#125; /** * Return a unique identifier for the item at the given position. * * &lt;p&gt;The default implementation returns the given position. * Subclasses should override this method if the positions of items can change.&lt;/p&gt; * * @param position Position within this adapter * @return Unique identifier for the item at position */ public long getItemId(int position) &#123; return position; &#125;&#125; 重点关注instantiateItem和setPrimaryItem这两个方法。在instantiateItem中通过TAG来找fragment，没有的话就初始化添加到frament事务中。有的话直接Attach。关键是这里设置了fragment的可见状态。setPrimaryItem中也是对当前fragment可见状态做了标记。所以我们来仔细看看setUserVisibleHint这个方法。 setUserVisibleHint 源码走读这个方法用来设置ui是否对用户可见。这个方法不会自动调用，是需要手动调用的，其实就是设置了一个boolean标记，没有做什么特殊处理。viewpager里面左右切换fragment的时候对frgament设置了setUserVisibleHint，所以我们是不是可以通过这个可见性标记来处理懒加载？ 123456789101112131415161718192021222324252627282930313233343536373839 /** * 设置一个标记，标注用户是否可以看到Fragment的UI。默认是可见的，为true。 * 在fragment实例状态保存和恢复之间，这个标记是持久化存在的。 * * 当fragment被滚动到屏幕之外，这时是不可见的。或者，不想直接对用户可见。 * 系统可以使用这一点来优先处理诸如片段生命周期更新或加载器排序行为的操作。 * * 注意：此方法可能在片段生命周期之外调用。 因此在fragment生命周期方法调用中没有排序保证。 * * @param isVisibleToUser 如果此fragment的UI当前对用户可见（默认），则为true，否则为false。 */ public void setUserVisibleHint(boolean isVisibleToUser) &#123; // 如果原来对用户不可见 &amp;&amp; 现在要设置为可见 &amp;&amp; 状态在started之前 // &amp;&amp; mFragmentManager不为空 &amp;&amp; 已经被添加到Activity了 // 就执行performPendingDeferredStart()这个方法 if (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED &amp;&amp; mFragmentManager != null &amp;&amp; isAdded()) &#123; mFragmentManager.performPendingDeferredStart(this); &#125; mUserVisibleHint = isVisibleToUser; mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser; &#125;``` ```javapublic void performPendingDeferredStart(Fragment f) &#123; if (f.mDeferStart) &#123; if (mExecutingActions) &#123; // Wait until we're done executing our pending transactions mHavePendingDeferredStart = true; return; &#125; f.mDeferStart = false; moveToState(f, mCurState, 0, 0, false); &#125; &#125; ViewPager#/frameworks/base/core/java/com/android/internal/widget/ViewPager.java123456789101112131415161718192021222324252627282930313233343536373839404142//每次切换ViewPager的Tab时调用的方法void populate(int newCurrentItem) &#123; mAdapter.startUpdate(this); //...... addNewItem(mCurItem, curIndex); // mCurItem 为当前可见Fragment // 调用setUserVisibleHint(true) mAdapter.setPrimaryItem(this, mCurItem, curItem != null ? curItem.object : null); // 在这里调用了mCurTransaction.commitNowAllowingStateLoss();开始初始化 fragment， // 所以setUserVisibleHint是在整个frament生命周期之前调用的 mAdapter.finishUpdate(this); //..... &#125;ItemInfo addNewItem(int position, int index) &#123; ItemInfo ii = new ItemInfo(); ii.position = position; // 初始化fragment, 这里调用了setUserVisibleHint(false) ii.object = mAdapter.instantiateItem(this, position); ii.widthFactor = mAdapter.getPageWidth(position); if (index &lt; 0 || index &gt;= mItems.size()) &#123; mItems.add(ii); &#125; else &#123; mItems.add(index, ii); &#125; return ii;&#125;``` ViewPager在创建Fragment之前，初始化的时候先设置setUserVisibleHint(false)，在当前页面对用户可见的时候调用setUserVisibleHint(true)。所有的操作完成后最后将执行frgament.commit()。所以setUserVisibleHint都是先于fragment的生命周期调用的。 使用FragmentAdapter并不会销毁Fragment实例，只会销毁View。```javaonPauseonStoponDestroyView 因为setUserVisibleHint最先调用，所以避免空指针需要判断View是否都初始化完毕了。根据这个思路我用2个map来保存每个fragment的view是否初始化了，和是否加载过数据。当fragment销毁view时重置标记。代码如下：fragment需要实现getPosition表明他的position。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * author: Amaze * date: 2017/4/20 11:44 * des: 适用于ViewPager懒加载fragment */public abstract class LazyViewPagerFragment extends Fragment &#123; private static final String TAG = \"LazyViewPagerFragment\"; private final SparseBooleanArray mIsViewCreatedArray = new SparseBooleanArray();// 存储view是否加载完 private final SparseBooleanArray mIsDataLoadedArray = new SparseBooleanArray();// 存储数据是否加载过了 @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); mIsViewCreatedArray.put(getPosition(), true); // 初始化完了View if (getUserVisibleHint()) &#123; loadData(); mIsDataLoadedArray.put(getPosition(), true); &#125; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); // 销毁时重置 reset(); &#125; private void reset() &#123; mIsViewCreatedArray.put(getPosition(), false); // 默认没有初始化View mIsDataLoadedArray.put(getPosition(), false); // 默认没有加载过数据 &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); reset(); &#125; @Override public void onHiddenChanged(boolean hidden) &#123; super.onHiddenChanged(hidden); &#125; @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); // 如果对用户可见且初始化完毕 if (isVisibleToUser &amp;&amp; mIsViewCreatedArray.get(getPosition()) &amp;&amp; !mIsDataLoadedArray.get( getPosition())) &#123; loadData(); mIsDataLoadedArray.put(getPosition(), true); &#125; &#125; protected abstract void loadData(); protected abstract int getPosition();&#125; FragmentAdapter和FragmentStatePagerAdapter的区别观察生命周期，当ViewPager销毁frgament的时候：1234567891011// FragmentAdapter：onPauseonStoponDestroyView // FragmentStatePagerAdapteronPauseonStoponDestroyViewonDestroyonDetach 所以之后重新创建的时候： 1234567891011// FragmentAdapter：onViewCreatedonStartonResume// FragmentStatePagerAdapteronAttachonCreateonViewCreatedonStartonResume FragmentStatePagerAdapter完全把fragment移除了，FragmentAdapter只是销毁了View。因此FragmentStatePagerAdapter里面用Bundle保存数据以便恢复。 FragmentStatePagerAdapter对内存开销更小，复杂页面应该使用这个。 参考资料Fragment的setUserVisibleHint详解 Andriod开发技巧——Fragment的懒加载","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"https://luwenjie.me/tags/Fragment/"}]},{"title":"Java的动态代理","slug":"Java_dynamicProxy","date":"2017-04-19T03:56:00.000Z","updated":"2017-04-19T03:56:50.000Z","comments":true,"path":"2017/04/19/Java_dynamicProxy/","link":"","permalink":"https://luwenjie.me/2017/04/19/Java_dynamicProxy/","excerpt":"结合Re：从零开始的设计模式 2 - 代理模式(Proxy Pattern) 学习一下Java的动态代理机制。","text":"结合Re：从零开始的设计模式 2 - 代理模式(Proxy Pattern) 学习一下Java的动态代理机制。 Proxy123456789101112// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象static Class getProxyClass(ClassLoader loader, Class[] interfaces) // 方法 3：该方法用于判断指定类对象是否是一个动态代理类static boolean isProxyClass(Class cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) java.lang.ClassLoader类装载器，负责将类的字节码装载到Java虚拟机中并为其定义对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。 接口的定义123public interface Subject &#123; void request(int id);&#125; 12345678910111213141516171819202122232425262728public class Demo1 &#123; public static void main(String[] args) &#123; dynamicProxy(); System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); &#125; private static void dynamicProxy() &#123; // TODO Auto-generated method stub Subject realSubject = new RealSubject(); Subject proxy = (Subject) java.lang.reflect.Proxy .newProxyInstance(realSubject.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), new InvocationSubject(realSubject)); proxy.request(1); &#125; private static class RealSubject implements Subject&#123; @Override public void request(int id) &#123; // TODO Auto-generated method stub System.out.println(id); &#125; &#125;&#125; 实现InvocationHandler接口123// 负责集中处理动态代理类的所有方法调用。第一个参数是Proxy动态代理类实例,// 第二个参数是被调用的方法对象，第三个方法是调用参数。public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; 1234567891011121314public class InvocationSubject implements InvocationHandler &#123; Subject subject; public InvocationSubject(Subject subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub System.out.println(\"log : \" + method.getName() + \" invoked with \" + args); return method.invoke(subject, args); &#125;&#125; 自动生成的Proxy代理类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.sun.proxy;import cn.hinus.designpattern.proxy.Subject;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Subject &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void request(int var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;Integer.valueOf(var1)&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m3 = Class.forName(\"cn.hinus.designpattern.proxy.Subject\").getMethod(\"request\", new Class[]&#123;Integer.TYPE&#125;); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 步骤 实现InvocationHandler接口实现自己的调用处理器 调用Prox.newProxyInstance创建动态代理类 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入 123456789101112// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象Class clazz = Proxy.getProxyClass(classLoader, new Class[] &#123; Interface.class, ... &#125;); // 通过反射从生成的类对象获得构造函数对象Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;); // 通过构造函数对象创建动态代理类实例Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123; handler &#125;); 简化的动态代理对象创建过程1234567// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 直接创建动态代理类实例Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, new Class[] &#123; Interface.class &#125;, handler ); 练习 通过 InvocationHandler 实现一个功能：拦截某个函数调用，如果发现调用的函数是一个名为“protectGetName” 的方法时，就打印一行语句，提示不能调用。 检查参数是否合法，如果不合法，打印不合法，退出调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by venjerLu on 2017/3/24. */public class Main &#123; public static void main(String[] args) &#123; System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); RealSubject realSubject = new RealSubject(); Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces(); Utils.print(\"\" + interfaces.length); for (Class s : interfaces) &#123; Utils.print(s.getName()); &#125; Subject subject = (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader() , interfaces, new Handler(realSubject)); String name = subject.getClass().getName(); Utils.print(name);// subject.protectGetName(1);// subject.protectGetName2(1);// subject.protectGetName3(1); subject.protectGetName3(\"fsdfsdf\"); &#125; public interface Subject &#123; void protectGetName(Object a); void protectGetName2(Object a); void protectGetName3(Object a); &#125; public interface Subject2 &#123; void protectGetNameB(Object a); void protectGetName2B(Object a); void protectGetName3B(Object a); &#125; private static class RealSubject implements Subject, Subject2 &#123; @Override public void protectGetName(Object a) &#123; Utils.print(\"protectGetName\"); &#125; @Override public void protectGetName2(Object a) &#123; Utils.print(\"protectGetName2\"); &#125; @Override public void protectGetName3(Object a) &#123; Utils.print(\"protectGetName3\"); &#125; @Override public void protectGetNameB(Object a) &#123; &#125; @Override public void protectGetName2B(Object a) &#123; &#125; @Override public void protectGetName3B(Object a) &#123; &#125; &#125; private static class Handler implements InvocationHandler &#123; Subject target; Handler(Subject target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Utils.print(proxy.getClass().getName()); if (method.getName().equals(\"protectGetName\")) &#123; Utils.print(\"函数是一个名为“protectGetName” 的方法，不能调用\"); return null; &#125; for (Object o : args) &#123; Utils.print(o.getClass().getName()); Utils.print(Integer.class.getName()); if (!o.getClass().getName().equals(Integer.class.getName())) &#123; Utils.print(\"参数不合法，必须为int\"); return null; &#125; &#125; return method.invoke(target, args); &#125; &#125;&#125; 生成的$Proxy0类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import Main.Subject;import Main.Subject2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Subject, Subject2 &#123; private static Method m1; private static Method m4; private static Method m3; private static Method m8; private static Method m6; private static Method m2; private static Method m7; private static Method m5; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void protectGetName(Object var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void protectGetName2(Object var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void protectGetName3B(Object var1) throws &#123; try &#123; super.h.invoke(this, m8, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void protectGetNameB(Object var1) throws &#123; try &#123; super.h.invoke(this, m6, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void protectGetName2B(Object var1) throws &#123; try &#123; super.h.invoke(this, m7, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void protectGetName3(Object var1) throws &#123; try &#123; super.h.invoke(this, m5, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m4 = Class.forName(\"Main$Subject\").getMethod(\"protectGetName\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m3 = Class.forName(\"Main$Subject\").getMethod(\"protectGetName2\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m8 = Class.forName(\"Main$Subject2\").getMethod(\"protectGetName3B\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m6 = Class.forName(\"Main$Subject2\").getMethod(\"protectGetNameB\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); m7 = Class.forName(\"Main$Subject2\").getMethod(\"protectGetName2B\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m5 = Class.forName(\"Main$Subject\").getMethod(\"protectGetName3\", new Class[]&#123;Class.forName(\"java.lang.Object\")&#125;); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 参考Java 动态代理机制分析及扩展，第 1 部分 进击的Java新人-动态代理 进击的Java新人-代理模式","categories":[{"name":"Java","slug":"Java","permalink":"https://luwenjie.me/categories/Java/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://luwenjie.me/tags/学习笔记/"}]},{"title":"自定义 View 笔记 3 - onDraw() 的过程","slug":"自定义 View onDraw()","date":"2017-04-05T07:15:00.000Z","updated":"2017-04-05T07:15:47.000Z","comments":true,"path":"2017/04/05/自定义 View onDraw()/","link":"","permalink":"https://luwenjie.me/2017/04/05/自定义 View onDraw()/","excerpt":"自定义 view 的最后一步是绘制，使用 Canvas 对象绘制出我们想要的效果。","text":"自定义 view 的最后一步是绘制，使用 Canvas 对象绘制出我们想要的效果。 绘制用到的Canvasdraw 方法中的参数都有个 Canvas 对象，先来了解一下这个东西。 The Canvas class holds the “draw” calls. To draw something, you need 4 basic components: A Bitmap to hold the pixels, a Canvas to host the draw calls (writing into the bitmap), a drawing primitive (e.g. Rect, Path, text, Bitmap), and a paint (to describe the colors and styles for the drawing). 官方文档-Canvas and Drawables 想要绘制一些东西，需要4个基础组件： 一个Bitmap，用来持有像素 一个Canvas画布，用来写入bitmap 一个绘制的图元，如（Rect，Path，text，Bitmap） 一个画笔，用来描述绘图的颜色和样式 view中的draw方法不需要我们自己创建一个bitmap，系统已经为我们创建好了。 给ImageView设置bitmap12345678910private void drawBitmap()&#123; Bitmap bitmap = Bitmap.createBitmap(800, 400, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); canvas.drawColor(Color.GREEN); Paint paint = new Paint(); paint.setColor(Color.RED); paint.setTextSize(60); canvas.drawText(\"hello, everyone\",150,200,paint); mImageView.setImageBitmap(bitmap); &#125; 在此处为canvas设置一个Bitmap，然后利用canvas画了一小段文字，最后使用ImageView显示了Bitmap。 在onDraw里面绘制不同的图形1234567891011121314151617181920212223242526272829303132333435363738394041@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制白色矩形 mPaint.reset(); mPaint.setColor(Color.WHITE); canvas.drawRect(0, 0, 800, 800, mPaint); // 绘制直线 mPaint.reset(); mPaint.setColor(Color.RED); mPaint.setStrokeWidth(10); canvas.drawLine(450, 30, 570, 170, mPaint); //--------&gt;绘制带边框的矩形 mPaint.reset(); mPaint.setStrokeWidth(10); mPaint.setARGB(150, 90, 255, 0); mPaint.setStyle(Paint.Style.STROKE); @SuppressLint(\"DrawAllocation\") RectF rectF1 = new RectF(30, 60, 350, 350); canvas.drawRect(rectF1, mPaint); //--------&gt;绘制实心圆 mPaint.reset(); mPaint.setStrokeWidth(14); mPaint.setColor(Color.GREEN); mPaint.setAntiAlias(true); canvas.drawCircle(670, 300, 70, mPaint); //--------&gt;绘制椭圆 mPaint.reset(); mPaint.setColor(Color.YELLOW); RectF rectF2 = new RectF(200, 430, 600, 600); canvas.drawOval(rectF2, mPaint); //--------&gt;绘制文字 mPaint.reset(); mPaint.setColor(Color.BLACK); mPaint.setTextSize(60); mPaint.setUnderlineText(true); canvas.drawText(\"Hello Android\", 150, 720, mPaint); &#125; 对canvas的操作 canvas.translate canvas.rotate canvas.clipRect canvas.save和canvas.restore PorterDuffXfermode Bitmap和Matrix Shader PathEffect 显示圆角图片123456789101112131415161718192021/** * @param bitmap 原图 * @param pixels 角度 * @return 带圆角的图 */ public Bitmap getRoundCornerBitmap(Bitmap bitmap, float pixels) &#123; int width=bitmap.getWidth(); int height=bitmap.getHeight(); Bitmap roundCornerBitmap = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(roundCornerBitmap); Paint paint = new Paint(); paint.setColor(Color.BLACK); paint.setAntiAlias(true); Rect rect = new Rect(0, 0, width, height); RectF rectF = new RectF(rect); canvas.drawRoundRect(rectF, pixels, pixels, paint); PorterDuffXfermode xfermode=new PorterDuffXfermode(PorterDuff.Mode.SRC_IN); paint.setXfermode(xfermode); canvas.drawBitmap(bitmap, rect, rect, paint); return roundCornerBitmap; &#125; drawview的draw()方法： 有2个draw()方法，分别是： void draw(Canvas canvas) boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) 源码中提及到draw有6个过程： Draw the background If necessary, save the canvas’ layers to prepare for fading（如有必要，保存画布层以准备褪色） Draw view’s content Draw children If necessary, draw the fading edges and restore layers（如有必要，绘制褪色边缘并恢复图层） Draw decorations (scrollbars for instance)（绘制装饰（例如滚动条）） 一般情况下可以忽略第2步和第5步。 绘制第2步和第5步要相对耗时一点。 draw(canvas)源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 手动的把当前的view以及它的所有子view渲染到画布上。 * 在调用此方法之前必须完成完整的layout过程。实现一个view的时候， * 实现&#123;@link #onDraw(android.graphics.Canvas)&#125;而不是覆盖此方法。 * 覆盖这个方法的时候一定要先调用父类super.draw(canvas)方法。 * * @param canvas 渲染视图的画布。 */@CallSuper public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; ( mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; // 第1步：绘制背景 int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // 一般情况下省略第2步和第5步 final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // 第3步：绘制内容 if (!dirtyOpaque) onDraw(canvas); // 第4步：绘制子view dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // 第6步：绘制decoration onDrawForeground(canvas); // 结束 return; &#125; /* * 下面是少数情况下的完整的流程 */ // Step 2, save the canvas' layers ....省略第2步的代码 // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers ....省略第5步的代码 // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas);&#125; draw(Canvas canvas, ViewGroup parent, long drawingTime)ViewGroup.drawChild()调用这个方法来让子view绘制自身,这里View根据图层类型和硬件加速特性来渲染。 onDrawView 中的 onDraw() 方法：1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */ protected void onDraw(Canvas canvas) &#123; &#125; 子类实现这个方法来绘制，参数canvas用来绘制背景画布。 dispatchDraw123456789/** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * @param canvas the canvas on which to draw the view */protected void dispatchDraw(Canvas canvas) &#123;&#125; 绘制自身之后，绘制子view之前可以调用这个方法。 ViewGroup 中的 drawChild()方法1234567891011/** * 绘制其中一个子view * * @param canvas 绘制子view的canvas * @param child 子view * @param drawingTime draw发生的时间 * @return 如果是调用invalidate()绘制的话就返回true */protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; draw的顺序图 参考自定义View系列教程04–Draw源码分析及其实践 How Android Draws Views","categories":[{"name":"自定义 View","slug":"自定义-View","permalink":"https://luwenjie.me/categories/自定义-View/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://luwenjie.me/tags/学习笔记/"}]},{"title":"我喜爱的几部电影/电视剧","slug":"myFavoriteMovie","date":"2017-02-24T17:08:00.000Z","updated":"2017-02-24T17:27:55.000Z","comments":true,"path":"2017/02/25/myFavoriteMovie/","link":"","permalink":"https://luwenjie.me/2017/02/25/myFavoriteMovie/","excerpt":"在一些电影里获得某种共鸣，在一些电影里体会某种情愫，在一些电影里塑造某种观念，在一些电影里改变某种认知，在一些电影里经历某种体验，在一些电影里沉淀某种情怀。","text":"在一些电影里获得某种共鸣，在一些电影里体会某种情愫，在一些电影里塑造某种观念，在一些电影里改变某种认知，在一些电影里经历某种体验，在一些电影里沉淀某种情怀。 人鬼情未了1990年的经典，经典的主题曲Unchained Melody单曲循环了几百次。 夏洛特烦恼穿越回去烧了教室，强吻了女神的那段最喜欢，在灿烂的青春就应该无所束缚的追求心之所向。虽然这是一部有点屌丝意淫味道的电影。开心麻花的演员演技都很扎实，朋友带我看过一次开心麻花的话剧，惊叹这才是真正的表演。 率性而活一本正经的幽默，但是又折射了社会问题。男主为何能如此认真。 熔炉韩国善于用一些真实题材拍成电影讽刺社会，警醒政府。我大天朝的电影我不想说话。 素媛被性侵过后的最大伤害是心理伤害，来源于以后别人的看法，这比物理伤害影响更久远，需要更大的勇气和努力走出来。更何况还是小女孩，很让人心痛。 7号房的礼物将行刑前，小女主和父亲分别的时候很揪心。 辩护人法律是为民主而生。 恐怖直播 这种题材的电影有漏洞在所难免，但韩国电影能做到这一步值得称赞，几乎是一间房子中的故事，格局却相当大，节奏紧张，剧情张力太强，舆论、媒体与政治的黑洞令人反思，结尾比搏击俱乐部还激进，美国估计都不敢拍，但韩国敢拍能拍。 想到【疑人X的献身】的一句话：这个社会，想去犯罪的往往都是可怜的弱者。 不可饶恕 往往在你刚开始犯下第一个错误的时候，所有的错误就为你安排完毕。 在世界心中呼唤爱 为麻酱而看。 如果有这样一个人能让那个男人泣不成声。爱他就带他去最喜欢的地方，就录下他的声音，就和他一起拍张照片，把一切都和他分享。是追寻回忆亦或是自我救赎。原来澳大利亚的红岩山是世界的中心啊~天堂是活着的人创造的东西，一切美好的东西都在那里。总有一天要重逢的。我们能做的，就是帮他们实现遗愿。原来最幸福的是红衣服的小女孩儿~黑白世界里，她是唯一有颜色的人。 你的名字 看完才知道原来麻酱参与了配音。新海诚的电影每一帧都可以作为壁纸。 桃花期 我麻酱被袭胸了。/(ㄒoㄒ)/~~这部作品真是满足了广大屌丝对女神的YY。 如果他还单身，全世界都是你的情敌，如果他有对象了，你的情敌就只剩一个了啊。 请叫我英雄 麻酱和村花真是太美了。这部电影有个高能预警的同名网络剧请叫我英雄：开战之日，建议看正片之前先食用。 龙樱 Gakki，山下智久，麻酱。认识麻酱就是从这部剧，从此成为麻酱粉；Gakki 在这部剧好黑。 考试的答案永远只有一个，没有达到就是不合格，这是很残酷的。但是人生是不同的，人生的正确答案有很多个。所以不要怯懦生存。 不要否定自己的可能性，不管考没考上都要堂堂正正活下去。(看到这句的时候真是彻底泪目。) 如果我高考之前看完这部，我应该可以上清华。毕竟太励志，哈哈哈。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://luwenjie.me/categories/杂谈/"}],"tags":[]},{"title":"Android中的groovy及gradle","slug":"Android中的groovy及Gradle","date":"2017-02-24T16:59:00.000Z","updated":"2017-02-24T17:02:01.000Z","comments":true,"path":"2017/02/25/Android中的groovy及Gradle/","link":"","permalink":"https://luwenjie.me/2017/02/25/Android中的groovy及Gradle/","excerpt":"Android Studio使用gradle来构建项目，之前看一堆配置总是云里雾里，现在来梳理一下。","text":"Android Studio使用gradle来构建项目，之前看一堆配置总是云里雾里，现在来梳理一下。 Groovy构建即build/make，把零碎的文件组织成完整的项目。Android Studio使用gradle来构建，类似还有Ant，Maven。 gradle基于Ant和Maven，使用groovy。groovy最大的特点就是-简单。AS目录下的build.gradle里面就是groovy语句。 groovy简介 groovy是一种基于jvm虚拟机的动态语言，语法简单，对于学过python等语言的人来说上手很快。groovy完全兼容java,又在java的基础上增加了很多动态类型和灵活的特性，比如闭包，dsl等。在这里我将简单的介绍一下groovy的语法，主要是和gradle相关的部分。 格式每一行可以不用分号结尾。 支持动态类型，定义变量可以写成：def xxx，或者省略def直接写xxx。 数据类型基础类型区分不明显。 双引号会对内部计算，单引号直接显示内容。12345task Demo&lt;&lt;&#123; def name = \"Demo\" println '单引号：$&#123;name&#125;' println \"双引号：$&#123;name&#125;\" &#125; 输出内容：单引号：${name} 和 双引号：Demo 3种容器类型： List 链表（底层对应java的List接口） Map 键-值对应表 Range 基于List的一种扩展 12345678910// list的定义def demo_list = ['a','b','c']// 访问元素不会越界，list会自动扩展demo_list[-1] = 100;// 迭代demo_list.each&#123; println it&#125; 1234567891011// map的定义def demo_map = ['key1':a,'key2':b,'key3':c]// 访问println demo_map['key1']println demo_map.key2// 迭代demo_map.each&#123; println \"key = $&#123;it.key&#125;, value = $&#123;it.value&#125;\"&#125; 函数/方法 可以不写返回类型，但是必须加上def 可以省略return，此时最后一行代码的执行结果就是返回值 函数参数的类型可以不指定，可以是代码块(闭包) 123456789101112131415161718192021222324// 基础写法def String demo_function(String s)&#123; s = \"demo\" retun s&#125;// 简洁写法String demo_function(s)&#123; s = \"demo\"&#125;def demo_function(s)&#123; s = \"demo\"&#125;// 将闭包作为参数传给函数object.fun(&#123; println it&#125;)// 如果函数的最后一个参数是闭包，也可以把这个闭包放在外面，括号可以省略object.fun&#123; println it&#125; 闭包 闭包（closure），是一种数据结构，包含了一段代码，在写法上与函数有相似之处。 12345def demo_closure&#123; String param-&gt; println param return param&#125; 定义闭包时，需要用花括号把要处理的代码块包起来 定义参数需要在参数后加上-&gt; 例如： String param-&gt;，否则直接在花括号内写代码 闭包如果只有一个参数时，可以不用声明，在代码块中调用这个参数时默认可以隐藏的参数it来代替（容器类的each函数及是如此） 如果定义闭包时没有定义参数但是有-&gt;符号，则这个隐藏参数it也就不存在了，此时调用闭包时不可传递参数 代码块如果有返回值，可以用return返回，也可以不谢return，这样就和函数的定义一样，默认把最后一行的结果作为返回值 脚本 groovy和Java一样都有类的概念，和Java一样：package me.amaze 可以用public/private修饰，用import引用其他类 1234class Demo&#123; String param1 String param2 &#125; 123import com.levent_j.groovy.Demo1def demo=new Demo(\"a\",\"b\") groovy不需每个类都写class或interface等 groovy文件中若出现class，它是一个类似于Java中的类 可以把要做的一堆操作直接扔到单个的groovy文件中，这样就是一个脚本类，在执行时可以直接执行这个.groovy后缀的脚本 groovy是基于java的语言，它和java是怎么联系起来的？ groovy在执行时会首先把.groovy文件中的内容转换为一个java中的类，然后提供一个main函数，并由run()方法来执行 注意： 在脚本类中操作时一定要注意定义的函数和参数及其作用域。脚本类中定义的函数是作为这个类的成员变量的，而定义的参数如果在定义时加上了def 和类型时，在转为java类后是在run()函数中定义的，因此如果要在函数中使用当前脚本类中定义的参数时，定义的参数前面不要加def 和类型，不过这样定义的参数，其他的脚本却无法访问。要解决这个问题，需要在脚本文件开头加上import groovy.transform.Field;并在定义参数时在前面加上@符号。至于原因就需要大家自己看看转为java类后的代码了。 IO操作只需2步： 创建file对象 调用各种方法操作文件 1def demo_file = new File(\"fileName\") 123456789101112131415demo_file.eachLine&#123; // 对每一行进行操作&#125;// 一次性读取整个文件内容并以byte[]格式储存demo_dile.getBytes()// 使用inputstream操作，结束后需要手动closedef ism = demo_file.newInputStream() ism.close()// 使用闭包操作inputstream,操作结束不必手动close，groovy会自动帮我们closedemo_file.withInputStream&#123; ism-&gt;&#125; Gradle配置环境比较简单，略。配置完执行gradle -v查看版本看看是否成功。 重要概念Project 每个用Gradle构建的工程都叫 一个Project，每个Project会包含很多Task，在构建过程中，不同的Task各司其职。每个Task相当于一个Project对象的函数，专门用来干一件事，比如Android项目的构建过程就包括了Java的编译、资源的编译、打包过程、签名等Task。 12345678// Task的原型为create(String name,Closure configureClosure)// 第一个参数为任务名，第二个为闭包，所以可以省略()。task demo_task&#123; doFirst&#123; &#125; doLast&#123; &#125;&#125; Task A 可以依赖 Task B，执行A之前会先执行B，可以依赖多个Task 在每一个Project中都必须有一个build.gradle文件，这是一个构建脚本，类似于makefile，这个文件是整个Project构建的入口，可以在其中做一些配置，比如版本、插件、依赖等 Android Studio默认的Gradle配置 选中了4个文件 Project的build.gradle module的build.gradle gradle-wrapper.properties setting.gradle gradle-wrapper.properties：123456789#Mon Dec 28 10:00:20 PST 2015distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/dists// 这个uri表明本工程使用gradle是要从https://services.gradle.org/distributions/gradle-2.10-all.zip下载的gradle2.10版本distributionUrl=https\\://services.gradle.org/distributions/gradle-2.10-all.zip setting.gradle：12345// 每构建一个module就要在这里配置一下，AS会自动配置。include ':app'// 增加一个demo moduleinclude ':app',':demo' 根目录下的build.gradle: 1234567891011121314151617181920212223242526// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; // 声明仓库源 repositories &#123; jcenter() &#125; // 声明依赖的gradle版本 dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() mavenCentral() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; module的build.gradle:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 声明用的android构建插件apply plugin: 'com.android.application'android &#123; // SDK 版本 compileSdkVersion 22 // build tools 版本 buildToolsVersion '22.0.1' // 默认设置 defaultConfig &#123; // 应用包名 applicationId \"com.zzr\" // SDK设置 minSdkVersion 14 targetSdkVersion 22 // 版本设置 versionCode 10 versionName \"1.2.4\" &#125; // 构建设置 buildTypes &#123; release &#123; // 是否混淆 minifyEnabled false // 混淆文件的位置 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' // 打包优化 zipAlignEnabled true &#125; &#125; // 资源目录的配置 sourceSets &#123; main &#123; manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets'] &#125; androidTest.setRoot('tests') &#125; //配置keystore签名 signingConfigs &#123; debug &#123; storeFile file(\"XXX.jks\") storePassword \"xxxxxx\" keyAlias \"xxx\" keyPassword \"xxxxxx\" &#125; release &#123; storeFile file(\"xxxxxx.jks\") storePassword \"xxxxxx\" keyAlias \"xxxxxx\" keyPassword \"xxxxxx\" &#125; &#125;&#125;dependencies &#123; // 依赖lib文件夹里面所有的jar包 compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:22.2.1' compile 'com.android.support:support-v4:22.2.1'&#125; 统一管理在根目录新建config.gradle 123456789ext &#123; android = [compileSdkVersion: 22, buildToolsVersion: \"22.0.1\", applicationId : \"com.zzr\", minSdkVersion : 14, targetSdkVersion : 22, versionCode : 10, versionName : \"1.2.4\",]&#125; 在根目录build.gradle应用 apply from: &quot;config.gradle&quot; 在app目录下的build.gradle配置 12345678910compileSdkVersion config.compileSdkVersion buildToolsVersion config.buildToolsVersion // useLibrary\"org.apache.http.legacy\" defaultConfig &#123; applicationId config.applicationId minSdkVersion config.minSdkVersion targetSdkVersion config.targetSdkVersion versionCode config.versionCode versionName config.versionName &#125; 参考资料Gradle：从入门到放弃（一） Gradle：从入门到放弃（二）) Gradle：从入门到放弃（三）) 50 条 gradle 使用建议和技巧 gradle官方文档 gradle的官网 详细配置android studio中的gradle","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[]},{"title":"自定义 View 笔记 3 - onMeasure() 的过程","slug":"自定义 View onMeasure() 的过程","date":"2017-01-19T14:23:00.000Z","updated":"2017-01-29T10:13:43.000Z","comments":true,"path":"2017/01/19/自定义 View onMeasure() 的过程/","link":"","permalink":"https://luwenjie.me/2017/01/19/自定义 View onMeasure() 的过程/","excerpt":"上篇自定义 View 笔记 2 - MeasureSpec 详解分析了MeasureSpec生成的原理，父容器测量子 View首先确定MeasureSpec，再让子View测量自己。","text":"上篇自定义 View 笔记 2 - MeasureSpec 详解分析了MeasureSpec生成的原理，父容器测量子 View首先确定MeasureSpec，再让子View测量自己。 完整的流程图是这样的： 父类和子类共同确定完子类的MeassureSpec后，子类就要测量自身的尺寸。 其中子View测量自身源码的调用流程图：我们从尾到头看一下源码的实现。 View#getSuggestedMinimumWidth() &amp; View#getSuggestedMinimumHeight()123456789101112131415/** * 返回视图的最小宽度。先比较视图的最小值和背景的最小值，返回较小的。 * @return 建议的视图最小宽度 */protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;/** * 返回视图的最小高度。先比较视图的最小值和背景的最小值，返回较小的。 * @return 建议的视图最小高度 */protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; View#getDefaultSize(int, int)：123456789101112131415161718192021222324252627/** * 返回一个默认的大小。如果 MeasureSpec 没有约束，则使用提供的大小。 * * @param size View 的默认大小 * @param measureSpec 此视图的 MeasureSpec * @return View 应该得到的默认大小 */public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; // 获得此视图的测量模式 int specMode = View.MeasureSpec.getMode(measureSpec); // 获得此时图的测量大小 int specSize = View.MeasureSpec.getSize(measureSpec); switch (specMode) &#123; // 如果未限制，结果为 View 的默认大小 case View.MeasureSpec.UNSPECIFIED: result = size; break; // 如果限制为准确模式或最大模式，结果为 MeasureSpec 的测量大小 case View.MeasureSpec.AT_MOST: case View.MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; View#setMeasuredDimension(int, int)123456789101112131415161718/** * 这个方法必须由 onMeasure(int, int) 调用来存储测量宽度和测量高度。如果没有调用会触发测量时异常。 * * @param measuredWidth 此视图的测量宽度 * @param measuredHeight 此视图的测量高度 */protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125; 上述方法最终调用 View#setMeasuredDimensionRaw(int, int) 12345678910111213/** * 原始的设置测量的尺寸。 * @param measuredWidth * @param measuredHeight */private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; // 赋值 mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; // 设置 flag mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; View#onMeasure(int, int)1234567891011121314151617/** * 测量视图及其内容以确定测量的宽度和测量的高度。 此方法由 measure（int，int）调用，应由子类覆盖以提供其内容的准确和高效的测量。 * * 当覆写这个方法的时候，必须调用 setMeasuredDimension(int, int) 存储视图的测量宽度和高度。否则会被 measure() 抛出 IllegalStateException。 * * 可以直接调用父类的 onMeasure(int, int) * * 除非 MeasureSpec 允许更大的尺寸，测量的基本类实现默认是背景的大小。子类应该重写 onMeasure(int, int)，提供更好的内容测量。 * * 如果这个方法被覆盖，子类必须保证测量的高度和宽度不小于视图的最小高度和宽度。 * @param widthMeasureSpec 此 View 的宽的 MeasureSpec * @param heightMeasureSpec 此 View 的高的 MeasureSpec */protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 为什么自定义View设置为WRAP_CONTENT，最后显示的效果是MATCH_PARENT?根据上篇总结的MeasureSpec生成的规则表可以得知，如果子View的布局参数是WRAP_CONTENT，不管父容器的MeasureSpec模式是EXACTLY还是AT_MOST，子View的MeasureSpec模式都是AT_MOST，且大小都为父容器剩下的大小。 所以我们虽然设置了WRAP_CONTENT，最后看到的效果却是MATCH_PARENT。 如何fix这个问题？我们通过重写onMeasure()处理宽或高为WRAP_CONTENT的情况。 123456789101112131415161718@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); // 如果宽和高都是AT_MOST模式，宽和高都设置为默认值，否则宽或高另设默认值 if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(mWidth, mHeight); &#125; else if (widthMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(mWidth, heightSize); &#125; else if (heightMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSize, mHeight); &#125;&#125; 子View布局为MATCH_PARENT，父容器的模式为AT_MOST的\b情况对照上面的MeasureSpec生成规则图，有这种情况：如果子View布局参数为MATCH_PARENT，父容器的模式为AT_MOST，那么子View的MeasureSpec模式为AT_MOST，大小为父容器剩下的大小。 如果这种情况下我们也根据判断是否为AT_MOST模式进行默认值赋值。那么子View的大小结果就是一个准确的值，而它的模式却是MATCH_PARENT。 这种情况是不合理的： 不可能出现根View的大小为wrap_content但它的一个子View大小为match_parent。 从根到这个子View的父容器都是wrap_content，而子View的大小为match_parent。这个极端情况也是不会的。 从根到这个子View的父容器都是wrap_content，而子View大小也为wrap_content。这是个正常情况也正是我们改良后的onMeasure()来专门处理的子View大小为wrap_content的情况。 LinearLayout的测量过程public abstract class ViewGroup extends View implements ViewParent, ViewManager ViewGroup是一个抽象类，它没有重写View的onMeasure()。容器类继承ViewGroup并根据自身的情况重写onMeasure()。 父容器类如何测量子View并且确定自身的大小？我们看看LinearLayout是如何做的。 onMeasure()12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; measureVertical()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123; mTotalLength = 0; int maxWidth = 0; int childState = 0; int alternativeMaxWidth = 0; int weightedMaxWidth = 0; boolean allFillParent = true; float totalWeight = 0; final int count = getVirtualChildCount(); final int widthMode = View.MeasureSpec.getMode(widthMeasureSpec); final int heightMode = View.MeasureSpec.getMode(heightMeasureSpec); boolean matchWidth = false; boolean skippedMeasure = false; final int baselineChildIndex = mBaselineAlignedChildIndex; final boolean useLargestChild = mUseLargestChild; int largestChildHeight = Integer.MIN_VALUE; int consumedExcessSpace = 0; // 遍历得到每个孩子的高度，并记录最大宽度。 for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); // 若孩子为空，跳出本次循环 if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; // 孩子的显示状态为GONE if (child.getVisibility() == GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; // 判断是否有分割线 if (hasDividerBeforeChildAt(i)) &#123; mTotalLength += mDividerHeight; &#125; // 得到孩子的LayoutParams final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); // weight累加到总weight上 totalWeight += lp.weight; final boolean useExcessSpace = lp.height == 0 &amp;&amp; lp.weight &gt; 0; if (heightMode == View.MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) &#123; // Optimization: don't bother measuring children who are only // laid out using excess space. These views will get measured // later if we have space to distribute. final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin); skippedMeasure = true; &#125; else &#123; if (useExcessSpace) &#123; // The heightMode is either UNSPECIFIED or AT_MOST, and // this child is only laid out using excess space. Measure // using WRAP_CONTENT so that we can find out the view's // optimal height. We'll restore the original height of 0 // after measurement. lp.height = LinearLayout.LayoutParams.WRAP_CONTENT; &#125; // Determine how big this child would like to be. If this or // previous children have given a weight, then we allow it to // use all available space (and we will shrink things later // if needed). final int usedHeight = totalWeight == 0 ? mTotalLength : 0; measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight); final int childHeight = child.getMeasuredHeight(); if (useExcessSpace) &#123; // Restore the original height and record how much space // we've allocated to excess-only children so that we can // match the behavior of EXACTLY measurement. lp.height = 0; consumedExcessSpace += childHeight; &#125; final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); if (useLargestChild) &#123; largestChildHeight = Math.max(childHeight, largestChildHeight); &#125; &#125; /** * If applicable, compute the additional offset to the child's baseline * we'll need later when asked &#123;@link #getBaseline&#125;. */ if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) &#123; mBaselineChildTop = mTotalLength; &#125; // if we are trying to use a child index for our baseline, the above // book keeping only works if there are no children above it with // weight. fail fast to aid the developer. if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) &#123; throw new RuntimeException(\"A child of LinearLayout with index \" + \"less than mBaselineAlignedChildIndex has weight &gt; 0, which \" + \"won't work. Either remove the weight, or don't set \" + \"mBaselineAlignedChildIndex.\"); &#125; boolean matchWidthLocally = false; if (widthMode != View.MeasureSpec.EXACTLY &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT) &#123; // The width of the linear layout will scale, and at least one // child said it wanted to match our width. Set a flag // indicating that we need to remeasure at least that view when // we know our width. matchWidth = true; matchWidthLocally = true; &#125; final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); childState = combineMeasuredStates(childState, child.getMeasuredState()); allFillParent = allFillParent &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT; if (lp.weight &gt; 0) &#123; /* * Widths of weighted Views are bogus if we end up * remeasuring, so keep them separate. */ weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth); &#125; else &#123; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); &#125; i += getChildrenSkipCount(child, i); &#125; if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) &#123; mTotalLength += mDividerHeight; &#125; if (useLargestChild &amp;&amp; (heightMode == View.MeasureSpec.AT_MOST || heightMode == View.MeasureSpec.UNSPECIFIED)) &#123; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); // Account for negative margins final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125; &#125; // Add in our padding mTotalLength += mPaddingTop + mPaddingBottom; int heightSize = mTotalLength; // Check against our minimum height heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // Reconcile our calculated size with the heightMeasureSpec int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0); heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK; // Either expand children with weight to take up available space or // shrink them if they extend beyond our current bounds. If we skipped // measurement on any children, we need to measure them now. int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace); if (skippedMeasure || remainingExcess != 0 &amp;&amp; totalWeight &gt; 0.0f) &#123; float remainingWeightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight; mTotalLength = 0; for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == GONE) &#123; continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); final float childWeight = lp.weight; if (childWeight &gt; 0) &#123; final int share = (int) (childWeight * remainingExcess / remainingWeightSum); remainingExcess -= share; remainingWeightSum -= childWeight; final int childHeight; if (mUseLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) &#123; childHeight = largestChildHeight; &#125; else if (lp.height == 0 &amp;&amp; (!mAllowInconsistentMeasurement || heightMode == View.MeasureSpec.EXACTLY)) &#123; // This child needs to be laid out from scratch using // only its share of excess space. childHeight = share; &#125; else &#123; // This child had some intrinsic height to which we // need to add its share of excess space. childHeight = child.getMeasuredHeight() + share; &#125; final int childHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec( Math.max(0, childHeight), View.MeasureSpec.EXACTLY); final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // Child may now not fit in vertical dimension. childState = combineMeasuredStates(childState, child.getMeasuredState() &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)); &#125; final int margin = lp.leftMargin + lp.rightMargin; final int measuredWidth = child.getMeasuredWidth() + margin; maxWidth = Math.max(maxWidth, measuredWidth); boolean matchWidthLocally = widthMode != View.MeasureSpec.EXACTLY &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT; alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth); allFillParent = allFillParent &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT; final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125; // Add in our padding mTotalLength += mPaddingTop + mPaddingBottom; // TODO: Should we recompute the heightSpec based on the new total length? &#125; else &#123; alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth); // We have no limit, so make all weighted views as tall as the largest child. // Children will have already been measured once. if (useLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null || child.getVisibility() == GONE) &#123; continue; &#125; final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); float childExtra = lp.weight; if (childExtra &gt; 0) &#123; child.measure( View.MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), View.MeasureSpec.EXACTLY), View.MeasureSpec.makeMeasureSpec(largestChildHeight, View.MeasureSpec.EXACTLY)); &#125; &#125; &#125; &#125; if (!allFillParent &amp;&amp; widthMode != View.MeasureSpec.EXACTLY) &#123; maxWidth = alternativeMaxWidth; &#125; maxWidth += mPaddingLeft + mPaddingRight; // Check against our minimum width maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); if (matchWidth) &#123; forceUniformWidth(count, heightMeasureSpec); &#125; &#125; 这段代码的主要操作： 遍历每个子View，并对每个子View调用measureChildBeforeLayout()，请参见代码第115-133行在measureChildBeforeLayout()方法内又会调用measureChildWithMargins()从而测量每个子View的大小。在该过程中mTotalLength保存了LinearLayout的高度，所以每当测量完一个子View该值都会发生变化。 调用setMeasuredDimension()设置LinearLayout的大小。","categories":[{"name":"自定义 View","slug":"自定义-View","permalink":"https://luwenjie.me/categories/自定义-View/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://luwenjie.me/tags/学习笔记/"}]},{"title":"自定义 View 笔记 2 - MeasureSpec 详解","slug":"自定义 View 笔记 - MeasureSpec 详解","date":"2017-01-19T14:20:00.000Z","updated":"2017-01-24T13:39:19.000Z","comments":true,"path":"2017/01/19/自定义 View 笔记 - MeasureSpec 详解/","link":"","permalink":"https://luwenjie.me/2017/01/19/自定义 View 笔记 - MeasureSpec 详解/","excerpt":"在自定义 View 的时候通常会遇到很多问题。比如为什么父 View 影响到了子 View 的 MeasureSpec 的生成？子 View 的 specMode 和 specSize 的生成依据又是什么？ 系统显示一个 View，首先需要通过测量(measure) 该 View 来知晓其长和宽从而确定显示该 View 时需要多大的空间。在测量的过程中 MeasureSpec 贯穿全程，发挥着不可或缺的作用。所以，了解 View 的测量过程，最合适的切入点就是 MeasureSpec。于是我们从 MeasureSpec 着手去寻找上述问题的答案。","text":"在自定义 View 的时候通常会遇到很多问题。比如为什么父 View 影响到了子 View 的 MeasureSpec 的生成？子 View 的 specMode 和 specSize 的生成依据又是什么？ 系统显示一个 View，首先需要通过测量(measure) 该 View 来知晓其长和宽从而确定显示该 View 时需要多大的空间。在测量的过程中 MeasureSpec 贯穿全程，发挥着不可或缺的作用。所以，了解 View 的测量过程，最合适的切入点就是 MeasureSpec。于是我们从 MeasureSpec 着手去寻找上述问题的答案。 概述MeasureSpec 是 View 类中的静态内部类。 A MeasureSpec encapsulates the layout requirements passed from parent to child.Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode. There are three possible 翻译：MeasureSpec (测量规格) 封装了从父节点传递给子节点的布局要求。每个 MeasureSpec 表示宽度或高度的要求。度量规格包括大小和模式。 有三种模式。 这段话的重要信息： MeasureSpec封装了父布局传递给子View的布局要求 MeasureSpec可以表示宽和高 MeasureSpec由size和mode组成 MeasureSpec 由 32 位 int 数据组成，其中高 2 位代表 mode，前 30 位代表 size。 这样实现是为了减少对象分配，计算中使用位运算提高了效率。 12345678// 获取 modeint specMode = MeasureSpec.getMode(measureSpec);// 获取 sizeint specSize = MeasureSpec.getSize(measureSpec);// 生成 measureSpecint measureSpec = MeasureSpec.makeMeasureSpec(size, mode); 三种模式一共有 3 种模式： MeasureSpec.UNSPECIFIED MeasureSpec.EXACTLY MeasureSpec.AT_MOST MeasureSpec.UNSPECIFIED Measure specification mode: The parent has not imposed any constraint on the child. It can be whatever size it wants. 不指定大小，View 想多大就多大，通常情况下绘制自定义 View 时才会使用。 MeasureSpec.EXACTLY Measure specification mode: The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be. 精确值模式。当我们设置控件的宽或高为具体的数值时即为此种模式。例如 ：1android:layout_width = \"100dp\" 1android:layout_width = \"match_parent\" 父布局已经为自 View 决定了准确的尺寸。 MeasureSpec.AT_MOST Measure specification mode: The child can be as large as it wants up to the specified size. 最大值模式。控件的尺寸只要不超过父控件允许的最大尺寸即可。例如：1android:layout_width = \"wrap_content\" 从源码中分析 MesaureSpec 是如何形成的父容器测量子 View 的过程如下： 父类容器 ViewGroup 在测量子 View 时会调用measureChildWidthMargins() ，在measureChildWidthMargins() 中又会调用 getChildMeasureSpec()。 通过这 2 个方法来了解这三个模式是如何生成的。 先来看 ViewGroup 中的 measureChildWidthMargins(View, int, int, int, int) 源码： 123456789101112131415161718192021222324252627/** * 请求此视图的一个孩子测量自身。 * 考虑到此视图的 MeasureSpec 要求和它有 padding 和 margins，孩子必须有 MarginLayoutParams。 * 计算 padding 和 margins 在 getChildMeasureSpec（） 中完成。 * * @param child 需要测量的孩子 * @param parentWidthMeasureSpec 当前 ViewGroup 视图的宽的 MeasureSpec * @param widthUsed 当前 ViewGroup 或者它的其他孩子在水平方向已经占用的空间 * @param parentHeightMeasureSpec 当前 ViewGroup 视图的高的 MeasureSpec * @param heightUsed 当前 ViewGroup 或者它的其他孩子在垂直方向已经占用的空间 */protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; // 获取孩子的 MarginLayoutParams final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); // 获得孩子的宽的 MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); // 获得孩子的高的 MeasureSpec final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); // 调用孩子 View 的 measure()方法，传入刚刚得到的孩子的宽和高的 MeasureSpec child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 注意这个方法传入的参数的含义。这四个参数 当前 ViewGroup 视图的宽的 MeasureSpec 当前 ViewGroup 或者它的其他孩子在水平方向已经占用的空间 当前 ViewGroup 视图的高的 MeasureSpec 当前 ViewGroup 或者它的其他孩子在垂直方向已经占用的空间 从这四个参数其实可以看出父 View 影响着子 View 的 MeasureSpec 的生成。 上述方法是通过 getChildMeasureSpec() 计算出子 View 宽和高的 MeasureSpec 的，我们来看看这个方法是如何计算的。 ViewGroup 中的 getChildMeasureSpec(int, int, int) 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 这个方法根据子 Veiw 的尺寸和父容器的 MeasureSpec 计算出子 View 的正确的 MeasureSpec * * @param spec 父容器的 MeasureSpec * @param padding 当前父容器的 padding 和 margin * @param childDimension 孩子想要在当前父容器上获取的尺寸 * @return 子 View 的 MeasureSpec */public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; // 获得父容器的测量模式和测量大小 int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); // 取 0 和 父容器剩下大小的最大值 int size = Math.max(0, specSize - padding); // 初始化子 View 的测量大小和测量模式 int resultSize = 0; int resultMode = 0; // 开始计算 MeasureSpec switch (specMode) &#123; // 父容器为 EXACTLY 模式 case MeasureSpec.EXACTLY: // 如果子类已经指定了准确的大小，孩子测量大小就是子类想要的大小，测量模式就是 EXACTLY。 if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; // 如果子类想要的大小是 MATCH_PARENT，即充满父容器，测量大小就为父容器剩余的大小。模式是 EXACTLY。 else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; // 如果子类想要的大小时 WRAP_CONTENT，测量大小就为父容器剩余的大小。模式是 AT_MOST。 else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 父容器为 AT_MOST 模式 case MeasureSpec.AT_MOST: // 如果子类已经指定了准确的大小，孩子测量大小就是子类想要的大小，测量模式就是 EXACTLY。 if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; // 如果子类想要的大小是 MATCH_PARENT，即充满父容器，但是父容器的大小是不固定的，那么子 View 测量大小就为父容器剩余的大小。模式也是 AT_MOST。 else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; // 如果子类想要的大小是 WRAP_CONTENT，子 View 大小不固定，父容器的大小也是不固定的，那么子 View 测量大小就为父容器剩余的大小。模式也是 AT_MOST。 else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 父容器为 UNSPECIFIED 模式 case MeasureSpec.UNSPECIFIED: // 如果子类已经指定了准确的大小，孩子测量大小就是子类想要的大小，测量模式就是 EXACTLY。 if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; // 如果子类想要的大小是 MATCH_PARENT，即充满父容器，那么子 View 测量大小就为父容器剩余的大小。模式也是 UNSPECIFIED。 else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; // 如果子类想要的大小是 WRAP_CONTENT，那么子 View 测量大小就为父容器剩余的大小。模式也是 UNSPECIFIED。 else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; // 根据上面得到的子 View 的测量大小和测量模式合成一个 MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 看完这段源码我们可以清楚的发现： 子 View 的 MeasureSpec 由其父容器的 MeasureSpec 和该子 View 本身的布局参数 LayoutParams 共同决定。 根据上述源码可以总结出下面这张表： 总结看到这里，开头问题迎刃而解。 比如为什么父 View 影响到了子 View 的 MeasureSpec 的生成？ 因为子 View 的 MeasureSpec 根据父 View 的 MeasureSpec 和子 View 的布局参数来计算的。 子 View 的 specMode 和 specSize 的生成依据又是什么？ 依据就是父 View 的 MeasureSpec 和子 View 的布局参数。 参考资料 自定义View系列教程02–onMeasure源码详尽分析 Android 群英传第三章","categories":[{"name":"自定义 View","slug":"自定义-View","permalink":"https://luwenjie.me/categories/自定义-View/"}],"tags":[]},{"title":"Mac Chrome 快捷键","slug":"Mac Chrome 快捷键","date":"2017-01-19T05:28:00.000Z","updated":"2017-01-21T09:52:11.000Z","comments":true,"path":"2017/01/19/Mac Chrome 快捷键/","link":"","permalink":"https://luwenjie.me/2017/01/19/Mac Chrome 快捷键/","excerpt":"每天使用最多的程序就是 Chrome，但是一直使用鼠标单手操作点来点去。记几个快捷键，使我们的工作效率提高一个档次。","text":"每天使用最多的程序就是 Chrome，但是一直使用鼠标单手操作点来点去。记几个快捷键，使我们的工作效率提高一个档次。 标签页和窗口快捷键 操作 快捷键 打开新窗口 ⌘ + n 在隐身模式下打开新窗口 ⌘ + Shift + n 打开新的标签页，并跳转到该标签页 ⌘ + t 重新打开最后关闭的标签页，并跳转到该标签页 ⌘ + Shift + t 跳转到下一个打开的标签页 ⌘ + Option + 向右箭头键 跳转到上一个打开的标签页 ⌘ + Option + 向左箭头键 跳转到特定标签页 ⌘ + 1 到 ⌘ + 8 跳转到最后一个标签页 ⌘ + 9 打开当前标签页浏览记录中记录的上一个页面 ⌘ + [ 或 ⌘ + 向左箭头键 打开当前标签页浏览记录中记录的下一个页面 ⌘ + ] 或 ⌘ + 向右箭头键 关闭当前标签页或弹出式窗口 ⌘ + w 关闭当前窗口 ⌘ + Shift + w 最小化窗口 ⌘ + m 隐藏 Google Chrome ⌘ + h 退出 Google Chrome ⌘ + q Google Chrome 功能快捷键 操作 快捷键 显示或隐藏书签栏 ⌘ + Shift + b 打开书签管理器 ⌘ + Option + b 在新标签页中打开“设置”页 ⌘ + , 在新标签页中打开“历史记录”页 ⌘ + y 在新标签页中打开“下载内容”页 ⌘ + Shift + j 打开查找栏搜索当前网页 ⌘ + f 跳转到与查找栏中搜索字词相匹配的下一条内容 ⌘ + g 跳转到与查找栏中搜索字词相匹配的上一条内容 ⌘ + Shift + g 打开查找栏后，搜索选定文本 ⌘ + e 跳转到所选部分 ⌘ + j 打开“开发者工具” ⌘ + Option + i 打开“清除浏览数据”选项 ⌘ + Shift + Delete 使用其他帐户登录或进入隐身模式 ⌘ + Shift + m 地址栏快捷键在地址栏中可使用以下快捷键： 操作 快捷键 使用默认搜索引擎进行搜索 输入搜索字词并按 Enter 键 使用其他搜索引擎进行搜索 输入搜索引擎名称并按 Tab 键 为网站名称添加 www. 和 .com，并在当前标签页中打开该网站 输入网站名称并按 Control + Enter 键 为网站名称添加 www. 和 .com，并在新标签页中打开该网站 输入网站名称并按 Control + Shift + Enter 键 在新的后台标签页中打开网站 输入网址并按 ⌘ + Enter 键 跳转到地址栏 ⌘ + l 网页快捷键 操作 快捷键 打开选项以打印当前网页 ⌘ + p 打开选项以保存当前网页 ⌘ + s 打开“页面设置”对话框 ⌘ + Option + p 通过电子邮件发送当前网页 ⌘ + Option + p 重新加载当前网页 ⌘ + r 重新加载当前网页（忽略缓存的内容） ⌘ + Shift + r 停止加载网页 Esc 浏览下一个可点击项 Tab 浏览上一个可点击项 Shift + Tab 使用 Google Chrome 打开计算机中的文件 按住 ⌘ + o 键并选择文件 显示当前网页的 HTML 源代码（不可修改） ⌘ + Option + u 打开 JavaScript 控制台 ⌘ + Option + j 将当前网页保存为书签 ⌘ + d 将所有打开的标签页以书签的形式保存在新文件夹中 ⌘ + Shift + d 开启或关闭全屏模式 ⌘ + Ctrl + f 放大网页上的所有内容 ⌘ 和 + 缩小网页上的所有内容 ⌘ 和 - 将网页上的所有内容恢复到默认大小 ⌘ + 0 向下滚动网页，一次一个屏幕 空格键 向上滚动网页，一次一个屏幕 Shift + 空格键 搜索网络 ⌘ + Option + f 将光标移到文本字段中的上一个字词前面 Option + 向左箭头键 将光标移到文本字段中的上一个字词后面 Option + 向右箭头键 删除文本字段中的上一个字词 Option + Backspace 在当前标签页中打开主页 ⌘ + Shift + h 鼠标快捷键以下快捷键要求您使用鼠标： 操作 快捷键 在当前标签页中打开链接（仅限鼠标） 将链接拖到标签页中 在新的后台标签页中打开链接 按住 ⌘ 键的同时点击链接 打开链接，并跳转到该链接 按住 ⌘ + Shift 键的同时点击链接 打开链接，并跳转到该链接（仅使用鼠标） 将链接拖到标签栏的空白区域 在新窗口中打开链接 按住 Shift 键的同时点击链接 在新窗口中打开标签页（仅使用鼠标） 将标签页拖出标签栏 将标签页移至当前窗口（仅限鼠标） 将标签页拖到现有窗口中 将标签页移回其原始位置 拖动标签页的同时按 Esc 将当前网页保存为书签 将相应网址拖动到书签栏中 下载链接目标 按住 Option 键的同时点击链接 显示浏览记录 右键点击“后退”箭头或“前进”箭头，或者点击并按住“后退”箭头或“前进”箭头 将窗口高度最大化 双击标签栏的空白区域 放大网页上的所有内容 按住 Ctrl 键的同时向上滚动鼠标滚轮 缩小网页上的所有内容 按住 Ctrl 键的同时向下滚动鼠标滚轮","categories":[{"name":"Mac","slug":"Mac","permalink":"https://luwenjie.me/categories/Mac/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://luwenjie.me/tags/Chrome/"}]},{"title":"自定义 View 笔记 1 - 常用工具","slug":"自定义 View 学习笔记-工具","date":"2017-01-15T06:25:00.000Z","updated":"2017-01-24T13:38:57.000Z","comments":true,"path":"2017/01/15/自定义 View 学习笔记-工具/","link":"","permalink":"https://luwenjie.me/2017/01/15/自定义 View 学习笔记-工具/","excerpt":"自定义之前先了解一下经常使用到的工具类，这些类能帮助我们快速开发，省的我们自己去实现一些细节问题。","text":"自定义之前先了解一下经常使用到的工具类，这些类能帮助我们快速开发，省的我们自己去实现一些细节问题。 主要用到的工具类有： Configuration ViewConfiguration GestureDetector VelocityTracker Scroller ViewDragHelper Configuration This class describes all device configuration information that can impact the resources the application retrieves. 用来描述设备的配置信息。比如用户的配置信息：locale 和 scaling 等等比如设备的相关信息：输入模式，屏幕大小，屏幕方向等等。 1234567891011Configuration configuration=getResources().getConfiguration();//获取国家码int countryCode=configuration.mcc;//获取网络码int networkCode=configuration.mnc;//判断横竖屏if(configuration.orientation==Configuration.ORIENTATION_PORTRAIT)&#123; &#125; else &#123;&#125; ViewConfiguration Contains methods to standard constants used in the UI for timeouts, sizes, and distances. 提供了一些自定义控件常用的标准常量，比如 UI 超时，尺寸大小，滑动距离，敏感度等。 1234567891011121314151617// 获取实例ViewConfigutation viewConfiguration = ViewConfiguration.get(context);//获取touchSlop。该值表示系统所能识别出的被认为是滑动的最小距离int touchSlop = viewConfiguration.getScaledTouchSlop();//获取Fling速度的最小值和最大值int minimumVelocity = viewConfiguration.getScaledMinimumFlingVelocity();int maximumVelocity = viewConfiguration.getScaledMaximumFlingVelocity();//判断是否有物理按键boolean isHavePermanentMenuKey=viewConfiguration.hasPermanentMenuKey();//双击间隔时间.在该时间内是双击，否则是单击int doubleTapTimeout=ViewConfiguration.getDoubleTapTimeout();//按住状态转变为长按状态需要的时间int longPressTimeout=ViewConfiguration.getLongPressTimeout();//重复按键的时间int keyRepeatTimeout=ViewConfiguration.getKeyRepeatTimeout(); GestureDetector Detects various gestures and events using the supplied {@link MotionEvent}s. The {@link OnGestureListener} callback will notify users when a particular motion event has occurred. This class should only be used with {@link MotionEvent}s reported via touch (don’t use for trackball events). 翻译：使用 MotionEvent 检测各种手势和事件。通过OnGestureListener 回调事件。不能用于轨迹球事件。 主要是为了简化 Touch 的操作。 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263GestureDetector gestureDetector;gestureDetector = new GestureDetector(this, new GestureDetectorImp());/** * OnGestureListener 的实现类 */class GestureDetectorImp implements GestureDetector.OnGestureListener &#123; /** * 触摸屏幕时 */ @Override public boolean onDown(MotionEvent e) &#123; log(\"GestureDetectorImp - onDown\"); return false; &#125; /** * 手指在屏幕上按下,且未移动和松开时 */ @Override public void onShowPress(MotionEvent e) &#123; log(\"GestureDetectorImp - onShowPress\"); &#125; /** * 轻击屏幕时 */ @Override public boolean onSingleTapUp(MotionEvent e) &#123; log(\"GestureDetectorImp - onSingleTapUp\"); return false; &#125; /** * 手指在屏幕上滚动时 */ @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return false; &#125; /** * 手指长按屏幕时 */ @Override public void onLongPress(MotionEvent e) &#123; &#125; /** * 手指在屏幕上拖动时 */ @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; return false; &#125;&#125;/** * 将 View 的 Touch 事件交给 GestureDetector 处理 */@Override public boolean onTouchEvent(MotionEvent event) &#123; return gestureDetector.onTouchEvent(event);&#125; VelocityTracker Helper for tracking the velocity of touch events, for implementing flinging and other such gestures. VelocityTracker 用于跟踪触摸屏事件（比如，Flinging 及其他 Gesture 手势事件等）的速率。 1234567891011121314151617181920212223242526272829303132 VelocityTracker mVelocityTracker;/** * 开始追踪 */ void startTrack(MotionEvent event) &#123; if (mVelocityTracker == null) mVelocityTracker = VelocityTracker.obtain(); mVelocityTracker.addMovement(event); &#125; /** * 得到速率 */ int getVelocity() &#123; // 设置单位，1000 表示 1 秒内移动的像素 mVelocityTracker.computeCurrentVelocity(1000); // 获取 1 秒内 X 方向移动的像素 float xVelocity = mVelocityTracker.getXVelocity(); // 返回绝对值 return (int) Math.abs(xVelocity); &#125; /** * 停止追踪 */ void stopTrack() &#123; if (mVelocityTracker != null) &#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; &#125; Scroller见 Scroller 学习笔记 ViewDragHelper ViewDragHelper is a utility class for writing custom ViewGroups. It offers a number of useful operations and state tracking for allowing a user to drag and reposition views within their parent ViewGroup. 用于简化 View 的拖拽的相关操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** * Author/Date: venjerLu / 2017/1/15 13:36 * Email: alwjlola@gmail.com * Description: viewDragHelper 使用示例 */public class ViewDragHelperLinearLayout extends LinearLayout &#123; private static final String TAG = \"VHLinearLayout\"; private ViewDragHelper mViewDragHelper; public ViewDragHelperLinearLayout(Context context) &#123; super(context); initViewDragHelper(); &#125; public ViewDragHelperLinearLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); initViewDragHelper(); &#125; public ViewDragHelperLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initViewDragHelper(); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public ViewDragHelperLinearLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); initViewDragHelper(); &#125; /** * 初始化 ViewDragHelper */ private void initViewDragHelper() &#123; mViewDragHelper = ViewDragHelper.create(this, 1.0f, new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(View child, int pointerId) &#123; Log.d(TAG, \"tryCaptureView\"); return true; &#125; /** * 处理竖直方向上的越界 * @param child * @param top * @param dy * @return */ @Override public int clampViewPositionVertical(View child, int top, int dy) &#123; Log.d(TAG, \"clampViewPositionVertical\"); int fixedTop; View parent = (View) child.getParent(); int paddingTop = getPaddingTop(); int bottomBound = getHeight() - child.getHeight() - parent.getPaddingBottom(); if (top &lt; paddingTop) &#123; fixedTop = paddingTop; &#125; else if (top &gt; bottomBound) &#123; fixedTop = bottomBound; &#125; else &#123; fixedTop = top; &#125; return fixedTop; &#125; /** * 处理水平方向上的越界 * @param child * @param left 左划的距离 * @param dx * @return */ @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; Log.d(TAG, \"clampViewPositionHorizontal\"); int fixedLeft; View parent = (View) child.getParent(); int leftBound = parent.getPaddingLeft(); // 左边的 padding int rightBound = parent.getWidth() - child.getWidth() - parent.getPaddingRight(); // 距离右边的最大距离 if (left &lt; leftBound) &#123;// 如果移动的距离小于左边距 fixedLeft = leftBound; &#125; else if (left &gt; rightBound) &#123; fixedLeft = rightBound; &#125; else &#123; fixedLeft = left; &#125; return fixedLeft; &#125; /** * 捕获 View * @param capturedChild * @param activePointerId */ @Override public void onViewCaptured(View capturedChild, int activePointerId) &#123; Log.d(TAG, \"onViewCaptured\"); super.onViewCaptured(capturedChild, activePointerId); &#125; /** * 释放 View * @param releasedChild * @param xvel * @param yvel */ @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; Log.d(TAG, \"onViewReleased\"); super.onViewReleased(releasedChild, xvel, yvel); &#125; /** * 监听拖动状态的改变 * @param state */ @Override public void onViewDragStateChanged(int state) &#123; switch (state) &#123; case ViewDragHelper.STATE_DRAGGING: Log.d(TAG, \"onViewDragStateChanged &gt; STATE_DRAGGING\"); break; case ViewDragHelper.STATE_IDLE: Log.d(TAG, \"onViewDragStateChanged &gt; STATE_IDLE\"); break; case ViewDragHelper.STATE_SETTLING: Log.d(TAG, \"onViewDragStateChanged &gt; STATE_SETTLING\"); break; &#125; super.onViewDragStateChanged(state); &#125; /** * 拖拽方向改变 * @param changedView * @param left * @param top * @param dx * @param dy */ @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; Log.d(TAG, \"onViewPositionChanged\"); super.onViewPositionChanged(changedView, left, top, dx, dy); &#125; &#125;); &#125; /** * 将事件拦截交给 ViewDragHelper 处理 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev); &#125; /** * 将 Touch 事件交给 ViewDragHelper 处理 */ @Override public boolean onTouchEvent(MotionEvent event) &#123; mViewDragHelper.processTouchEvent(event); return true; &#125;&#125;","categories":[{"name":"自定义 View","slug":"自定义-View","permalink":"https://luwenjie.me/categories/自定义-View/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://luwenjie.me/tags/学习笔记/"}]},{"title":"Handler 总结","slug":"Handler 总结","date":"2017-01-10T11:44:00.000Z","updated":"2017-01-21T09:51:42.000Z","comments":true,"path":"2017/01/10/Handler 总结/","link":"","permalink":"https://luwenjie.me/2017/01/10/Handler 总结/","excerpt":"Android 最基础的最核心的组件 - Handler，了解它的原理，我们才能更好的使用它。","text":"Android 最基础的最核心的组件 - Handler，了解它的原理，我们才能更好的使用它。 主要内容 ThreadLocal Looper 和线程以及消息队列的关系 Message 的发送和处理过程 Handler 异步原理小结 使用 Handler 的错误姿势及其优化 ThreadLocal从 jdk 1.2 开始引进。实现不同线程的数据副本 保持线程相互独立 Looper Looper.prepare() 初始化当前的线程 作为一个 looperThreadLocal 里面放入了 looper1 个 looper 对应 1 个 messageQueue 对应 1 个 thread1 个线程只有一个 looper looper.prepareMainLopper() 专门为 Ui 线程准备的 looper.loop()从 threadLocal 取出 Looper，再取出 looper 中的消息队列进入循环，没有像消息就阻塞。有消息就 msg.target.dispatchMessage(msg)这里的 msg.target 正是 Handler looper.quit() 消息的发送和处理消息入队发送消息最终都会走 Handler的sendMessageAtTime(Message msg, long uptimeMillis) 这个方法 12345678910//Handler/** ** queue: ** msg: ** uptimeMills: 根据这个时间判断消息执行顺序, 如果是 0 就是第一个执行。 **/boolean enqueueMessage(MessageQueue queue，Message msg，long uptimeMillis)&#123; // 这个 target 赋值为 this， 就是 Handler。 msg.target = this;&#125; 消息出队Looper.prepare() 之后，需要调用loop() 方法轮询消息 ,首先从threadLocal 取出 Looper，再取出 looper 中的消息队列进入循环，没有消息就阻塞。有消息就 msg.target.dispatchMessage(msg)这里的 msg.target 正是 Handler 消息处理 判断消息的回调，这里的回调就是 handler.post(Runnable callback) 中的 Runnable 判断自己的回调，这里的回调是 Handler 构造函数中的 Runnable 处理消息 就是需要我们自己覆盖的方法 handleMessage() 梳理 Handler 工作机制 Thread: 负责业务逻辑 Handler：负责发送消息和处理消息 MessageQueue：负责保存消息 Looper：负责轮询消息队列 使用Handler的错误姿势及其潜在风险Hanler 在哪个线程就在那个线程执行#View.post(rnnable) 在主线程执行#Activity.runOnUiThread()在主线程执行 匿名内部内引发内存泄露1234567891011privite void init()&#123; mHandler = new Handler()&#123; @Override public void handleMessage(Message msg)&#123; // handler msg &#125; &#125; mhandler.postDelay(new Runnable()&#123; //do something &#125;,1000 * 20);&#125; 如上代码匿名内部类 new Runnable() 持有外部 Activity 的引用，如果旋转屏幕当前 Activity 不会被释放。 解决方式: 弱引用 Handler","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"https://luwenjie.me/tags/Handler/"}]},{"title":"Re：从零开始的数据结构 2 - 单链表","slug":"Re：从零开始的数据结构 2 - 单链表","date":"2017-01-09T14:43:00.000Z","updated":"2017-01-21T09:51:54.000Z","comments":true,"path":"2017/01/09/Re：从零开始的数据结构 2 - 单链表/","link":"","permalink":"https://luwenjie.me/2017/01/09/Re：从零开始的数据结构 2 - 单链表/","excerpt":"一般来说，单链表比顺序表的插入删除效率高，但是它的查找较为耗时。","text":"一般来说，单链表比顺序表的插入删除效率高，但是它的查找较为耗时。 为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为结点（Node）。 n个结点（ai的存储映像）链结成一个链表，即为线性表（a1,a2,…,an）的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。 头指针与头结点头指针 链表中第一个结点的存储位置叫做头指针，如果有头结点则指向头结点。最后一个节点的指针指向空。 头结点在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。也可以存储如线性表的长度等附加信息。 异同头指针： 头指针具有标识作用，所以常用头指针冠以链表的名字。 头结点： 头结点不是必须的。 有了头节点，第一个节点的插入、删除等操作和其他节点一样。 空表线性表为空，若有头结点，则头结点指向第一个节点的指针为空。 若没有头结点，则头指针为空。 节点节点里面存储了数据域和指向下一个节点的指针。用一个类来表示。1234567891011121314/** * 节点 */private static class Node&lt;T&gt; &#123; private T data; // 节点的数据 private Node&lt;T&gt; next; // 指向下一个节点的指针 public Node() &#123;&#125; public Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125;&#125; 单链表的初始化单链表需要一个头指针和尾指针，尾指针一定是 null，可以不声明。可以选择有无头结点。还需要一个计数器来计数。 初始化时，有头结点的话需要把头指针指向头结点，头节点的指针指向 null。没有头结点的话头指针指向 null。123456789101112131415161718192021222324252627282930private Node&lt;T&gt; head; // 头指针private Node&lt;T&gt; tail; // 尾指针private int size; // 节点的个数private boolean hasHeadNode = false; // 是否有头节点 /** * 初始化一个空表没有头结点 */public MyLinkedList() &#123; this.size = 0; head = null; // 头指针指向空 tail = null; // 尾指针指向空 hasHeadNode = false;&#125;/** * 初始化一个带头结点的空表 * * @param data 头结点的数据域，可以为 null */public MyLinkedList(@Nullable T data) &#123; Node&lt;T&gt; headNode = new Node&lt;&gt;(); // 头节点 headNode.data = data; headNode.next = null; // 头指针指向头结点 head = headNode; tail = null; // 尾指针指向空 this.size = 0; hasHeadNode = true;&#125; 查找在顺序表查找是很容易的。单链表中没有计数，只存储了下一个节点的位置，所以我们每次都要从头遍历查找并计数。 因为单链表没有定义表厂，所以不可以用 for 循环来查找，核心思想是 工作指针后移，这也是很多算法的常用技术。 最坏的时间复杂度是O(n)。 查找第 i 个节点的步骤： 声明一个指针 p 指向链表第一个结点，初始化 j 从 1 开始； 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1； 若到链表末尾 p 为空，则说明第i个结点不存在； 否则查找成功，返回结点 p 的数据。 123456789101112131415161718192021222324252627/** * 查找某个节点的指针 * * @param index 节点索引 * @return 节点指针 */private Node&lt;T&gt; getNode(int index) throws Exception &#123; if (size == 0) &#123; throw new Exception(\"表为空\"); &#125; // 检查 index 是否合法 checkInvalid(index); Node&lt;T&gt; p = head; // 初始化指针 p 指向第一个节点，即将头指针赋值给 p。 if (hasHeadNode) &#123; // 有头结点 for (int i = 0; i &lt;= index; i++) &#123; p = p.next; &#125; &#125; else &#123; // 没有头结点, 相比有头结点就要少循环一次 for (int i = 0; i &lt; index; i++) &#123; p = p.next; &#125; &#125; return p;&#125; 添加 要把 s 插入到 p 的后面，只需要把 p 中的指针指向 s，将 s 的指针指向 p.next。 在表头和表尾插入： 在第 i 个数据后面插入节点的步骤： 声明一个指针 P 指向链表的头结点，初始化 j = 1。 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个节点，j 累加 1。 若到链表末尾 p 为空，则说明第 i 个结点不存在； 否则查找成功，在系统中生成一个空结点 s； 将数据元素 e 赋值给 s-&gt;data； 单链表的插入标准语句 s-&gt;next=p-&gt;next; p-&gt;next=s； 返回成功。 头插法和尾插法不需要再特定位置插入的话，有头插法和尾插法 2 种方式，即在头部插入和在尾部插入。插入之前都需要先查找。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 默认是尾插法 * * @param t 元素 * @throws Exception */ @SuppressWarnings(\"unchecked\") @Override public void add(T t) throws Exception &#123; Node&lt;T&gt; node = new Node(); node.data = t; node.next = tail; if (size == 0) &#123; // 空表时从第一个插入 if (hasHeadNode) &#123; head.next = node; &#125; else &#123; head = node; &#125; &#125; else &#123; // 得到最后一个节点 Node&lt;T&gt; lastNode = getNode(size - 1); // 指向新插入的节点 lastNode.next = node; &#125; size++; &#125; /** * 头插法 * * @param t 元素 */ @SuppressWarnings(\"unchecked\") public void addAfterHead(T t) throws Exception &#123; Node&lt;T&gt; node = new Node(); node.data = t; node.next = tail; Node&lt;T&gt; p = head; // 将头指针赋值给临时指针 p if (size == 0) &#123; // 空表时从第一个插入 if (hasHeadNode) &#123; head.next = node; &#125; else &#123; head = node; &#125; &#125; else &#123; // 有头结点时，将头结点指针指向新插入的节点，将新插入节点的指针指向原头节点指针指向的节点 if (hasHeadNode) &#123; head.next = node; node.next = p.next; &#125; else &#123; // 没有头结点时，头指针指向新插入的节点，新插入的节点指向第一个节点 head = node; node.next = p; &#125; &#125; size++; &#125; 在指定位置插入想要在第 i 个位置插进去，就需要改变第 i-1 个位置节点的指针，新插进的节点的指针指向原来第 i 个位置的节点。 1234567891011121314151617181920212223242526272829/** * 指定插在某个位置 * * @param index 元素索引 * @param obj 元素实例 * @throws Exception */@Override public void insert(int index, T obj) throws Exception &#123; //检查 index 合法 checkInvalid(index); Node&lt;T&gt; newNode = new Node&lt;&gt;(); newNode.data = obj; if (index == 0) &#123; // 如果要插入到第一个位置 if (hasHeadNode) &#123; newNode.next = head.next; head.next = newNode; &#125; else &#123; newNode.next = head; head = newNode; &#125; &#125;else &#123; Node&lt;T&gt; node = getNode(index - 1);// 得到前一个节点 newNode.next = node.next; node.next = newNode; &#125; size++;&#125; 批量添加上述每次添加一个都需要重新查找一遍节点，这样时间复杂度就是 O(n的平方)，很费时。如果批量插入的话，只需要在插入第一个数据的时候查找一次，后续的节点直接接着插在末尾，时间复杂度只有0(n)。 这里我只实现了尾插法的批量添加：1234567891011121314151617181920212223242526272829303132333435363738/** * 批量从尾部加入数据 */@SuppressWarnings(\"unchecked\") public void add(T... data) throws Exception &#123; Node&lt;T&gt; p = null; // 临时指针 p 指向最后一个节点 for (int i = 0; i &lt; data.length; i++) &#123; Node&lt;T&gt; node = new Node(); node.data = data[i]; node.next = tail; if (i == 0) &#123; Log.d(TAG, \"批量插入- 第一条开始\"); // 第一个先查找再插入，后续直接一个一个插到后面。 if (size == 0) &#123; // 空表时从第一个插入 if (hasHeadNode) &#123; head.next = node; &#125; else &#123; head = node; &#125; &#125; else &#123; // 得到最后一个节点 Node&lt;T&gt; lastNode = getNode(size - 1); // 指向新插入的节点 lastNode.next = node; &#125; size++; p = node; Log.d(TAG, \"批量插入- 第一条结束\"); &#125; else &#123; Log.d(TAG, \"批量插入- 第\" + (i + 1) + \"条开始\"); p.next = node; // 最后一个节点指针指向新插入的节点 size++; p = node; Log.d(TAG, \"批量插入- 第\" + (i + 1) + \"条结束\"); &#125; &#125;&#125; 删除 要把 p 节点后面的节点删除，只需要将 p 节点的指针指向 p-&gt;next-&gt;next，即 p 的后面第二个节点。再将 p-&gt; next 指向 null，删除 p-&gt;next 节点。 删除第 i 个节点的步骤： 声明一个指针 P 指向链表的头结点，初始化 j = 1。 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个节点，j 累加 1。 若到链表末尾 p 为空，则说明第 i 个结点不存在； 否则查找成功，将欲删除的结点 p-&gt;next 赋值给 p 的前一个节点 q-&gt;next； 删除第 i 个节点。 123456789101112131415161718192021222324252627282930313233/** * 删除某个位置的节点 * * @param index 元素的索引 * @throws Exception */ @Override public void delete(int index) throws Exception &#123; if (size == 0) &#123; throw new Exception(\"表为空\"); &#125; checkInvalid(index); if (index == 0) &#123; // 如果是删除第一个位置 if (hasHeadNode) &#123; if (head.next.next == null) &#123; // 如果索引为 1 的位置的节点为空，代表只有一个节点 head.next = null; // 直接将头节点的指针指向空 &#125; else &#123; head.next = head.next.next; // 直接头结点的指针指向索引为 1 的位置的节点 &#125; &#125; else &#123; if (head.next == null) &#123; // 如果索引为 1 的位置的节点为空，代表只有一个节点 head = null; // 直接将头指针指向空 &#125; else &#123; head = head.next; // 直接头指针指向索引为 1 的位置的节点 &#125; &#125; &#125; else &#123; Node&lt;T&gt; preNode = getNode(index - 1);// 得到前一个节点的指针 preNode.next = preNode.next.next; // 将前一个节点的指针指向后一个 &#125; size--; &#125; 清空整张表清空的只要把头结点指向空就行。1234567891011/** * 清空整张表 */public void clear() &#123; this.size = 0; if (hasHeadNode) &#123; head.next = null; // 头结点的指针指向空 &#125; else &#123; head = null; // 头指针指向空 &#125;&#125; 和顺序表的比较 总结从整个算法来说，我们很容易推导出：单链表的插入和删除的时间复杂度都是 O(n)。如果在我们不知道第i个结点的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但如果，我们希望从第i个位置，插入 10 个结点，对于顺序存储结构意味着，每一次插入都需要移动 n-i 个结点，每次都是 O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为 O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。 显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。","categories":[{"name":"从零开始的数据结构系列","slug":"从零开始的数据结构系列","permalink":"https://luwenjie.me/categories/从零开始的数据结构系列/"}],"tags":[]},{"title":"Re：从零开始的设计模式 5 - 外观模式(Facade Pattern)","slug":"从零开始的设计模式5-外观模式","date":"2017-01-06T12:24:00.000Z","updated":"2017-01-21T09:51:02.000Z","comments":true,"path":"2017/01/06/从零开始的设计模式5-外观模式/","link":"","permalink":"https://luwenjie.me/2017/01/06/从零开始的设计模式5-外观模式/","excerpt":"外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。","text":"外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 模式结构 Facade: 外观角色 SubSystem: 子系统 模式结构图和时序图： 举个栗子手机就是一个外观模式的例子，它集合了电话，音乐，视频，拍照等功能于一身。我们并不需要打电话用固话，听音乐用用 MP3，定位用 GPS 定位器，看视频用 DVD，拍照用相机。完成这些功能只需要在一部手机即可。手机就是一个统一的入口。 你只要买一部 iPhone 7 就可以使用所有的功能：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990interface Phone &#123; void call(); &#125; interface Camera &#123; void takePhoto(); &#125; interface Gps &#123; void location(); &#125; interface Video &#123; void play(); &#125; interface Music &#123; void play(); &#125; class IPhone7 &#123; Phone mPhone; Camera mCamera; Gps mGps; Music mMusic; Video mVideo; public IPhone7() &#123; mPhone = new PhoneImp(); mCamera = new CameraImp(); mGps = new GpsImp(); mMusic = new MusicImp(); mVideo = new VideoImp(); &#125; void phone() &#123; mPhone.call(); &#125; void takePhoto() &#123; mCamera.takePhoto(); &#125; void loaction() &#123; mGps.location(); &#125; void playMusic() &#123; mMusic.play(); &#125; void playVideo() &#123; mVideo.play(); &#125; &#125; class PhoneImp implements Phone &#123; @Override public void call() &#123; Log.d(TAG, \"PhoneImp-call()\"); &#125; &#125; class CameraImp implements Camera &#123; @Override public void takePhoto() &#123; Log.d(TAG, \"CameraImp-takePhoto()\"); &#125; &#125; class GpsImp implements Gps &#123; @Override public void location() &#123; Log.d(TAG, \"GpsImp-location()\"); &#125; &#125; class MusicImp implements Music &#123; @Override public void play() &#123; Log.d(TAG, \"MusicImp-play()\"); &#125; &#125; class VideoImp implements Video &#123; @Override public void play() &#123; Log.d(TAG, \"VideoImp-play()\"); &#125; &#125;","categories":[{"name":"从零开始的设计模式系列","slug":"从零开始的设计模式系列","permalink":"https://luwenjie.me/categories/从零开始的设计模式系列/"}],"tags":[{"name":"外观模式","slug":"外观模式","permalink":"https://luwenjie.me/tags/外观模式/"}]},{"title":"Re：从零开始的数据结构 1 - 顺序表","slug":"从零开始的数据结构1-顺序表","date":"2017-01-06T12:23:00.000Z","updated":"2017-01-21T09:51:05.000Z","comments":true,"path":"2017/01/06/从零开始的数据结构1-顺序表/","link":"","permalink":"https://luwenjie.me/2017/01/06/从零开始的数据结构1-顺序表/","excerpt":"顺序表属于线性表的一种实现。","text":"顺序表属于线性表的一种实现。 线性表 ADT一般有这些： 求元素个数 插入 删除 查找 判断是否为空 根据这个我们设计一个抽象的线性表接口 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Author/Date: venjerLu / 2017/1/6 14:41 * Email: alwjlola@gmail.com * Description: 线性表抽象数据类型接口 */public interface MyList&lt;T&gt; &#123; /** * 获得线性表的长度 */ int size(); /** * 判断线性表是否为空 */ boolean isEmpty(); /** * 在指定位置插入元素 * * @param index 元素索引 * @param obj 元素实例 */ void insert(int index, T obj) throws Exception; /** * 删除指定的元素 * * @param index 元素的索引 */ void delete(int index) throws Exception; /** * 得到指定的元素 * * @param index 元素的索引 * @return Object */ T get(int index) throws Exception; /** * 在最后一位插入 * @param t 元素 */ void add(T t) throws Exception;&#125; 顺序表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293** * Author/Date: venjerLu / 2017/1/6 14:48 * Email: alwjlola@gmail.com * Description: 顺序表的实现 */public class SequenceList&lt;T&gt; implements MyList&lt;T&gt; &#123; private final int defaultSize = 10; // 默认顺序表的长度 private int maxSize; // 最大长度 private int size; // 当前长度 private T[] elements; // 元素数组 public SequenceList() &#123; init(defaultSize); &#125; public SequenceList(int maxSize) &#123; init(maxSize); &#125; /** * 初始化顺序表 * * @param size 最大长度 */ @SuppressWarnings(\"unchecked\") private void init(int size) &#123; maxSize = size; this.size = 0; elements = (T[]) new Object[maxSize]; &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public void insert(int index, T obj) throws Exception &#123; if (size == maxSize) &#123; // TODO: 2017/1/6 动态增加数组的大小 throw new Exception(\"顺序表已满，无法插入\"); &#125; if (index &lt; 0 || index &gt; size) &#123; throw new Exception(\"index 非法\"); &#125; // 从 index 开始所有的元素往后一位, 从表尾开始遍历 for (int j = size - 1; j &gt;= index; j++) &#123; // 将前一个值赋值给后一位 elements[j + 1] = elements[j]; &#125; elements[index] = obj; size++; &#125; @Override public void delete(int index) throws Exception &#123; if (isEmpty()) &#123; throw new Exception(\"书序表为空，无法删除\"); &#125; if (index &lt; 0 || index &gt; size) &#123; throw new Exception(\"index 非法\"); &#125; // 从 index 开始所有的元素往前移一位, 从表尾开始遍历 for (int i = size - 1; i &gt;= index; i++) &#123; // 将后一个元素的值赋值给前一个元素。 elements[i] = elements[i + 1]; &#125; elements[size - 1] = null; // 将最后一个元素值置为空。 size--; &#125; @Override public T get(int index) throws Exception &#123; if (index &lt; 0 || index &gt; size) &#123; throw new Exception(\"index 非法\"); &#125; if (isEmpty()) &#123; throw new Exception(\"list is null\"); &#125; return elements[index]; &#125; @Override public void add(T t) throws Exception &#123; if (size == maxSize) &#123; // TODO: 2017/1/6 动态增加数组的大小 throw new Exception(\"顺序表已满，无法插入\"); &#125; elements[size] = t; size++; &#125;&#125;","categories":[{"name":"从零开始的数据结构系列","slug":"从零开始的数据结构系列","permalink":"https://luwenjie.me/categories/从零开始的数据结构系列/"}],"tags":[]},{"title":"Re：从零开始的设计模式 4 - 装饰模式(Decorator Pattern)","slug":"从零开始的设计模式4-装饰模式","date":"2017-01-06T12:21:00.000Z","updated":"2017-01-21T09:50:58.000Z","comments":true,"path":"2017/01/06/从零开始的设计模式4-装饰模式/","link":"","permalink":"https://luwenjie.me/2017/01/06/从零开始的设计模式4-装饰模式/","excerpt":"装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。","text":"装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。 模式结构 Component: 抽象构件 ConcreteComponent: 具体构件 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类 UML 时序图 举个栗子变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。 代码分析通用模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void client() &#123; // 构造被装饰的组件对象，在此组件上增加 A B 两种功能块 Component component = new ConcreteComponent(); //增加 A 功能 ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component); concreteDecoratorA.operate(); //增加 B 功能 ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(component); concreteDecoratorB.operate(); &#125; abstract class Component &#123; abstract void operate(); &#125; class ConcreteComponent extends Component &#123; @Override void operate() &#123; Log.d(TAG, \"ConcreteComponent - operate()\"); &#125; &#125; /** * 抽象装饰者类 */ abstract class Decorator extends Component &#123; private Component mComponent; /** * @param component Component 对象 */ public Decorator(Component component) &#123; mComponent = component; &#125; /** * 实际操作由传入的组件来实施 */ @Override void operate() &#123; mComponent.operate(); &#125; &#125; /** * 装饰者具体实现类 A */ class ConcreteDecoratorA extends Decorator &#123; /** * @param component Component 对象 */ public ConcreteDecoratorA(Component component) &#123; super(component); &#125; /** * 在父类操作前后加上自己的操作 */ @Override void operate() &#123; operateA(); super.operate(); operateB(); &#125; private void operateA() &#123; Log.d(TAG, \"ConcreteDecoratorA operateA\"); &#125; private void operateB() &#123; Log.d(TAG, \"ConcreteDecoratorA operateB\"); &#125; &#125; /** * 装饰者具体是实现类 B */ class ConcreteDecoratorB extends Decorator &#123; /** * @param component Component 对象 */ public ConcreteDecoratorB(Component component) &#123; super(component); &#125; /** * 在父类操作前后加上自己的操作 */ @Override void operate() &#123; operateA(); super.operate(); operateB(); &#125; private void operateA() &#123; Log.d(TAG, \"ConcreteDecoratorB operateA\"); &#125; private void operateB() &#123; Log.d(TAG, \"ConcreteDecoratorB operateB\"); &#125; &#125; 12345678// 日志打印ConcreteDecoratorA operateAConcreteComponent - operate()ConcreteDecoratorA operateBConcreteDecoratorB operateAConcreteComponent - operate()ConcreteDecoratorB operateB 变形金刚的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void clientTransformer()&#123; // 汽车形态 Transformer car = new Car(); //变形成汽车人形态 Robot robot = new Robot(car); robot.move(); robot.say(); //变形成飞机形态 Airplane airplane = new Airplane(car); airplane.move(); airplane.fly(); &#125; /** * 抽象变形者 */ abstract class Transformer &#123; /** * 无论变成汽车还是其他形态都会移动 */ abstract void move(); &#125; /** * 原本的形态是汽车，基本功能 */ class Car extends Transformer &#123; @Override void move() &#123; Log.d(TAG, \"移动\"); &#125; &#125; /** * 抽象出变形系统的功能 */ abstract class Changer extends Transformer &#123; private Transformer mTransformer; public Changer(Transformer transformer) &#123; mTransformer = transformer; &#125; @Override void move() &#123; mTransformer.move(); &#125; &#125; class Robot extends Changer &#123; public Robot(Transformer transformer) &#123; super(transformer); &#125; /** * 边移动边说话 */ @Override void move() &#123; super.move(); say(); &#125; private void say() &#123; Log.d(TAG, \"变成汽车人后说话\"); &#125; &#125; class Airplane extends Changer &#123; public Airplane(Transformer transformer) &#123; super(transformer); &#125; @Override void move() &#123; super.move(); &#125; private void fly() &#123; Log.d(TAG, \"变成飞机后飞翔\"); &#125; &#125; 1234567//日志打印移动变成汽车人后说话变成汽车人后说话移动变成飞机后飞翔 适用环境 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销。 总结装饰模式和代理模式有点类似，常常将装饰看做代理。","categories":[{"name":"从零开始的设计模式系列","slug":"从零开始的设计模式系列","permalink":"https://luwenjie.me/categories/从零开始的设计模式系列/"}],"tags":[{"name":"装饰模式","slug":"装饰模式","permalink":"https://luwenjie.me/tags/装饰模式/"}]},{"title":"Re：从零开始的设计模式 3 - 适配器模式(Adapter Pattern)","slug":"从零开始的设计模式3-适配器模式","date":"2017-01-06T12:19:00.000Z","updated":"2017-01-21T09:50:54.000Z","comments":true,"path":"2017/01/06/从零开始的设计模式3-适配器模式/","link":"","permalink":"https://luwenjie.me/2017/01/06/从零开始的设计模式3-适配器模式/","excerpt":"适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。","text":"适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 适配器模式有对象适配器和类适配器两种实现。 模式结构 Target：目标抽象接口，期待得到的接口。 Adapter：适配器 Adaptee：适配者，需要适配的接口。 Client：客户类 举个栗子笔记本电脑的电源一般是 5 v，但是插座电压是 220 v，这时候就需要一个电源适配器。将 220 v 转化为 5 v。笔记本电源就是 Target，插座电压就是 Adaptee，电源适配器就是 Adapter。 UML对象适配器： 类适配器： 时序图 代码示例类适配器1234567891011121314151617181920212223242526272829303132333435/** * 客户端调用类适配器 */void testClassAdapter() &#123; VAdapter adapter = new VAdapter(); Log.d(TAG, \"输出电压 = \" + adapter.get5V());&#125;/** * Target * 5v 电压 */interface V5 &#123; int get5V();&#125;/** * Adaptee * 220V 电压 */class V220 &#123; int getV() &#123; return 220; &#125;&#125;/** * 电源适配器 */class VAdapter extends V220 implements V5 &#123; @Override public int get5V() &#123; return 5; &#125;&#125; 对象适配器 对象的适配器不是使用继承关系连接到 Adaptee 对象，而是使用代理关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 对象适配器模式 */class VObjectAdapter implements V5 &#123; V220 mV220; public VObjectAdapter(V220 v220) &#123; mV220 = v220; &#125; public int getvV220() &#123; return mV220.getV(); &#125; @Override public int get5V() &#123; return 5; &#125;&#125;/** * Target * 5v 电压 */interface V5 &#123; int get5V();&#125;/** * Adaptee * 220V 电压 */class V220 &#123; int getV() &#123; return 220; &#125;&#125;/** * 客户端调用对象适配器 */void testObjectAdapter() &#123; V220 v220 = new V220(); VObjectAdapter objectAdapter = new VObjectAdapter(v220); Log.d(TAG, \"输出电压 = \" + objectAdapter.get5V())&#125; 类适配器模式和对象适配器模式的区别对象适配器将要适配的对象传到 Adapter 中，使用组合的形式实现接口兼容的效果，比类适配器更加灵活。 类适配器由于继承了被适配的对象，可以调用被适配的对象的所有暴露的方法，使用起来比较混乱。","categories":[{"name":"从零开始的设计模式系列","slug":"从零开始的设计模式系列","permalink":"https://luwenjie.me/categories/从零开始的设计模式系列/"}],"tags":[{"name":"适配器模式","slug":"适配器模式","permalink":"https://luwenjie.me/tags/适配器模式/"}]},{"title":"记一次 ScrollView 嵌套 RecyclerView 的坑","slug":"记一次 ScrollView 嵌套 RecyclerView 的坑","date":"2017-01-06T09:50:00.000Z","updated":"2017-01-21T09:51:08.000Z","comments":true,"path":"2017/01/06/记一次 ScrollView 嵌套 RecyclerView 的坑/","link":"","permalink":"https://luwenjie.me/2017/01/06/记一次 ScrollView 嵌套 RecyclerView 的坑/","excerpt":"我在一个 ScrollerView 中嵌套了 2 个横向的 RecyclerView。结果每次点击这个页面初始化的时候，ScrollView 总是不在最顶端。而是在 RecyclerView 的顶端位置。","text":"我在一个 ScrollerView 中嵌套了 2 个横向的 RecyclerView。结果每次点击这个页面初始化的时候，ScrollView 总是不在最顶端。而是在 RecyclerView 的顶端位置。 类似于这种情况： 原因Google 发现是 RecyclerView 抢了焦点。这种现象是因为 ScrollView 里的控件抢夺到了焦点导致的，控件抢到焦点以后，ScrollView 会滚动到抢到焦点的控件的位置。 注：能够获取焦点的控件很多，例如 ListView、RecyclerView 等等…… 解决方法 解决方法很简单，取消控件的焦点即可mRecyclerView.setFocusable(false);","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"qxt","slug":"qxt","permalink":"https://luwenjie.me/tags/qxt/"}]},{"title":"Re：从零开始的设计模式 2 - 代理模式(Proxy Pattern)","slug":"从零开始的设计模式2-代理模式","date":"2017-01-01T15:40:00.000Z","updated":"2017-01-24T13:45:35.000Z","comments":true,"path":"2017/01/01/从零开始的设计模式2-代理模式/","link":"","permalink":"https://luwenjie.me/2017/01/01/从零开始的设计模式2-代理模式/","excerpt":"给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。","text":"给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。 举个栗子我们在国内想要访问谷歌，必须走代理。这就是一个典型的场景。过程如下： 用户把 Http 请求发给代理 代理把 Http 请求发给谷歌服务器 服务器把 Http 响应发给代理 代理把 Http 响应发回用户 然后我们就能愉快的 Google 了。 怎样用代码实现？抽象代理接口, 代理者与被代理者都需要实现此接口123public interface Subject &#123; void request(); &#125; 代理者12345678910111213class Proxy implements Subject &#123; private Subject mSubject; public Proxy(Subject subject) &#123; mSubject = subject; &#125; @Override public void request() &#123; Log.d(TAG, \"Proxy - requestStart\"); mSubject.request(); Log.d(TAG, \"Proxy - requestFinish\"); &#125; &#125; 被代理者123456class RealSubject implements Subject &#123; @Override public void request() &#123; Log.d(TAG, \"RealSubject - request\"); &#125; &#125; 调用123RealSubject realSubject = new RealSubject();Proxy proxy = new Proxy(realSubject);proxy.request(); 执行上述代码打印日志结果如下：123Proxy - requestStartRealSubject - requestProxy - requestFinish 代理的分类上述的代理属于静态代理。 静态代理：在运行前代理类的 class 编译文件就已经存在。 动态代理：通过反射机制动态的生成代理者的对象，在运行时动态的生成类字节码加载到 JVM 中。 Java 动态代理什么是动态代理？ Java动态代理就是给了程序员一种可能：当你要调用某个 Class 的方法前或后，插入你想要执行的代码。比如你要执行某个操作前，你必须要判断这个用户是否登录，或者你在付款前，你需要判断这个人的账户中存在这么多钱。这么简单的一句话，我相信可以把一个不懂技术的人也讲明白 Java 动态代理是什么东西了。 步骤 定义一个委托类和公共接口 定义一个实现 InvocationHandler 接口的调用处理器类。代理类调用任何方法都会经过这个调用处理器类。 生成代理类和它的实例。 代码实现12345678910111213141516171819202122232425interface Subject &#123; void request(); &#125; class ProxyHandler implements InvocationHandler &#123; private Subject mSubject; public ProxyHandler(Subject subject) &#123; mSubject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.d(TAG, \"invoke before\"); Object invoke = method.invoke(mSubject, args); Log.d(TAG, \"invoke end\"); return invoke; &#125; &#125; class RealSubject implements Subject &#123; @Override public void request() &#123; Log.d(TAG, \"RealSubject - request\"); &#125; &#125; 客户端调用：12345678RealSubject realSubject = new RealSubject();ProxyHandler handler = new ProxyHandler(realSubject);Subject proxy = (Subject) Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler);proxy.request(); 参考资料代理模式及Java实现动态代理","categories":[{"name":"从零开始的设计模式系列","slug":"从零开始的设计模式系列","permalink":"https://luwenjie.me/categories/从零开始的设计模式系列/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://luwenjie.me/tags/设计模式/"}]},{"title":"Re：从零开始的设计模式 1 - 建造者模式(Builder Pattern)","slug":"从零开始的设计模式1-建造者模式","date":"2017-01-01T15:39:00.000Z","updated":"2017-01-21T09:50:42.000Z","comments":true,"path":"2017/01/01/从零开始的设计模式1-建造者模式/","link":"","permalink":"https://luwenjie.me/2017/01/01/从零开始的设计模式1-建造者模式/","excerpt":"新年第一天，从零开始系列计划开始启动，今年的时光决定都花在写博客上，反正不写也没事干，时间还是啪啪啪的流逝了。虽然文笔很烂，尽量把自己的理解写出来，也方便日后复习。","text":"新年第一天，从零开始系列计划开始启动，今年的时光决定都花在写博客上，反正不写也没事干，时间还是啪啪啪的流逝了。虽然文笔很烂，尽量把自己的理解写出来，也方便日后复习。 定义 建造者模式将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。 顾名思义，建造者模式，就是有一个建造者专门负责设置一些参数。 它有什么好处？建造者模式构建复杂对象就像造汽车一样，是一个一个组件一个一个步骤创建出来的，它允许用户通过制定的对象类型和内容来创建他们，但是用户并不需要知道这个复杂对象是如何构建的，它只需要明白通过这样做我可以得到一个完整的复杂对象实例。 模式结构有 4 个角色来完成这种模式，他们分别是： 抽象建造者：给出模板方法来建造一类东西 具体建造者：根据模板建造具体的型号，具体的配置 实施者：操作建造者对象 要建造的对象：最终建造的对象 举个栗子我们要生产一部 Mac，Mac 有很多零件。我们的抽象建造者就是电脑的设计图，具体建造者就是 Mac 独有的一些设计，比如视网膜屏幕，macOS 系统，type-c 接口。实施者就是工人，一个开关流水线机器人就运作了。最后要建造的对象当然是 Mac 了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MacBookPro extends Computer&#123; int part1; int part2; int part3; public void setPart1(int part1) &#123; this.part1 = part1; &#125; public void setPart2(int part2) &#123; this.part2 = part2; &#125; public void setPart3(int part3) &#123; this.part3 = part3; &#125; public static class Builder &#123; MacBookPro mMacBookPro; public Builder() &#123; mMacBookPro = new MacBookPro(); &#125; public Builder setPart1(int part1) &#123; mMacBookPro.setPart1(part1); return this; &#125; public Builder setPart2(int part2) &#123; mMacBookPro.setPart2(part2); return this; &#125; public Builder setPart3(int part3) &#123; mMacBookPro.setPart2(part3); return this; &#125; public MacBookPro build() &#123; return mMacBookPro; &#125; &#125;/*工人*/public static class Worker &#123; private Builder mBuilder; public Worker() &#123; mBuilder = new Builder(); &#125; public MacBookPro buildMac() &#123; return mBuilder.setPart1(1).setPart2(2).setPart3(3).build(); &#125; &#125;&#125; 调用的时候这样写： 123// 让工人去工作生产一部 macMacBookPro.Worker worker = new MacBookPro.Worker();MacBookPro macBookPro = worker.buildMac(); 在实际开发中一般会省去实施者这个角色。 源码中的例子比如在 Android 的源码中，创建一个 Dialog 的时候是这样的： 12345AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setCustomTitle(); builder.setIcon(); builder.setItems(); AlertDialog show = builder.show(); 还有我们 Android 日常开发常用的 OkHttp 和 Retrofit，在初始化的时候都会 new 一个 Builder 来设置一些参数。 Retrofit 示例：12345mRetrofit = new Retrofit.Builder().client(okHttpClient) .baseUrl(Constants.BASE_URL) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create(gson)) .build(); 这种链式的写法特别方便。 要满足链式调用每个方法都要返回 Builder 对象。 简单贴一下 Retrofit.Builder 的源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 省去了若干代码public static final class Builder &#123; private Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; /* 构造方法初始化一些参数 */ Builder(Platform platform) &#123; this.platform = platform; consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; public Builder client(OkHttpClient client) &#123; return callFactory(checkNotNull(client, \"client == null\")); &#125; public Builder baseUrl(String baseUrl) &#123; // 省去若干代码。。。 return baseUrl(httpUrl); &#125; public Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(checkNotNull(factory, \"factory == null\")); return this; &#125; public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123; adapterFactories.add(checkNotNull(factory, \"factory == null\")); return this; &#125; public Retrofit build() &#123; // 省去若干代码。。。 return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; &#125; 对比我们生产 Mac 的例子，其实大同小异。 优缺点 优点：开头已经说了，也就是将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰。 缺点：只适合生成共同的较多的对象。而且不适合内部过于庞大和复杂的产品。 适用场景当一个对象拥有复杂的内部结构，比如上面的 Retrofit，生存过程有很多细节，需要设置baseUrl，设置okHttpClient, 设置各种自定义的XxxFactory()。每个建造者都是独立的，可以按需设置，不设置的内部一般会有一个默认值。 总结建造者模式将创建过程与产品本身隔离。外部不需要关心内部的生成过程。我买一台 Mac，我不需要关心 Mac 是咋造出来的。我有钱就可以买到一台 Mac，就这么简单。 参考资料设计模式读书笔记—–建造者模式 理解设计模式之原型模式、建造者模式 Android 源码设计模式解析与实战","categories":[{"name":"从零开始的设计模式系列","slug":"从零开始的设计模式系列","permalink":"https://luwenjie.me/categories/从零开始的设计模式系列/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://luwenjie.me/tags/设计模式/"}]},{"title":"Scroller 学习笔记","slug":"Scroller 学习笔记","date":"2016-12-31T06:46:00.000Z","updated":"2017-01-21T09:51:57.000Z","comments":true,"path":"2016/12/31/Scroller 学习笔记/","link":"","permalink":"https://luwenjie.me/2016/12/31/Scroller 学习笔记/","excerpt":"Android 里面各式各样的滑动效果都是由一个小精灵协助完成的，它就是 Scroller！","text":"Android 里面各式各样的滑动效果都是由一个小精灵协助完成的，它就是 Scroller！ 主要内容 scrollTo() 和 scrollBy() Scroller 原理解析 Scroller 应用示例 View 的 scrollTo() 和 scrollBy()int mScrollX , int mScrollY 移动的是 View 的内容。123public void scrollBy(int x, int y)&#123; scrollTo(mScrollX + x, mScrollY + y);&#125; mScrollX mScrollY 分别表示 View 在 X，Y 轴方向滚动的距离 scrollTo()表示 View 相对于其初始位置滚动某段距离 scrollBy() 在上一次滚动的基础之上继续滚动。 scrollTo(x,y) 。通过查看 View 的绘制代码可以知道。x &gt; 0 ，View 的内容左移，反之右移y &gt; 0 ，View 的内容上移，反之下移 Scroller 的使用步骤 初始化 Scroller ，可以指定 一个差值器。 调用 startScroll() 开始滚动 执行 invalidate() 刷新界面 重写 View 的 computeScroll() 并在其内部实现与滚动相关的业务逻辑 再次执行 invalidate() 刷新界面 初始化12345678910111213public Scroller(Context context, Interpolator interpolator, boolean flywheel) &#123; mFinished = true; if (interpolator == null) &#123; mInterpolator = new ViscousFluidInterpolator(); &#125; else &#123; mInterpolator = interpolator; &#125; mPpi = context.getResources().getDisplayMetrics().density * 160.0f; mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction()); mFlywheel = flywheel; mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning &#125; 在构造函数中给插值器等变量赋值。 调用 startScroll()我们来看一下源码。1234567891011121314/*根据提供的滑动的起始位置的坐标，和滑动的距离以及滑动的时间进行赋值*/public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; mMode = SCROLL_MODE; mFinished = false; mDuration = duration; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; mFinalX = startX + dx; mFinalY = startY + dy; mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float) mDuration; &#125; 调用 invalidate() 刷新界面在调用 invalidate() 后会导致 View 的重绘从而调用 computeScroll() 重写 View 的 computeScroll() 并在其内部实现与滚动相关的业务逻辑这个方法在 View 里面，是个空方法。12345678/** * Called by a parent to request that a child update its values for mScrollX * and mScrollY if necessary. This will typically be done if the child is * animating a scroll using a &#123;@link android.widget.Scroller Scroller&#125; * object. */ public void computeScroll() &#123; &#125; 翻译一下注释：这个方法被父类调用来更新子类的 mScrollX 和 mScrollY 的值。如果子类是使用 android.widget.Scroller Scroller 对象来创建一个滑动效果的话，典型就会这样做。 如果使用 Scroller 使得 View 发生滚动，那么可以在该方法中处理与滑动相关的业务和数据，比如调用scrollTo() 或者scrollBy() 使得View发生滚动；比如获取变量 mScrollX、mScrollY、mCurrX、mCurrY 的值。在此有一点需要注意，在处理这些业务和数据之前我们通常需要先利用 computeScrollOffset() 判断一下滑动是否停止然后再进行相关操作。 再次执行 invalidate() 刷新界面在处理完与滑动相关的业务和数据后，再次调用invalidate() 刷新界面。既然刷新了界面，那么又将导致 View 的重绘，故又将调用到第四步的computeScroll() 方法。所以只要 View 的滚动没有完成或者未被人为的终止，那么第四步和第五步会一直循环进行。 小结不是 Scroller 让 View 发生了滚动而是 View 自己在滚蛋。Scroller 只是相当于一个辅助者，提供滚动的所有信息。 梳理一下流程： 示例在拉动页面后松手，页面弹回到原来的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class ElasticityRelativeLayout extends RelativeLayout &#123; static final String TAG = \"ElasticityRelativeLayout\"; private Scroller mScroller; private GestureDetector mGestureDetector; public ElasticityRelativeLayout(Context context) &#123; super(context); init(context); &#125; public ElasticityRelativeLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ElasticityRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public ElasticityRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); init(context); &#125; private void init(Context context) &#123; setClickable(true); setLongClickable(true); mScroller = new Scroller(context); mGestureDetector = new GestureDetector(context, new GestureListenerImpl()); &#125; private void beginScroll(int dx, int dY) &#123; mScroller.startScroll(mScroller.getFinalX(), mScroller.getFinalY(), dx, dY); invalidate(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: reset(0, 0); break; default: return mGestureDetector.onTouchEvent(event); &#125; return super.onTouchEvent(event); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate(); &#125; super.computeScroll(); &#125; protected void reset(int x, int y) &#123; int dx = x - mScroller.getFinalX(); int dy = y - mScroller.getFinalY(); beginScroll(dx, dy); &#125; class GestureListenerImpl implements GestureDetector.OnGestureListener &#123; @Override public boolean onDown(MotionEvent e) &#123; return true; &#125; @Override public void onShowPress(MotionEvent e) &#123; &#125; @Override public boolean onSingleTapUp(MotionEvent e) &#123; return false; &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; int disY = (int) (distanceY/2.4); if (disY&lt;0) beginScroll(0, disY); return false; &#125; @Override public void onLongPress(MotionEvent e) &#123; &#125; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; return false; &#125; &#125;&#125; 参考资料全解Scroller工作机制-有心课堂","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://luwenjie.me/tags/学习笔记/"}]},{"title":"Hexo s Cannot GET / 问题","slug":"Hexo s Cannot GET : 问题","date":"2016-12-28T09:15:00.000Z","updated":"2017-01-21T09:51:30.000Z","comments":true,"path":"2016/12/28/Hexo s Cannot GET : 问题/","link":"","permalink":"https://luwenjie.me/2016/12/28/Hexo s Cannot GET : 问题/","excerpt":"在 Mac 上搭建 hexo 时，执行到 hexo s 后，访问localhost:4000 出现 Cannot GET /","text":"在 Mac 上搭建 hexo 时，执行到 hexo s 后，访问localhost:4000 出现 Cannot GET / 解决方法hexo init 之后需要执行 npm intall 完整步骤示例npm install hexo-cli -ghexo init blogcd blognpm installhexo server","categories":[{"name":"hexo","slug":"hexo","permalink":"https://luwenjie.me/categories/hexo/"}],"tags":[]},{"title":"String, StringBuffer 与 StringBuilder 的区别","slug":"String, StringBuffer 与 StringBuilder 的区别","date":"2016-12-28T06:37:00.000Z","updated":"2017-01-21T09:52:01.000Z","comments":true,"path":"2016/12/28/String, StringBuffer 与 StringBuilder 的区别/","link":"","permalink":"https://luwenjie.me/2016/12/28/String, StringBuffer 与 StringBuilder 的区别/","excerpt":"比较基础的 Java 知识，记录一下。","text":"比较基础的 Java 知识，记录一下。 String 字符串常量 StringBuffer 字符串变量 （线程安全） StringBuilder 字符串变量 （非线程安全） String 的缺点String 是不可变的对象， 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。 StringBuffer 对比 String字符串对象经常改变的情况而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。 同一个字符串对象字符串拼接的情况而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：12String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。 其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”;所以当然不需要太多的时间了。 但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：1234String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做。 在大部分情况下 StringBuffer &gt; StringJava.lang.StringBuffer 线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是 “start” 的字符串缓冲区对象，则此方法调用 z.append(&quot;le&quot;) 会使字符串缓冲区包含 “startle” ，而 z.insert(4, &quot;le&quot;)将更改字符串缓冲区，使之包含“starlet”。 在大部分情况下 StringBuilder &gt; StringBufferjava.lang.StringBuilder 一个可变的字符序列是 5.0 新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer要快。两者的方法基本相同。","categories":[{"name":"Java","slug":"Java","permalink":"https://luwenjie.me/categories/Java/"}],"tags":[]},{"title":"避免 Android 的冷启动","slug":"避免-Android-的冷启动","date":"2016-12-21T06:49:34.000Z","updated":"2017-01-21T09:50:39.000Z","comments":true,"path":"2016/12/21/避免-Android-的冷启动/","link":"","permalink":"https://luwenjie.me/2016/12/21/避免-Android-的冷启动/","excerpt":"冷启动时间是指当用户点击你的 app 那一刻到系统调用 Activity.onCreate() 之间的时间段。在这个时间段内，WindowManager 会先加载 app 主题样式中的 windowBackground 做为 app 的预览元素，然后再真正去加载 activity 的 layout 布局","text":"冷启动时间是指当用户点击你的 app 那一刻到系统调用 Activity.onCreate() 之间的时间段。在这个时间段内，WindowManager 会先加载 app 主题样式中的 windowBackground 做为 app 的预览元素，然后再真正去加载 activity 的 layout 布局 冷启动优化windowBackground 这个属性只能指定一个颜色, 或者 drawable 文件, 但是图片是全屏的, 无法居中. 我们可以用&lt;layer-list&gt; 标签来设置一个 bitmap 让图片居中 .123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt; &lt;item android:drawable=\"@color/grey\"/&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@drawable/img_pizza\"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 为了避免出现问题, &lt;layer-list&gt; 必须设置为不透明的, android:opacity=&quot;opaque&quot;. 参考资料 avoding-android-cold-starts Android 冷启动时间优化","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"冷启动","slug":"冷启动","permalink":"https://luwenjie.me/tags/冷启动/"}]},{"title":"初识 Dagger2","slug":"初识 dagger","date":"2016-12-21T06:00:00.000Z","updated":"2017-01-21T09:50:40.000Z","comments":true,"path":"2016/12/21/初识 dagger/","link":"","permalink":"https://luwenjie.me/2016/12/21/初识 dagger/","excerpt":"使用 Dagger2 配合 RxJava 和 MVP 能更加方便解耦代码。这么高大上的框架，是时候学习一下了。","text":"使用 Dagger2 配合 RxJava 和 MVP 能更加方便解耦代码。这么高大上的框架，是时候学习一下了。 Dagger2 官方文档 参考资料：滴滴牛小伟 dagger2让你爱不释手-基础依赖注入框架篇滴滴牛小伟 dagger2让你爱不释手-重点概念讲解、融合篇滴滴牛小伟 dagger2让你爱不释手-终结篇 声明依赖用 @Inject 声明你需要注入的类的构造，并声明你在哪个地方需要一个这个实例。 123456789101112131415161718class Thermosiphon implements Pump &#123; private final Heater heater; @Inject Thermosiphon(Heater heater) &#123; this.heater = heater; &#125; ...&#125;/*--------------------------------------*/class CoffeeMaker &#123; @Inject Heater heater; @Inject Pump pump; ...&#125; 如果你注明了你在哪需要注入一个实例，但是没有注明构造函数： 12345678class A &#123; @Inject B b;&#125;class B &#123; public B()&#123;&#125;&#125; Dagger2 会注入那些字段，但是不会创建新的实例。 用 @Inject 注解一个无参构造函数，Dagger2 可以创建实例。 Dagger2 还支持方法注入， 一般优先考虑字段和构造器注入。 缺少 @Inject 注释的类不能由 Dagger 构造。 满足依赖@Inject 有一定的局限性 无法构建接口。 第三方类不能注释。 必须配置可配置对象！ 所以我们使用 @Module 和 @Provide 来代替。 12345678910@Moduleclass DripCoffeeModule &#123; @Provides static Heater provideHeater() &#123; return new ElectricHeater(); &#125; @Provides static Pump providePump(Thermosiphon pump) &#123; return pump; &#125;&#125; 按照惯例，@Provides 注解的方法用provideXxx() 命名，而 @Module 注解的类用 class XxxModule命名。 Building Graph (构建组件)@Inject注解的字段和 @Provide注解的类构成一个对象的映射图，通过依赖关系链接。 在应用程序的主方法中通过明确定义好的根集来访问该映射图形。 在 Dagger 2 中，该集合由具有没有参数的方法的 interface 定义，并返回所需的类型。 用 @Component 注释这样的接口 1234@Component(modules = DripCoffeeModule.class)interface CoffeeShop &#123; CoffeeMaker maker();&#125; rebuild 一下，Dagger2 会自动生成该接口的实现类，形如 DaggerCoffeeShop 以 Dagger 为前缀，后面和接口名称一样。调用该实现的 builder() 方法来得到一个建造者实例。 使用这个建造者设置依赖关系，并 build()一个实例。 123CoffeeShop coffeeShop = DaggerCoffeeShop.builder() .dripCoffeeModule(new DripCoffeeModule()) .build(); 如果 @Componet 注解的不是一个顶级类型，也就是一个内部接口。 那么生成的实现的命名会包含外部类。123456class Foo &#123; static class Bar &#123; @Component interface BazComponent &#123;&#125; &#125;&#125; 如上所示，会生成 DaggerFoo_Bar_BazCoponent 对于任何@Provides方法都是静态的模块，实现根本不需要一个实例。 如果所有依赖关系都可以在用户没有创建依赖关系实例的情况下构建，那么生成的实现也将有一个create（）方法，可用于获取一个新实例，而无需处理构建器。 如果 @Provides注解的方法是静态的，实现不需要一个实例， 生成的实现类有一个create()方法，用于获取一个实例，而不需要构造器。12345678CoffeeShop coffeeShop = DaggerCoffeeShop.create();public class CoffeeApp &#123; public static void main(String[] args) &#123; CoffeeShop coffeeShop = DaggerCoffeeShop.create(); coffeeShop.maker().brew(); &#125; &#125; Bindings in the graphSingletons and Scoped Bindings用 @Singleton 注解一个注解了@Provides的方法或者可注入的类。该组件将提供一个单例给需要注入的地方。 123@Provides @Singleton static Heater provideHeater() &#123; return new ElectricHeater();&#125; 可注入类上的@Singleton注释也用作文档。 它提醒这个类可以被多个线程共享。1234@Singletonclass CoffeeMaker &#123; ...&#125; 声明的相同的 scoped注解， 具有相同的生命周期。 12345@Component(modules = DripCoffeeModule.class)@Singletoninterface CoffeeShop &#123; CoffeeMaker maker();&#125; Reusable scopeLazy injections懒注入，需要的时候再注入。用Lazy&lt;T&gt;的形式包裹需要懒加载的对象。需要加载的时候调用 Lazy&lt;T&gt;.get()。12345678910class GridingCoffeeMaker &#123; @Inject Lazy&lt;Grinder&gt; lazyGrinder; public void brew() &#123; while (needsGrinding()) &#123; // Grinder created once on first call to .get() and cached. lazyGrinder.get().grind(); &#125; &#125;&#125; Provider injections有时你需要返回多个实例，而不是仅仅注入单个值。虽然可以用工厂模式，建造者模式，还有一个选择是注入一个 Provider&lt;T&gt;，而不是一个 T。 Provider&lt;T&gt;每次调用 get()时，会调用 T 的绑定逻辑。 如果这个绑定逻辑是一个 @Inject 构造器，会创建一个新的实例。但是如果你用 @Provider 方法不会有这样的保证。 12345678910111213class BigCoffeeMaker &#123; @Inject Provider&lt;Filter&gt; filterProvider; public void brew(int numberOfPots) &#123; ... for (int p = 0; p &lt; numberOfPots; p++) &#123; maker.addFilter(filterProvider.get()); //new filter every time. maker.addCoffee(...); maker.percolate(); ... &#125; &#125;&#125; note： 注入@Provider&lt;T&gt; 有可能创建混乱的代码。 QualifiersComponent 创建一个类实例有2种方法。 通过用Inject注解标注的构造函数来创建（以下简称Inject维度） 通过工厂模式的Module来创建（以下简称Module维度） 这2个维度是有优先级之分的，Component会首先从Module维度中查找类实例，若找到就用Module维度创建类实例，并停止查找Inject维度。否则才是从Inject维度查找类实例。所以创建类实例级别Module维度要高于Inject维度。 现在有个问题，基于同一个维度条件下，若一个类的实例有多种方法可以创建出来，那注入器（Component）应该选择哪种方法来创建该类的实例呢？ 我把上面遇到的问题起个名字叫依赖注入迷失。 Qualifier（限定符）就是解决依赖注入迷失问题的。1234567891011121314 class ExpensiveCoffeeMaker &#123; @Inject @Named(\"water\") Heater waterHeater; @Inject @Named(\"hot plate\") Heater hotPlateHeater; ... &#125;--- Provides @Named(\"hot plate\") static Heater provideHotPlateHeater() &#123; return new ElectricHeater(70); &#125; @Provides @Named(\"water\") static Heater provideWaterHeater() &#123; return new ElectricHeater(93); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://luwenjie.me/categories/Android/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://luwenjie.me/tags/学习笔记/"},{"name":"dagger2","slug":"dagger2","permalink":"https://luwenjie.me/tags/dagger2/"}]}]}