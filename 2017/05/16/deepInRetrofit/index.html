<!doctype html>




<html class="theme-next muse" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Retrofit," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="前言 Retrofit 是现在 Android 主流的网络请求库，对比 Volley 它解耦更加彻底，使用更加方便，而且支持 RxJava。具体的区别的可以看看这篇文章——OkHttp, Retrofit, Volley应该选择哪一个？。   Retrofit 中文可以翻译成 在原有基础上改进。它的底层基于 OkHttp。   Retrofit 的精简流程图，图片来自Stay：">
<meta name="keywords" content="Retrofit">
<meta property="og:type" content="article">
<meta property="og:title" content="Retrofit 源码阅读笔记">
<meta property="og:url" content="https://luwenjie.me/2017/05/16/deepInRetrofit/index.html">
<meta property="og:site_name" content="luwenjie&#39;s Blog">
<meta property="og:description" content="前言 Retrofit 是现在 Android 主流的网络请求库，对比 Volley 它解耦更加彻底，使用更加方便，而且支持 RxJava。具体的区别的可以看看这篇文章——OkHttp, Retrofit, Volley应该选择哪一个？。   Retrofit 中文可以翻译成 在原有基础上改进。它的底层基于 OkHttp。   Retrofit 的精简流程图，图片来自Stay：">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/625299-29a632638d9f518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://7xt4re.com1.z0.glb.clouddn.com/20170511149448389296485.png">
<meta property="og:image" content="http://cuntuku.com/images/2017/01/02/QQ20170102-1928262x.png">
<meta property="og:image" content="http://cuntuku.com/images/2017/01/03/QQ20170103-1341382x.png">
<meta property="og:updated_time" content="2017-05-16T03:48:07.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Retrofit 源码阅读笔记">
<meta name="twitter:description" content="前言 Retrofit 是现在 Android 主流的网络请求库，对比 Volley 它解耦更加彻底，使用更加方便，而且支持 RxJava。具体的区别的可以看看这篇文章——OkHttp, Retrofit, Volley应该选择哪一个？。   Retrofit 中文可以翻译成 在原有基础上改进。它的底层基于 OkHttp。   Retrofit 的精简流程图，图片来自Stay：">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/625299-29a632638d9f518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://luwenjie.me/2017/05/16/deepInRetrofit/"/>





  <title>Retrofit 源码阅读笔记 | luwenjie's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">luwenjie's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://luwenjie.me/2017/05/16/deepInRetrofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luwenjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="luwenjie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Retrofit 源码阅读笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-16T21:57:00+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2017/05/16/deepInRetrofit/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> Retrofit 是现在 Android 主流的网络请求库，对比 Volley 它解耦更加彻底，使用更加方便，而且支持 RxJava。具体的区别的可以看看这篇文章——<a href="http://www.jianshu.com/p/77d418e7b5d6" target="_blank" rel="external">OkHttp, Retrofit, Volley应该选择哪一个？</a>。  </p>
<p>Retrofit 中文可以翻译成 <strong>在原有基础上改进</strong>。它的底层基于 OkHttp。  </p>
<p>Retrofit 的精简流程图，图片来自Stay：<br><img src="http://upload-images.jianshu.io/upload_images/625299-29a632638d9f518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a>  </p>
<p>Retrofit 中使用了大量设计模式，分析源码之前最好先熟悉一下这些模式。    </p>
<ol>
<li>建造者模式</li>
<li>工厂模式</li>
<li>外观模式</li>
<li>策略模式</li>
<li>适配器模式</li>
<li>装饰模式</li>
<li>代理模式及 Java 动态代理</li>
</ol>
<p>还涉及一些基础的 Java 注解的知识，建议先打好基础再分析源码。</p>
<h2 id="Retrofit的类的结构"><a href="#Retrofit的类的结构" class="headerlink" title="Retrofit的类的结构"></a>Retrofit的类的结构</h2><p><img src="http://7xt4re.com1.z0.glb.clouddn.com/20170511149448389296485.png" alt=""></p>
<p>上层有4个抽象接口，有默认的实现类。核心服务类是ServiceMethod。Platform判断Android，Java平台。</p>
<h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><pre><code class="java">/**
 * 这是一个Retrofit方法给服务器发送一个request，返回一个response的调用。
 * 每个Call生产一组HTTP request和response。对于同一个完全一样请求，实现
 * clone方法来创建多个call，这个可以用于轮询和错误重试的场景。
 *
 * Calls 同步执行的时候使用 execute(), 异步执行使用 enqueue()。无论是
 * 同步还是异步都可以在请求的时候使用 cancel() 随时被取消。正在写入request或者读取response的Call可能会引起IOException。
 *
 *
 * @param &lt;T&gt; 请求成功时返回的 response body 类型
 */
public interface Call&lt;T&gt; extends Cloneable {

  // 同步发起请求返回response
  Response&lt;T&gt; execute() throws IOException;



  // 异步发起请求，结果返回给回调
  void enqueue(Callback&lt;T&gt; callback);



  // 如果call已经调用了execute()或者enqueue()就返回true。不允许一个call重复请求。
  boolean isExecuted();



  // 取消正在执行中的请求，如果call还没开始执行请求，就不做任何处理。
  void cancel();


  // 是否取消了请求
  boolean isCanceled();


  // 创建一个新的和当前完全一样的call
  Call&lt;T&gt; clone();

  // 原始的HTTP请求
  Request request();
}
</code></pre>
<h3 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h3><p>用于RxJava的转化。</p>
<pre><code class="java">public interface CallAdapter&lt;R, T&gt; {
  // 返回解析成java对象的response的类型。
  Type responseType();

  T adapt(Call&lt;R&gt; call);

  // 抽象工厂类
  abstract class Factory {

    public abstract CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,
        Retrofit retrofit);

    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
      return Utils.getParameterUpperBound(index, type);
    }

    protected static Class&lt;?&gt; getRawType(Type type) {
      return Utils.getRawType(type);
    }
  }
}
</code></pre>
<h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><pre><code class="java">public interface Callback&lt;T&gt; {

  void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response);

  void onFailure(Call&lt;T&gt; call, Throwable t);
}
</code></pre>
<h3 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h3><pre><code class="java">public interface Converter&lt;F, T&gt; {
  // 实体类和HTTP的RequestBody和ResponseBody的互相转换
  T convert(F value) throws IOException;

  // 抽象工厂
  abstract class Factory {

    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,
        Retrofit retrofit) {
      return null;
    }

    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,
        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
      return null;
    }

    public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,
        Retrofit retrofit) {
      return null;
    }
  }
}
</code></pre>
<h2 id="正常请求网络的套路"><a href="#正常请求网络的套路" class="headerlink" title="正常请求网络的套路"></a>正常请求网络的套路</h2><p><img src="http://cuntuku.com/images/2017/01/02/QQ20170102-1928262x.png" alt="QQ20170102-1928262x.png"><br>如果我们自己写一个网络请求模块一般是这样的套路：   </p>
<ol>
<li>build request 参数，加入到请求队列中</li>
<li>在子线程轮询执行</li>
<li>得到服务器数据后，回调给上层  </li>
</ol>
<p>Retrofit 不外乎也是这种套路，那么它到底有什么精妙的地方呢?</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>先看一个正常 Retrofit 请求的例子：</p>
<pre><code class="java">Retrofit build = new Retrofit.Builder().baseUrl(ServiceApi.BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build();
    ServiceApi serviceApi = build.create(ServiceApi.class);

    serviceApi.getHistoryDate().enqueue(new Callback&lt;String&gt;() {
      @Override public void onResponse(Call&lt;String&gt; call, Response&lt;String&gt; response) {
        Log.d(TAG, &quot;onResponse- &quot; + response.body());
      }

      @Override public void onFailure(Call&lt;String&gt; call, Throwable t) {
        Log.d(TAG, &quot;onFailure- &quot; + t.getMessage());
      }
    });  

/**
 * API 来自 gank.io，感谢 @代码家
 */
interface ServiceApi {
  String BASE_URL = &quot;http://gank.io/api/&quot;;
  /**
   * 获取某一天的数据
   */
  @GET(&quot;day/{year}/{month}/{day}&quot;) Call&lt;String&gt; getDataOnSomeday(
      @Path(&quot;year&quot;) String year, @Path(&quot;month&quot;) String month, @Path(&quot;day&quot;) String day);
}
</code></pre>
<p>我们通过调用 <code>serviceApi.getHistoryDate().enqueue(callback)</code> 请求数据并在回调中处理数据。<br>就从这行代码作为切入点，看看发出请求的时候到底内部发生了啥？<br>debug <code>serviceApi.getHistoryDate()</code> 这行代码我发现，运行至此的时候调用了动态代理，代码走到了下面的 <code>create(final Class&lt;T&gt; service)</code> 中的 <code>InvocationHandler() 中</code>，回调了 <code>invoke()</code>。<br><img src="http://cuntuku.com/images/2017/01/03/QQ20170103-1341382x.png" alt="QQ20170103-1341382x.png">  </p>
<p>我们来仔细分析一下这个函数。  </p>
<pre><code class="java">/**
 * 创建由 service 定义的 API 的实现。
 * return  类型还是为 T 的代理对象    
 */
public &lt;T&gt; T create(final Class&lt;T&gt; service) {
    // 检查 service 是否合法，必须是接口且只有 1 个接口，
    Utils.validateServiceInterface(service);
    // 创建的时候如果设置验证方法就先验证，否则只在动态代理里面验证。
    if (validateEagerly) {  
      eagerlyValidateMethods(service);
    }
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();

          @Override public Object invoke(Object proxy, Method method, Object... args)
              throws Throwable {
            // If the method is a method from Object then defer to normal invocation.
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            ServiceMethod serviceMethod = loadServiceMethod(method);
            OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
            return serviceMethod.callAdapter.adapt(okHttpCall);
          }
        });
  }
</code></pre>
<p>很明显这是一个 Java 动态代理。这个方法在 <code>ServiceApi serviceApi = build.create(ServiceApi.class);</code> 调用，返回的是一个代理对象。<br>在<code>invoke(Object proxy, Method method, Object... args)</code>中，Retrofit 只关心 method 和 args 两个参数。<br>核心代码是这 3 句：</p>
<pre><code class="java">ServiceMethod serviceMethod = loadServiceMethod(method);
OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre>
<h2 id="ServcieMethod"><a href="#ServcieMethod" class="headerlink" title="ServcieMethod"></a>ServcieMethod</h2><p>ServiceMethod就像是一个中央处理器，传入Retrofit对象和Method对象，调用各个接口和解析器，最终生成一个Request，包含api 的域名、path、http请求方法、请求头、是否有body、是否是multipart等等。最后返回一个Call对象，Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。  </p>
<p>使用Java动态代理的目的就要拦截被调用的Java方法，然后解析这个Java方法的注解，最后生成Request由OkHttp发送。</p>
<p>先看 <code>loadServiceMethod(method)</code>，从这里面得到一个 ServiceMethod</p>
<pre><code class="java"> ServiceMethod loadServiceMethod(Method method) {
    ServiceMethod result;
    synchronized (serviceMethodCache) {
      // 先从缓存中取
      result = serviceMethodCache.get(method);
      if (result == null) {
          // 如果没有就新建，然后加入缓存
        result = new ServiceMethod.Builder(this, method).build();
        serviceMethodCache.put(method, result);
      }
    }
    return result;
  }
</code></pre>
<p>  build方法里面创建了CallAdapter和Converter。处理注解，将其转化成OkHttp Call。</p>
<pre><code class="java"> /**
   * 创建 CallAdapter，创建 Converter，解析注释
   * ServiceMethod 的作用是将接口方法的调用适配为 HTTP Call
   * return ServiceMethod 对象
   */
 public ServiceMethod build() {

        // 创建callAdapter
        callAdapter = createCallAdapter();
        responseType = callAdapter.responseType();
        // 创建Converter
        responseConverter = createResponseConverter();
        // 遍历，解析方法注释
        for (Annotation annotation : methodAnnotations) {
            parseMethodAnnotation(annotation);
        }

        // 参数里的注解的个数
        int parameterCount = parameterAnnotationsArray.length;
        // 创建对应的 parameterHandlers数组。将每个参数的注解解析成parameterHandler对象存入数组。
        parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
        for (int p = 0; p &lt; parameterCount; p++) {
            Type parameterType = parameterTypes[p];

            Annotation[] parameterAnnotations = parameterAnnotationsArray[p];

            parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);
        }

        return new ServiceMethod&lt;&gt;(this);
    }
</code></pre>
<p>这里的parameterHandlers 负责解析API定义时每个方法的参数，并在构造HTTP请求时设置参数。</p>
<h3 id="解析方法注释"><a href="#解析方法注释" class="headerlink" title="解析方法注释"></a>解析方法注释</h3><pre><code class="java">private void parseMethodAnnotation(Annotation annotation) {
    if (annotation instanceof DELETE) {
        parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);
    } else if (annotation instanceof GET) {
        parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);
    }

    // ...省略代码
}
</code></pre>
<pre><code class="java">    private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {

      this.httpMethod = httpMethod;
      this.hasBody = hasBody;

      if (value.isEmpty()) {
        return;
      }

      // Get the relative URL path and existing query string, if present.
      int question = value.indexOf(&#39;?&#39;);
      if (question != -1 &amp;&amp; question &lt; value.length() - 1) {
        // Ensure the query string does not have any named parameters.
        String queryParams = value.substring(question + 1);
        Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);

      }

      this.relativeUrl = value;
      this.relativeUrlParamNames = parsePathParameters(value);
}

static Set&lt;String&gt; parsePathParameters(String path) {
    Matcher m = PARAM_URL_REGEX.matcher(path);
    Set&lt;String&gt; patterns = new LinkedHashSet&lt;&gt;();
    while (m.find()) {
      patterns.add(m.group(1));
    }
    return patterns;
}
</code></pre>
<h3 id="parameterHandlers"><a href="#parameterHandlers" class="headerlink" title="parameterHandlers"></a>parameterHandlers</h3><blockquote>
<p>每个参数都会有一个 ParameterHandler，由 ServiceMethod#parseParameter 方法负责创建，其主要内容就是解析每个参数使用的注解类型（诸如 Path，Query，Field 等），对每种类型进行单独的处理。构造 HTTP 请求时，我们传递的参数都是字符串，那 Retrofit 是如何把我们传递的各种参数都转化为 String 的呢？还是由 Retrofit 类提供 converter！<br>Converter.Factory 除了提供上一小节提到的 responseBodyConverter，还提供 requestBodyConverter 和 stringConverter，API 方法中除了 @Body 和 @Part 类型的参数，都利用 stringConverter 进行转换，而 @Body 和 @Part 类型的参数则利用 requestBodyConverter 进行转换。</p>
</blockquote>
<h2 id="CallAdapter-1"><a href="#CallAdapter-1" class="headerlink" title="CallAdapter"></a>CallAdapter</h2><pre><code class="java">    // #ServiceMethod.java

this.callFactory = builder.retrofit.callFactory();
</code></pre>
<p>CallAdapter由retrofit提供，我们可以自己指定，默认是okhttp3.OkHttpClient。</p>
<p>创建callAdapter由retrofit完成。</p>
<pre><code class="java">private CallAdapter&lt;T, R&gt; createCallAdapter() {
    return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);
}

 // # Retrofit.java
 public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {
        return nextCallAdapter(null, returnType, annotations);
 }
</code></pre>
<p>最终走到nextCallAdapter()，通过CallAdapter.Factory来创造。</p>
<pre><code class="java">public CallAdapter&lt;?, ?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType,
                                             Annotation[] annotations) {
    // ...省略多若干码

    // 去除skipPast这个过去的工厂，Retrofit默认传的是null。
    int start = adapterFactories.indexOf(skipPast) + 1;
    // 遍历取出第一个工厂，获得adapter。
    for (int i = start, count = adapterFactories.size(); i &lt; count; i++) {
        CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);
        if (adapter != null) {
            return adapter;
        }
    }
}
</code></pre>
<h2 id="ResponseConverter"><a href="#ResponseConverter" class="headerlink" title="ResponseConverter"></a>ResponseConverter</h2><p>和callAdapter一样，也是由Retrofit创建的。通过遍历 Converter.Factory 列表，看看有没有工厂能够提供需要的 responseBodyConverter。工厂列表同样可以在构造 Retrofit 对象时进行添加。</p>
<h2 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><p>OkHttpCall实现了Call接口。</p>
<p>okHttpCall 关键的部分是:</p>
<pre><code class="java">private okhttp3.Call createRawCall() throws IOException {
    Request request = serviceMethod.toRequest(args);
    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
    if (call == null) {
      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
    }
    return call;
  }


  // ServiceMethod.java # toRequest() 
  /** Builds an HTTP request from method arguments. */
  Request toRequest(Object... args) throws IOException {
    RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,
        contentType, hasBody, isFormEncoded, isMultipart);

    @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;

    // 省略部分检查代码

    for (int p = 0; p &lt; argumentCount; p++) {
      handlers[p].apply(requestBuilder, args[p]);
    }

    return requestBuilder.build();
  }
</code></pre>
<p>这里由serviceMethod创建request，之前的ParameterHandler这里就用到了，这里把参数传进去一起组成完整request。并且由serviceMethod里的callFactory创建一个Call，默认就是OkHttpCall。  </p>
<p>调用execute()执行同步请求：</p>
<pre><code class="java">@Override public Response&lt;T&gt; execute() throws IOException {
    okhttp3.Call call;

    // 省略判断代码...

    call = rawCall = createRawCall();

    // 省略判断代码...

    // 最终调用 parseResponse 解析返回的结果
    return parseResponse(call.execute());
  }

Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {
    ResponseBody rawBody = rawResponse.body();

    // Remove the body&#39;s source (the only stateful object) so we can pass the response along.
    rawResponse = rawResponse.newBuilder()
        .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))
        .build();

    int code = rawResponse.code();
    if (code &lt; 200 || code &gt;= 300) {
      try {
        // Buffer the entire body to avoid future I/O.
        ResponseBody bufferedBody = Utils.buffer(rawBody);
        return Response.error(bufferedBody, rawResponse);
      } finally {
        rawBody.close();
      }
    }

    if (code == 204 || code == 205) {
      rawBody.close();
      return Response.success(null, rawResponse);
    }

    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
    try {

      // 这里调用serviceMethod中的方法用对应的ConvertFactory转换
      T body = serviceMethod.toResponse(catchingBody);
      return Response.success(body, rawResponse);
    } catch (RuntimeException e) {
      // If the underlying source threw an exception, propagate that rather than indicating it was
      // a runtime exception.
      catchingBody.throwIfCaught();
      throw e;
    }
  }
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.stay4it.com/course/22/learn#lesson/258" target="_blank" rel="external"> Retrofit源码分析 - 有心课堂</a>  </p>
<p><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路
</a></p>
<p><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit 官方文档</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/21662195" target="_blank" rel="external">「Android技术汇」Retrofit2 源码解析和案例说明</a></p>
<p><a href="http://www.println.net/post/deep-in-retrofit" target="_blank" rel="external">深入浅出 Retrofit，这么牛逼的框架你们还不来看看？
</a></p>
<p><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/" target="_blank" rel="external">拆轮子系列：拆 Retrofit
</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Retrofit/" rel="tag"># Retrofit</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/15/工厂方法模式 /" rel="next" title="工厂方法模式">
                <i class="fa fa-chevron-left"></i> 工厂方法模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/24/yishuyansuo3/" rel="prev" title="Android开发艺术探索笔记-第3章 View的事件体系">
                Android开发艺术探索笔记-第3章 View的事件体系 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="luwenjie" />
          <p class="site-author-name" itemprop="name">luwenjie</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Retrofit的类的结构"><span class="nav-number">2.</span> <span class="nav-text">Retrofit的类的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Call"><span class="nav-number">2.1.</span> <span class="nav-text">Call</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CallAdapter"><span class="nav-number">2.2.</span> <span class="nav-text">CallAdapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callback"><span class="nav-number">2.3.</span> <span class="nav-text">Callback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Converter"><span class="nav-number">2.4.</span> <span class="nav-text">Converter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正常请求网络的套路"><span class="nav-number">3.</span> <span class="nav-text">正常请求网络的套路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#举个栗子"><span class="nav-number">4.</span> <span class="nav-text">举个栗子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServcieMethod"><span class="nav-number">5.</span> <span class="nav-text">ServcieMethod</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析方法注释"><span class="nav-number">5.1.</span> <span class="nav-text">解析方法注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parameterHandlers"><span class="nav-number">5.2.</span> <span class="nav-text">parameterHandlers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CallAdapter-1"><span class="nav-number">6.</span> <span class="nav-text">CallAdapter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ResponseConverter"><span class="nav-number">7.</span> <span class="nav-text">ResponseConverter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttpCall"><span class="nav-number">8.</span> <span class="nav-text">OkHttpCall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">9.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luwenjie</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "2ab4175d0069412cbcb722431b663013",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  

  

  

  

  

</body>
</html>
