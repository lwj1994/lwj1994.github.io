<!doctype html>




<html class="theme-next muse" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="学习笔记," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="上篇自定义 View 笔记 2 - MeasureSpec 详解分析了MeasureSpec生成的原理，父容器测量子 View首先确定MeasureSpec，再让子View测量自己。">
<meta name="keywords" content="学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="自定义 View 笔记 3 - onMeasure() 的过程">
<meta property="og:url" content="https://luwenjie.me/2017/01/19/自定义 View onMeasure() 的过程/index.html">
<meta property="og:site_name" content="luwenjie&#39;s Blog">
<meta property="og:description" content="上篇自定义 View 笔记 2 - MeasureSpec 详解分析了MeasureSpec生成的原理，父容器测量子 View首先确定MeasureSpec，再让子View测量自己。">
<meta property="og:image" content="http://7xt4re.com1.z0.glb.clouddn.com/2017012440753Jietu20170124-155630.jpg?imageView/2/w/300/q/100">
<meta property="og:image" content="http://cuntuku.com/images/2017/01/19/Jietu20170119-222605.jpg">
<meta property="og:image" content="http://cuntuku.com/images/2017/01/17/QQ20170117-2140552x.png">
<meta property="og:updated_time" content="2017-01-29T10:13:43.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="自定义 View 笔记 3 - onMeasure() 的过程">
<meta name="twitter:description" content="上篇自定义 View 笔记 2 - MeasureSpec 详解分析了MeasureSpec生成的原理，父容器测量子 View首先确定MeasureSpec，再让子View测量自己。">
<meta name="twitter:image" content="http://7xt4re.com1.z0.glb.clouddn.com/2017012440753Jietu20170124-155630.jpg?imageView/2/w/300/q/100">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://luwenjie.me/2017/01/19/自定义 View onMeasure() 的过程/"/>





  <title>自定义 View 笔记 3 - onMeasure() 的过程 | luwenjie's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">luwenjie's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-tags " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://luwenjie.me/2017/01/19/自定义 View onMeasure() 的过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luwenjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="luwenjie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">自定义 View 笔记 3 - onMeasure() 的过程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-19T22:23:00+08:00">
                2017-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/自定义-View/" itemprop="url" rel="index">
                    <span itemprop="name">自定义 View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2017/01/19/自定义 View onMeasure() 的过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上篇<a href="https://luwenjie.me/2017/01/19/%E8%87%AA%E5%AE%9A%E4%B9%89%20View%20%E7%AC%94%E8%AE%B0%20-%20MeasureSpec%20%E8%AF%A6%E8%A7%A3/">自定义 View 笔记 2 - MeasureSpec 详解</a>分析了MeasureSpec生成的原理，父容器测量子 View首先确定MeasureSpec，再让子View测量自己。<br><a id="more"></a></p>
<p>完整的流程图是这样的：</p>
<p><img src="http://7xt4re.com1.z0.glb.clouddn.com/2017012440753Jietu20170124-155630.jpg?imageView/2/w/300/q/100" alt=""></p>
<p>父类和子类共同确定完子类的MeassureSpec后，子类就要测量自身的尺寸。</p>
<p>其中子View测量自身源码的调用流程图：<br><img src="http://cuntuku.com/images/2017/01/19/Jietu20170119-222605.jpg" alt="子View OnMeasure() 的过程"><br>我们从尾到头看一下源码的实现。</p>
<h2 id="View-getSuggestedMinimumWidth-amp-View-getSuggestedMinimumHeight"><a href="#View-getSuggestedMinimumWidth-amp-View-getSuggestedMinimumHeight" class="headerlink" title="View#getSuggestedMinimumWidth() &amp; View#getSuggestedMinimumHeight()"></a>View#getSuggestedMinimumWidth() &amp; View#getSuggestedMinimumHeight()</h2><pre><code class="java">  /**
   * 返回视图的最小宽度。先比较视图的最小值和背景的最小值，返回较小的。
   * @return 建议的视图最小宽度
   */
  protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
  }

  /**
   * 返回视图的最小高度。先比较视图的最小值和背景的最小值，返回较小的。
   * @return 建议的视图最小高度
   */
  protected int getSuggestedMinimumHeight() {
    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());
  }
</code></pre>
<h2 id="View-getDefaultSize-int-int-："><a href="#View-getDefaultSize-int-int-：" class="headerlink" title="View#getDefaultSize(int, int)："></a>View#getDefaultSize(int, int)：</h2><pre><code class="java">  /**
   * 返回一个默认的大小。如果 MeasureSpec 没有约束，则使用提供的大小。
   *
   * @param size View 的默认大小
   * @param measureSpec 此视图的 MeasureSpec
   * @return View 应该得到的默认大小
   */
  public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    // 获得此视图的测量模式
    int specMode = View.MeasureSpec.getMode(measureSpec);
    // 获得此时图的测量大小
    int specSize = View.MeasureSpec.getSize(measureSpec);

    switch (specMode) {
      // 如果未限制，结果为 View 的默认大小
      case View.MeasureSpec.UNSPECIFIED:
        result = size;
        break;
      // 如果限制为准确模式或最大模式，结果为 MeasureSpec 的测量大小
      case View.MeasureSpec.AT_MOST:
      case View.MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
  }
</code></pre>
<h2 id="View-setMeasuredDimension-int-int"><a href="#View-setMeasuredDimension-int-int" class="headerlink" title="View#setMeasuredDimension(int, int)"></a>View#setMeasuredDimension(int, int)</h2><pre><code class="java">  /**
   * 这个方法必须由 onMeasure(int, int) 调用来存储测量宽度和测量高度。如果没有调用会触发测量时异常。
   *
   * @param measuredWidth 此视图的测量宽度
   * @param measuredHeight 此视图的测量高度
   */
  protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
      Insets insets = getOpticalInsets();
      int opticalWidth = insets.left + insets.right;
      int opticalHeight = insets.top + insets.bottom;

      measuredWidth += optical ? opticalWidth : -opticalWidth;
      measuredHeight += optical ? opticalHeight : -opticalHeight;
    }
    setMeasuredDimensionRaw(measuredWidth, measuredHeight);
  }
</code></pre>
<p>上述方法最终调用 View#setMeasuredDimensionRaw(int, int)</p>
<pre><code class="java">  /**
   * 原始的设置测量的尺寸。
   * @param measuredWidth
   * @param measuredHeight
   */
  private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
    // 赋值
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;

    // 设置 flag
    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
  }
</code></pre>
<h2 id="View-onMeasure-int-int"><a href="#View-onMeasure-int-int" class="headerlink" title="View#onMeasure(int, int)"></a>View#onMeasure(int, int)</h2><pre><code class="java">  /**
   * 测量视图及其内容以确定测量的宽度和测量的高度。 此方法由 measure（int，int）调用，应由子类覆盖以提供其内容的准确和高效的测量。
   *
   * 当覆写这个方法的时候，必须调用 setMeasuredDimension(int, int) 存储视图的测量宽度和高度。否则会被 measure() 抛出 IllegalStateException。
   *
   * 可以直接调用父类的 onMeasure(int, int)
   *
   * 除非 MeasureSpec 允许更大的尺寸，测量的基本类实现默认是背景的大小。子类应该重写 onMeasure(int, int)，提供更好的内容测量。
   *
   * 如果这个方法被覆盖，子类必须保证测量的高度和宽度不小于视图的最小高度和宽度。
   * @param widthMeasureSpec 此 View 的宽的 MeasureSpec
   * @param heightMeasureSpec 此 View 的高的 MeasureSpec
   */
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
  }
</code></pre>
<h2 id="为什么自定义View设置为WRAP-CONTENT，最后显示的效果是MATCH-PARENT"><a href="#为什么自定义View设置为WRAP-CONTENT，最后显示的效果是MATCH-PARENT" class="headerlink" title="为什么自定义View设置为WRAP_CONTENT，最后显示的效果是MATCH_PARENT?"></a>为什么自定义View设置为<code>WRAP_CONTENT</code>，最后显示的效果是<code>MATCH_PARENT</code>?</h2><p>根据上篇总结的MeasureSpec生成的规则表可以得知，如果子View的布局参数是<code>WRAP_CONTENT</code>，不管父容器的MeasureSpec模式是<code>EXACTLY</code>还是<code>AT_MOST</code>，子View的MeasureSpec模式都是<code>AT_MOST</code>，且大小都为父容器剩下的大小。</p>
<p><a href="http://img.blog.csdn.net/20160510112048981" target="_blank" rel="external"><img src="http://cuntuku.com/images/2017/01/17/QQ20170117-2140552x.png" alt=""></a></p>
<p>所以我们虽然设置了<code>WRAP_CONTENT</code>，最后看到的效果却是<code>MATCH_PARENT</code>。</p>
<h3 id="如何fix这个问题？"><a href="#如何fix这个问题？" class="headerlink" title="如何fix这个问题？"></a>如何fix这个问题？</h3><p>我们通过重写<code>onMeasure()</code>处理宽或高为<code>WRAP_CONTENT</code>的情况。</p>
<pre><code class="java">@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
  super.onMeasure(widthMeasureSpec, heightMeasureSpec);

  int widthMode = MeasureSpec.getMode(widthMeasureSpec);
  int widthSize = MeasureSpec.getSize(widthMeasureSpec);

  int heightMode = MeasureSpec.getMode(heightMeasureSpec);
  int heightSize = MeasureSpec.getSize(heightMeasureSpec);

  // 如果宽和高都是AT_MOST模式，宽和高都设置为默认值，否则宽或高另设默认值
  if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) {
    setMeasuredDimension(mWidth, mHeight);
  } else if (widthMode == MeasureSpec.AT_MOST) {
    setMeasuredDimension(mWidth, heightSize);
  } else if (heightMode == MeasureSpec.AT_MOST) {
    setMeasuredDimension(widthSize, mHeight);
  }
}
</code></pre>
<h2 id="子View布局为MATCH-PARENT，父容器的模式为AT-MOST的情况"><a href="#子View布局为MATCH-PARENT，父容器的模式为AT-MOST的情况" class="headerlink" title="子View布局为MATCH_PARENT，父容器的模式为AT_MOST的情况"></a>子View布局为<code>MATCH_PARENT</code>，父容器的模式为<code>AT_MOST</code>的情况</h2><p>对照上面的MeasureSpec生成规则图，有这种情况：如果子View布局参数为<code>MATCH_PARENT</code>，父容器的模式为<code>AT_MOST</code>，那么子View的MeasureSpec模式为<code>AT_MOST</code>，大小为父容器剩下的大小。</p>
<p>如果这种情况下我们也根据判断是否为<code>AT_MOST</code>模式进行默认值赋值。那么子View的大小结果就是一个准确的值，而它的模式却是<code>MATCH_PARENT</code>。</p>
<p>这种情况是不合理的：  </p>
<ol>
<li><p>不可能出现根View的大小为wrap_content但它的一个子View大小为match_parent。</p>
</li>
<li><p>从根到这个子View的父容器都是wrap_content，而子View的大小为match_parent。这个极端情况也是不会的。</p>
</li>
<li><p>从根到这个子View的父容器都是wrap_content，而子View大小也为wrap_content。这是个正常情况也正是我们改良后的onMeasure()来专门处理的子View大小为wrap_content的情况。  </p>
</li>
</ol>
<h2 id="LinearLayout的测量过程"><a href="#LinearLayout的测量过程" class="headerlink" title="LinearLayout的测量过程"></a>LinearLayout的测量过程</h2><p><code>public abstract class ViewGroup extends View implements ViewParent, ViewManager</code>  </p>
<p>ViewGroup是一个抽象类，它没有重写View的<code>onMeasure()</code>。容器类继承ViewGroup并根据自身的情况重写<code>onMeasure()</code>。</p>
<h3 id="父容器类如何测量子View并且确定自身的大小？"><a href="#父容器类如何测量子View并且确定自身的大小？" class="headerlink" title="父容器类如何测量子View并且确定自身的大小？"></a>父容器类如何测量子View并且确定自身的大小？</h3><p>我们看看LinearLayout是如何做的。</p>
<h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h4><pre><code class="java">    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (mOrientation == VERTICAL) {
            measureVertical(widthMeasureSpec, heightMeasureSpec);
        } else {
            measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        }
    }
</code></pre>
<h4 id="measureVertical"><a href="#measureVertical" class="headerlink" title="measureVertical()"></a>measureVertical()</h4><pre><code class="java">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;

    final int count = getVirtualChildCount();

    final int widthMode = View.MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = View.MeasureSpec.getMode(heightMeasureSpec);

    boolean matchWidth = false;
    boolean skippedMeasure = false;

    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;

    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;

    // 遍历得到每个孩子的高度，并记录最大宽度。
    for (int i = 0; i &lt; count; ++i) {
      final View child = getVirtualChildAt(i);
      // 若孩子为空，跳出本次循环
      if (child == null) {
        mTotalLength += measureNullChild(i);
        continue;
      }

      // 孩子的显示状态为GONE
      if (child.getVisibility() == GONE) {
        i += getChildrenSkipCount(child, i);
        continue;
      }

      // 判断是否有分割线
      if (hasDividerBeforeChildAt(i)) {
        mTotalLength += mDividerHeight;
      }

      // 得到孩子的LayoutParams
      final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

      // weight累加到总weight上
      totalWeight += lp.weight;

      final boolean useExcessSpace = lp.height == 0 &amp;&amp; lp.weight &gt; 0;
      if (heightMode == View.MeasureSpec.EXACTLY &amp;&amp; useExcessSpace) {
        // Optimization: don&#39;t bother measuring children who are only
        // laid out using excess space. These views will get measured
        // later if we have space to distribute.
        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        skippedMeasure = true;
      } else {
        if (useExcessSpace) {
          // The heightMode is either UNSPECIFIED or AT_MOST, and
          // this child is only laid out using excess space. Measure
          // using WRAP_CONTENT so that we can find out the view&#39;s
          // optimal height. We&#39;ll restore the original height of 0
          // after measurement.
          lp.height = LinearLayout.LayoutParams.WRAP_CONTENT;
        }

        // Determine how big this child would like to be. If this or
        // previous children have given a weight, then we allow it to
        // use all available space (and we will shrink things later
        // if needed).
        final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
        measureChildBeforeLayout(child, i, widthMeasureSpec, 0,
            heightMeasureSpec, usedHeight);

        final int childHeight = child.getMeasuredHeight();
        if (useExcessSpace) {
          // Restore the original height and record how much space
          // we&#39;ve allocated to excess-only children so that we can
          // match the behavior of EXACTLY measurement.
          lp.height = 0;
          consumedExcessSpace += childHeight;
        }

        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
            lp.bottomMargin + getNextLocationOffset(child));

        if (useLargestChild) {
          largestChildHeight = Math.max(childHeight, largestChildHeight);
        }
      }

      /**
       * If applicable, compute the additional offset to the child&#39;s baseline
       * we&#39;ll need later when asked {@link #getBaseline}.
       */
      if ((baselineChildIndex &gt;= 0) &amp;&amp; (baselineChildIndex == i + 1)) {
        mBaselineChildTop = mTotalLength;
      }

      // if we are trying to use a child index for our baseline, the above
      // book keeping only works if there are no children above it with
      // weight.  fail fast to aid the developer.
      if (i &lt; baselineChildIndex &amp;&amp; lp.weight &gt; 0) {
        throw new RuntimeException(&quot;A child of LinearLayout with index &quot;
            + &quot;less than mBaselineAlignedChildIndex has weight &gt; 0, which &quot;
            + &quot;won&#39;t work.  Either remove the weight, or don&#39;t set &quot;
            + &quot;mBaselineAlignedChildIndex.&quot;);
      }

      boolean matchWidthLocally = false;
      if (widthMode != View.MeasureSpec.EXACTLY &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT) {
        // The width of the linear layout will scale, and at least one
        // child said it wanted to match our width. Set a flag
        // indicating that we need to remeasure at least that view when
        // we know our width.
        matchWidth = true;
        matchWidthLocally = true;
      }

      final int margin = lp.leftMargin + lp.rightMargin;
      final int measuredWidth = child.getMeasuredWidth() + margin;
      maxWidth = Math.max(maxWidth, measuredWidth);
      childState = combineMeasuredStates(childState, child.getMeasuredState());

      allFillParent = allFillParent &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT;
      if (lp.weight &gt; 0) {
                /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
        weightedMaxWidth = Math.max(weightedMaxWidth,
            matchWidthLocally ? margin : measuredWidth);
      } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth,
            matchWidthLocally ? margin : measuredWidth);
      }

      i += getChildrenSkipCount(child, i);
    }

    if (mTotalLength &gt; 0 &amp;&amp; hasDividerBeforeChildAt(count)) {
      mTotalLength += mDividerHeight;
    }

    if (useLargestChild &amp;&amp;
        (heightMode == View.MeasureSpec.AT_MOST || heightMode == View.MeasureSpec.UNSPECIFIED)) {
      mTotalLength = 0;

      for (int i = 0; i &lt; count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
          mTotalLength += measureNullChild(i);
          continue;
        }

        if (child.getVisibility() == GONE) {
          i += getChildrenSkipCount(child, i);
          continue;
        }

        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
            child.getLayoutParams();
        // Account for negative margins
        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
            lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
      }
    }

    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;

    int heightSize = mTotalLength;

    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());

    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK;

    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength
        + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 &amp;&amp; totalWeight &gt; 0.0f) {
      float remainingWeightSum = mWeightSum &gt; 0.0f ? mWeightSum : totalWeight;

      mTotalLength = 0;

      for (int i = 0; i &lt; count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null || child.getVisibility() == GONE) {
          continue;
        }

        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        final float childWeight = lp.weight;
        if (childWeight &gt; 0) {
          final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
          remainingExcess -= share;
          remainingWeightSum -= childWeight;

          final int childHeight;
          if (mUseLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) {
            childHeight = largestChildHeight;
          } else if (lp.height == 0 &amp;&amp; (!mAllowInconsistentMeasurement
              || heightMode == View.MeasureSpec.EXACTLY)) {
            // This child needs to be laid out from scratch using
            // only its share of excess space.
            childHeight = share;
          } else {
            // This child had some intrinsic height to which we
            // need to add its share of excess space.
            childHeight = child.getMeasuredHeight() + share;
          }

          final int childHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec(
              Math.max(0, childHeight), View.MeasureSpec.EXACTLY);
          final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
              mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin,
              lp.width);
          child.measure(childWidthMeasureSpec, childHeightMeasureSpec);

          // Child may now not fit in vertical dimension.
          childState = combineMeasuredStates(childState, child.getMeasuredState()
              &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));
        }

        final int margin =  lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);

        boolean matchWidthLocally = widthMode != View.MeasureSpec.EXACTLY &amp;&amp;
            lp.width == LinearLayout.LayoutParams.MATCH_PARENT;

        alternativeMaxWidth = Math.max(alternativeMaxWidth,
            matchWidthLocally ? margin : measuredWidth);

        allFillParent = allFillParent &amp;&amp; lp.width == LinearLayout.LayoutParams.MATCH_PARENT;

        final int totalLength = mTotalLength;
        mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() +
            lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
      }

      // Add in our padding
      mTotalLength += mPaddingTop + mPaddingBottom;
      // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
      alternativeMaxWidth = Math.max(alternativeMaxWidth,
          weightedMaxWidth);


      // We have no limit, so make all weighted views as tall as the largest child.
      // Children will have already been measured once.
      if (useLargestChild &amp;&amp; heightMode != View.MeasureSpec.EXACTLY) {
        for (int i = 0; i &lt; count; i++) {
          final View child = getVirtualChildAt(i);
          if (child == null || child.getVisibility() == GONE) {
            continue;
          }

          final LinearLayout.LayoutParams lp =
              (LinearLayout.LayoutParams) child.getLayoutParams();

          float childExtra = lp.weight;
          if (childExtra &gt; 0) {
            child.measure(
                View.MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                    View.MeasureSpec.EXACTLY),
                View.MeasureSpec.makeMeasureSpec(largestChildHeight,
                    View.MeasureSpec.EXACTLY));
          }
        }
      }
    }

    if (!allFillParent &amp;&amp; widthMode != View.MeasureSpec.EXACTLY) {
      maxWidth = alternativeMaxWidth;
    }

    maxWidth += mPaddingLeft + mPaddingRight;

    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());

    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
        heightSizeAndState);

    if (matchWidth) {
      forceUniformWidth(count, heightMeasureSpec);
    }
  }
</code></pre>
<p>这段代码的主要操作：</p>
<ol>
<li>遍历每个子View，并对每个子View调用measureChildBeforeLayout()，请参见代码第115-133行<br>在measureChildBeforeLayout()方法内又会调用measureChildWithMargins()从而测量每个子View的大小。在该过程中mTotalLength保存了LinearLayout的高度，所以每当测量完一个子View该值都会发生变化。</li>
<li>调用setMeasuredDimension()设置LinearLayout的大小。</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/学习笔记/" rel="tag"># 学习笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/19/自定义 View 笔记 - MeasureSpec 详解/" rel="next" title="自定义 View 笔记 2 - MeasureSpec 详解">
                <i class="fa fa-chevron-left"></i> 自定义 View 笔记 2 - MeasureSpec 详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/25/Android中的groovy及Gradle/" rel="prev" title="Android中的groovy及gradle">
                Android中的groovy及gradle <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="luwenjie" />
          <p class="site-author-name" itemprop="name">luwenjie</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#View-getSuggestedMinimumWidth-amp-View-getSuggestedMinimumHeight"><span class="nav-number">1.</span> <span class="nav-text">View#getSuggestedMinimumWidth() & View#getSuggestedMinimumHeight()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-getDefaultSize-int-int-："><span class="nav-number">2.</span> <span class="nav-text">View#getDefaultSize(int, int)：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-setMeasuredDimension-int-int"><span class="nav-number">3.</span> <span class="nav-text">View#setMeasuredDimension(int, int)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-onMeasure-int-int"><span class="nav-number">4.</span> <span class="nav-text">View#onMeasure(int, int)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么自定义View设置为WRAP-CONTENT，最后显示的效果是MATCH-PARENT"><span class="nav-number">5.</span> <span class="nav-text">为什么自定义View设置为WRAP_CONTENT，最后显示的效果是MATCH_PARENT?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何fix这个问题？"><span class="nav-number">5.1.</span> <span class="nav-text">如何fix这个问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子View布局为MATCH-PARENT，父容器的模式为AT-MOST的情况"><span class="nav-number">6.</span> <span class="nav-text">子View布局为MATCH_PARENT，父容器的模式为AT_MOST的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinearLayout的测量过程"><span class="nav-number">7.</span> <span class="nav-text">LinearLayout的测量过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#父容器类如何测量子View并且确定自身的大小？"><span class="nav-number">7.1.</span> <span class="nav-text">父容器类如何测量子View并且确定自身的大小？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#onMeasure"><span class="nav-number">7.1.1.</span> <span class="nav-text">onMeasure()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#measureVertical"><span class="nav-number">7.1.2.</span> <span class="nav-text">measureVertical()</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luwenjie</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "2ab4175d0069412cbcb722431b663013",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  

  

  

  

  

</body>
</html>
